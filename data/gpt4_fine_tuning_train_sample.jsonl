{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-732"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) {\n  NavigationEntry* pending_entry = controller_->GetPendingEntry();\n  bool pending_matches_fail_msg =\n      pending_entry &&\n      expected_pending_entry_id == pending_entry->GetUniqueID();\n  if (!pending_matches_fail_msg)\n    return;\n\n  bool should_preserve_entry = controller_->IsUnmodifiedBlankTab() ||\n                               delegate_->ShouldPreserveAbortedURLs();\n   if (pending_entry != controller_->GetVisibleEntry() ||\n       !should_preserve_entry) {\n     controller_->DiscardPendingEntry(true);\n\n    controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t__be32 daddr;\n\t__be16 dport;\n\tstruct rds_message *rm = NULL;\n\tstruct rds_connection *conn;\n\tint ret = 0;\n\tint queued = 0, allocated_mr = 0;\n\tint nonblock = msg->msg_flags & MSG_DONTWAIT;\n\tlong timeo = sock_sndtimeo(sk, nonblock);\n\n\t/* Mirror Linux UDP mirror of BSD error message compatibility */\n\t/* XXX: Perhaps MSG_MORE someday */\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (msg->msg_namelen) {\n\t\t/* XXX fail non-unicast destination IPs? */\n\t\tif (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t} else {\n\t\t/* We only care about consistency with ->connect() */\n\t\tlock_sock(sk);\n\t\tdaddr = rs->rs_conn_addr;\n\t\tdport = rs->rs_conn_port;\n \t\trelease_sock(sk);\n \t}\n \n\t/* racing with another thread binding seems ok here */\n \tif (daddr == 0 || rs->rs_bound_addr == 0) {\n \t\tret = -ENOTCONN; /* XXX not a great errno */\n \t\tgoto out;\n \t}\n \n \tif (payload_len > rds_sk_sndbuf(rs)) {\n \t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\t/* size of rm including all sgs */\n\tret = rds_rm_size(msg, payload_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trm = rds_message_alloc(ret, GFP_KERNEL);\n\tif (!rm) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Attach data to the rm */\n\tif (payload_len) {\n\t\trm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));\n\t\tif (!rm->data.op_sg) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = rds_message_copy_from_user(rm, &msg->msg_iter);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\trm->data.op_active = 1;\n\n\trm->m_daddr = daddr;\n\n\t/* rds_conn_create has a spinlock that runs with IRQ off.\n\t * Caching the conn in the socket helps a lot. */\n\tif (rs->rs_conn && rs->rs_conn->c_faddr == daddr)\n\t\tconn = rs->rs_conn;\n\telse {\n\t\tconn = rds_conn_create_outgoing(sock_net(sock->sk),\n\t\t\t\t\t\trs->rs_bound_addr, daddr,\n\t\t\t\t\trs->rs_transport,\n\t\t\t\t\tsock->sk->sk_allocation);\n\t\tif (IS_ERR(conn)) {\n\t\t\tret = PTR_ERR(conn);\n\t\t\tgoto out;\n\t\t}\n\t\trs->rs_conn = conn;\n\t}\n\n\t/* Parse any control messages the user may have included. */\n\tret = rds_cmsg_send(rs, rm, msg, &allocated_mr);\n\tif (ret)\n\t\tgoto out;\n\n\tif (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {\n\t\tprintk_ratelimited(KERN_NOTICE \"rdma_op %p conn xmit_rdma %p\\n\",\n\t\t\t       &rm->rdma, conn->c_trans->xmit_rdma);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {\n\t\tprintk_ratelimited(KERN_NOTICE \"atomic_op %p conn xmit_atomic %p\\n\",\n\t\t\t       &rm->atomic, conn->c_trans->xmit_atomic);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trds_conn_connect_if_down(conn);\n\n\tret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);\n\tif (ret) {\n\t\trs->rs_seen_congestion = 1;\n\t\tgoto out;\n\t}\n\n\twhile (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,\n\t\t\t\t  dport, &queued)) {\n\t\trds_stats_inc(s_send_queue_full);\n\n\t\tif (nonblock) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\trds_send_queue_rm(rs, conn, rm,\n\t\t\t\t\t\t\t  rs->rs_bound_port,\n\t\t\t\t\t\t\t  dport,\n\t\t\t\t\t\t\t  &queued),\n\t\t\t\t\ttimeo);\n\t\trdsdebug(\"sendmsg woke queued %d timeo %ld\\n\", queued, timeo);\n\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\tcontinue;\n\n\t\tret = timeo;\n\t\tif (ret == 0)\n\t\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * By now we've committed to the send.  We reuse rds_send_worker()\n\t * to retry sends in the rds thread if the transport asks us to.\n\t */\n\trds_stats_inc(s_send_queued);\n\n\tret = rds_send_xmit(conn);\n\tif (ret == -ENOMEM || ret == -EAGAIN)\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 1);\n\n\trds_message_put(rm);\n\treturn payload_len;\n\nout:\n\t/* If the user included a RDMA_MAP cmsg, we allocated a MR on the fly.\n\t * If the sendmsg goes through, we keep the MR. If it fails with EAGAIN\n\t * or in any other way, we need to destroy the MR again */\n\tif (allocated_mr)\n\t\trds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);\n\n\tif (rm)\n\t\trds_message_put(rm);\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "parse_encoding( T1_Face    face,\n                  T1_Loader  loader )\n  {\n    T1_Parser  parser = &loader->parser;\n    FT_Byte*   cur;\n    FT_Byte*   limit  = parser->root.limit;\n\n    PSAux_Service  psaux = (PSAux_Service)face->psaux;\n\n\n    T1_Skip_Spaces( parser );\n    cur = parser->root.cursor;\n    if ( cur >= limit )\n    {\n      FT_ERROR(( \"parse_encoding: out of bounds\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n\n    /* if we have a number or `[', the encoding is an array, */\n    /* and we must load it now                               */\n    if ( ft_isdigit( *cur ) || *cur == '[' )\n    {\n      T1_Encoding  encode          = &face->type1.encoding;\n      FT_Int       count, n;\n      PS_Table     char_table      = &loader->encoding_table;\n      FT_Memory    memory          = parser->root.memory;\n      FT_Error     error;\n      FT_Bool      only_immediates = 0;\n\n\n      /* read the number of entries in the encoding; should be 256 */\n      if ( *cur == '[' )\n      {\n        count           = 256;\n        only_immediates = 1;\n        parser->root.cursor++;\n      }\n      else\n        count = (FT_Int)T1_ToInt( parser );\n\n      T1_Skip_Spaces( parser );\n      if ( parser->root.cursor >= limit )\n        return;\n\n      /* we use a T1_Table to store our charnames */\n      loader->num_chars = encode->num_chars = count;\n      if ( FT_NEW_ARRAY( encode->char_index, count )     ||\n           FT_NEW_ARRAY( encode->char_name,  count )     ||\n           FT_SET_ERROR( psaux->ps_table_funcs->init(\n                           char_table, count, memory ) ) )\n      {\n        parser->root.error = error;\n        return;\n      }\n\n      /* We need to `zero' out encoding_table.elements */\n      for ( n = 0; n < count; n++ )\n      {\n        char*  notdef = (char *)\".notdef\";\n\n\n        T1_Add_Table( char_table, n, notdef, 8 );\n      }\n\n      /* Now we need to read records of the form                */\n      /*                                                        */\n      /*   ... charcode /charname ...                           */\n      /*                                                        */\n      /* for each entry in our table.                           */\n      /*                                                        */\n      /* We simply look for a number followed by an immediate   */\n      /* name.  Note that this ignores correctly the sequence   */\n      /* that is often seen in type1 fonts:                     */\n      /*                                                        */\n      /*   0 1 255 { 1 index exch /.notdef put } for dup        */\n      /*                                                        */\n      /* used to clean the encoding array before anything else. */\n      /*                                                        */\n      /* Alternatively, if the array is directly given as       */\n      /*                                                        */\n      /*   /Encoding [ ... ]                                    */\n      /*                                                        */\n      /* we only read immediates.                               */\n\n      n = 0;\n      T1_Skip_Spaces( parser );\n\n      while ( parser->root.cursor < limit )\n      {\n        cur = parser->root.cursor;\n\n        /* we stop when we encounter a `def' or `]' */\n        if ( *cur == 'd' && cur + 3 < limit )\n        {\n          if ( cur[1] == 'e'         &&\n               cur[2] == 'f'         &&\n               IS_PS_DELIM( cur[3] ) )\n          {\n            FT_TRACE6(( \"encoding end\\n\" ));\n            cur += 3;\n            break;\n          }\n        }\n        if ( *cur == ']' )\n        {\n          FT_TRACE6(( \"encoding end\\n\" ));\n          cur++;\n          break;\n        }\n\n        /* check whether we've found an entry */\n        if ( ft_isdigit( *cur ) || only_immediates )\n        {\n          FT_Int  charcode;\n\n\n          if ( only_immediates )\n            charcode = n;\n          else\n           {\n             charcode = (FT_Int)T1_ToInt( parser );\n             T1_Skip_Spaces( parser );\n           }\n \n           cur = parser->root.cursor;\n\n            parser->root.cursor = cur;\n            T1_Skip_PS_Token( parser );\n            if ( parser->root.cursor >= limit )\n              return;\n            if ( parser->root.error )\n              return;\n\n            len = parser->root.cursor - cur;\n\n            parser->root.error = T1_Add_Table( char_table, charcode,\n                                               cur, len + 1 );\n            if ( parser->root.error )\n              return;\n            char_table->elements[charcode][len] = '\\0';\n\n            n++;\n          }\n          else if ( only_immediates )\n          {\n            /* Since the current position is not updated for           */\n            /* immediates-only mode we would get an infinite loop if   */\n            /* we don't do anything here.                              */\n            /*                                                         */\n            /* This encoding array is not valid according to the type1 */\n            /* specification (it might be an encoding for a CID type1  */\n            /* font, however), so we conclude that this font is NOT a  */\n            /* type1 font.                                             */\n            parser->root.error = FT_THROW( Unknown_File_Format );\n            return;\n          }\n        }\n        else\n        {\n          T1_Skip_PS_Token( parser );\n          if ( parser->root.error )\n            return;\n        }\n\n        T1_Skip_Spaces( parser );\n      }\n\n      face->type1.encoding_type = T1_ENCODING_TYPE_ARRAY;\n      parser->root.cursor       = cur;\n    }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int ff_mpeg4_decode_video_packet_header(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n\n    int mb_num_bits      = av_log2(s->mb_num - 1) + 1;\n    int header_extension = 0, mb_num, len;\n\n    /* is there enough space left for a video packet + header */\n    if (get_bits_count(&s->gb) > s->gb.size_in_bits - 20)\n        return AVERROR_INVALIDDATA;\n\n    for (len = 0; len < 32; len++)\n        if (get_bits1(&s->gb))\n            break;\n\n    if (len != ff_mpeg4_get_video_packet_prefix_length(s)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"marker does not match f_code\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->shape != RECT_SHAPE) {\n        header_extension = get_bits1(&s->gb);\n    }\n\n    mb_num = get_bits(&s->gb, mb_num_bits);\n    if (mb_num >= s->mb_num || !mb_num) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"illegal mb_num in video packet (%d %d) \\n\", mb_num, s->mb_num);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->mb_x = mb_num % s->mb_width;\n    s->mb_y = mb_num / s->mb_width;\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        int qscale = get_bits(&s->gb, s->quant_precision);\n        if (qscale)\n            s->chroma_qscale = s->qscale = qscale;\n    }\n\n    if (ctx->shape == RECT_SHAPE)\n        header_extension = get_bits1(&s->gb);\n\n    if (header_extension) {\n        int time_incr = 0;\n\n        while (get_bits1(&s->gb) != 0)\n            time_incr++;\n\n        check_marker(s->avctx, &s->gb, \"before time_increment in video packed header\");\n        skip_bits(&s->gb, ctx->time_increment_bits);      /* time_increment */\n        check_marker(s->avctx, &s->gb, \"before vop_coding_type in video packed header\");\n\n        skip_bits(&s->gb, 2); /* vop coding type */\n\n        if (ctx->shape != BIN_ONLY_SHAPE) {\n            skip_bits(&s->gb, 3); /* intra dc vlc threshold */\n            if (s->pict_type == AV_PICTURE_TYPE_S &&\n                ctx->vol_sprite_usage == GMC_SPRITE) {\n                if (mpeg4_decode_sprite_trajectory(ctx, &s->gb) < 0)\n                    return AVERROR_INVALIDDATA;\n                av_log(s->avctx, AV_LOG_ERROR, \"untested\\n\");\n            }\n\n\n            if (s->pict_type != AV_PICTURE_TYPE_I) {\n                int f_code = get_bits(&s->gb, 3);       /* fcode_for */\n                if (f_code == 0)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"Error, video packet header damaged (f_code=0)\\n\");\n            }\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n                int b_code = get_bits(&s->gb, 3);\n                if (b_code == 0)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"Error, video packet header damaged (b_code=0)\\n\");\n            }\n        }\n    }\n    if (ctx->new_pred)\n        decode_new_pred(ctx, &s->gb);\n\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\n\t/* Get flash device data */\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n \t\t\tgoto err;\n \t\t}\n \n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n \t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n \t\t\tgoto err;\n \t\t}\n\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\n\t\tmtd->priv = nor;\n\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tf_pdata->registered = true;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void InspectorTraceEvents::WillSendRequest(\n    ExecutionContext*,\n    unsigned long identifier,\n     DocumentLoader* loader,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n    const FetchInitiatorInfo&) {\n   LocalFrame* frame = loader ? loader->GetFrame() : nullptr;\n   TRACE_EVENT_INSTANT1(\n       \"devtools.timeline\", \"ResourceSendRequest\", TRACE_EVENT_SCOPE_THREAD,\n      \"data\", InspectorSendRequestEvent::Data(identifier, frame, request));\n  probe::AsyncTaskScheduled(frame ? frame->GetDocument() : nullptr,\n                            \"SendRequest\", AsyncId(identifier));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n {\n \tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ssl_scan_clienthello_custom_tlsext(SSL *s,\n                                              const unsigned char *data,\n                                              const unsigned char *limit,\n                                              int *al)\n{\n    unsigned short type, size, len;\n    /* If resumed session or no custom extensions nothing to do */\n     if (s->hit || s->cert->srv_ext.meths_count == 0)\n         return 1;\n \n    if (data >= limit - 2)\n         return 1;\n     n2s(data, len);\n \n    if (data > limit - len)\n         return 1;\n \n    while (data <= limit - 4) {\n         n2s(data, type);\n         n2s(data, size);\n \n        if (data + size > limit)\n             return 1;\n         if (custom_ext_parse(s, 1 /* server */ , type, data, size, al) <= 0)\n             return 0;\n\n        data += size;\n    }\n\n    return 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int cm_dreq_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_dreq_msg *dreq_msg;\n\tstruct ib_mad_send_buf *msg = NULL;\n\tint ret;\n\n\tdreq_msg = (struct cm_dreq_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(dreq_msg->remote_comm_id,\n\t\t\t\t   dreq_msg->local_comm_id);\n\tif (!cm_id_priv) {\n\t\tatomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\n\t\t\t\tcounter[CM_DREQ_COUNTER]);\n\t\tcm_issue_drep(work->port, work->mad_recv_wc);\n\t\treturn -EINVAL;\n\t}\n\n\twork->cm_event.private_data = &dreq_msg->private_data;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->local_qpn != cm_dreq_get_remote_qpn(dreq_msg))\n\t\tgoto unlock;\n\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_DREQ_SENT:\n\t\tib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\n\t\tbreak;\n\tcase IB_CM_ESTABLISHED:\n\t\tif (cm_id_priv->id.lap_state == IB_CM_LAP_SENT ||\n\t\t    cm_id_priv->id.lap_state == IB_CM_MRA_LAP_RCVD)\n\t\t\tib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\n\t\tbreak;\n\tcase IB_CM_MRA_REP_RCVD:\n\t\tbreak;\n\tcase IB_CM_TIMEWAIT:\n\t\tatomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\n\t\t\t\tcounter[CM_DREQ_COUNTER]);\n\t\tif (cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg))\n\t\t\tgoto unlock;\n\n\t\tcm_format_drep((struct cm_drep_msg *) msg->mad, cm_id_priv,\n\t\t\t       cm_id_priv->private_data,\n\t\t\t       cm_id_priv->private_data_len);\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\n\t\tif (ib_post_send_mad(msg, NULL))\n\t\t\tcm_free_msg(msg);\n\t\tgoto deref;\n\tcase IB_CM_DREQ_RCVD:\n\t\tatomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\n\t\t\t\tcounter[CM_DREQ_COUNTER]);\n\t\tgoto unlock;\n\tdefault:\n\t\tgoto unlock;\n\t}\n\tcm_id_priv->id.state = IB_CM_DREQ_RCVD;\n\tcm_id_priv->tid = dreq_msg->hdr.tid;\n\tret = atomic_inc_and_test(&cm_id_priv->work_count);\n\tif (!ret)\n\t\tlist_add_tail(&work->list, &cm_id_priv->work_list);\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\tif (ret)\n\t\tcm_process_work(cm_id_priv, work);\n\telse\n\t\tcm_deref_id(cm_id_priv);\n\treturn 0;\n\nunlock:\tspin_unlock_irq(&cm_id_priv->lock);\nderef:\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n\t\t\t   config, pGlxScreen, req->isDirect);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual status_t emptyBuffer(\n            node_id node,\n            buffer_id buffer,\n            OMX_U32 range_offset, OMX_U32 range_length,\n            OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {\n Parcel data, reply;\n        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());\n        data.writeInt32((int32_t)node);\n        data.writeInt32((int32_t)buffer);\n        data.writeInt32(range_offset);\n        data.writeInt32(range_length);\n        data.writeInt32(flags);\n        data.writeInt64(timestamp);\n        data.writeInt32(fenceFd >= 0);\n if (fenceFd >= 0) {\n            data.writeFileDescriptor(fenceFd, true /* takeOwnership */);\n }\n        remote()->transact(EMPTY_BUFFER, data, &reply);\n\n return reply.readInt32();\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n \tint unit;\n \n \tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n \t\tif (cd->present) {\n \t\t\tdel_gendisk(cd->disk);\n \t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "videobuf_vm_open(struct vm_area_struct *vma)\n {\n \tstruct videobuf_mapping *map = vma->vm_private_data;\n \n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n \t\tmap->count,vma->vm_start,vma->vm_end);\n \n \tmap->count++;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n \n  operations_.emplace(id, std::move(operation));\n   return id;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)\n{\tva_list\t\t\targptr ;\n\tsf_count_t\t\t*countptr, countdata ;\n\tunsigned char\t*ucptr, sixteen_bytes [16] ;\n\tunsigned int \t*intptr, intdata ;\n\tunsigned short\t*shortptr ;\n\tchar\t\t\t*charptr ;\n \tfloat\t\t\t*floatptr ;\n \tdouble\t\t\t*doubleptr ;\n \tchar\t\t\tc ;\n\tint\t\t\t\tbyte_count = 0, count ;\n \n \tif (! format)\n \t\treturn psf_ftell (psf) ;\n \n \tva_start (argptr, format) ;\n \n \twhile ((c = *format++))\n\t{\tswitch (c)\n \t\t{\tcase 'e' : /* All conversions are now from LE to host. */\n \t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n \t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* All conversions are now from BE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;\n\t\t\t\t\tbreak ;\n \n \t\t\tcase 'm' : /* 4 byte marker value eg 'RIFF' */\n \t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n \t\t\t\t\tucptr = (unsigned char*) intptr ;\n \t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n \t\t\t\t\t*intptr = GET_MARKER (ucptr) ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'h' :\n \t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n \t\t\t\t\tucptr = (unsigned char*) intptr ;\n \t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;\n \t\t\t\t\t{\tint k ;\n\t\t\t\t\t\tintdata = 0 ;\n\t\t\t\t\t\tfor (k = 0 ; k < 16 ; k++)\n\t\t\t\t\t\t\tintdata ^= sixteen_bytes [k] << k ;\n\t\t\t\t\t\t}\n\t\t\t\t\t*intptr = intdata ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n\t\t\t\t\t*charptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, charptr, sizeof (char)) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' : /* 2 byte value with the current endian-ness */\n\t\t\t\t\tshortptr = va_arg (argptr, unsigned short*) ;\n\t\t\t\t\t*shortptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) shortptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (short)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*shortptr = GET_BE_SHORT (ucptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*shortptr = GET_LE_SHORT (ucptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* 3 byte value with the current endian-ness */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 3) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*intptr = GET_BE_3BYTE (sixteen_bytes) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*intptr = GET_LE_3BYTE (sixteen_bytes) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' : /* 4 byte value with the current endian-ness */\n\t\t\t\t\tintptr = va_arg (argptr, unsigned int*) ;\n\t\t\t\t\t*intptr = 0 ;\n\t\t\t\t\tucptr = (unsigned char*) intptr ;\n\t\t\t\t\tbyte_count += header_read (psf, ucptr, sizeof (int)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*intptr = psf_get_be32 (ucptr, 0) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*intptr = psf_get_le32 (ucptr, 0) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' : /* 8 byte value with the current endian-ness */\n\t\t\t\t\tcountptr = va_arg (argptr, sf_count_t *) ;\n\t\t\t\t\t*countptr = 0 ;\n\t\t\t\t\tbyte_count += header_read (psf, sixteen_bytes, 8) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tcountdata = psf_get_be64 (sixteen_bytes, 0) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tcountdata = psf_get_le64 (sixteen_bytes, 0) ;\n\t\t\t\t\t*countptr = countdata ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' : /* Float conversion */\n\t\t\t\t\tfloatptr = va_arg (argptr, float *) ;\n\t\t\t\t\t*floatptr = 0.0 ;\n\t\t\t\t\tbyte_count += header_read (psf, floatptr, sizeof (float)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*floatptr = float32_be_read ((unsigned char*) floatptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*floatptr = float32_le_read ((unsigned char*) floatptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' : /* double conversion */\n\t\t\t\t\tdoubleptr = va_arg (argptr, double *) ;\n\t\t\t\t\t*doubleptr = 0.0 ;\n\t\t\t\t\tbyte_count += header_read (psf, doubleptr, sizeof (double)) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\t*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;\n\t\t\t\t\telse\n\t\t\t\t\t\t*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\tpsf_log_printf (psf, \"Format conversion 's' not implemented yet.\\n\") ;\n\t\t\t\t\t/*\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize   = strlen (strptr) + 1 ;\n \t\t\t\t\tsize  += (size & 1) ;\n \t\t\t\t\tlongdata = H2LE_32 (size) ;\n \t\t\t\t\tget_int (psf, longdata) ;\n\t\t\t\t\tmemcpy (&(psf->header [psf->headindex]), strptr, size) ;\n\t\t\t\t\tpsf->headindex += size ;\n \t\t\t\t\t*/\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'b' : /* Raw bytes */\n \t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n \t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tif (count > 0)\n\t\t\t\t\t\tbyte_count += header_read (psf, charptr, count) ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'G' :\n \t\t\t\t\tcharptr = va_arg (argptr, char*) ;\n \t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tif (count > 0)\n\t\t\t\t\t\tbyte_count += header_gets (psf, charptr, count) ;\n \t\t\t\t\tbreak ;\n \n \t\t\tcase 'z' :\n \t\t\t\t\tpsf_log_printf (psf, \"Format conversion 'z' not implemented yet.\\n\") ;\n \t\t\t\t\t/*\n \t\t\t\t\tsize    = va_arg (argptr, size_t) ;\n \t\t\t\t\twhile (size)\n\t\t\t\t\t{\tpsf->header [psf->headindex] = 0 ;\n\t\t\t\t\t\tpsf->headindex ++ ;\n \t\t\t\t\t\tsize -- ;\n \t\t\t\t\t\t} ;\n \t\t\t\t\t*/\n \t\t\t\t\tbreak ;\n \n\t\t\tcase 'p' :\n\t\t\t\t\t/* Get the seek position first. */\n \t\t\t\t\tcount = va_arg (argptr, size_t) ;\n \t\t\t\t\theader_seek (psf, count, SEEK_SET) ;\n \t\t\t\t\tbyte_count = count ;\n \t\t\t\t\tbreak ;\n \n\t\t\tcase 'j' :\n\t\t\t\t\t/* Get the seek position first. */\n \t\t\t\t\tcount = va_arg (argptr, size_t) ;\n\t\t\t\t\tif (count)\n\t\t\t\t\t{\theader_seek (psf, count, SEEK_CUR) ;\n\t\t\t\t\t\tbyte_count += count ;\n\t\t\t\t\t\t} ;\n \t\t\t\t\tbreak ;\n \n \t\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;\n\t\t\t\tpsf->error = SFE_INTERNAL ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (argptr) ;\n\n\treturn byte_count ;\n} /* psf_binheader_readf */"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "GF_Err stss_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SyncSampleBox *p;\n\tu32 i;\n\n\tp = (GF_SyncSampleBox *)a;\n\tgf_isom_box_dump_start(a, \"SyncSampleBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->sampleNumbers && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No Key Frames indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++) {\n\t\t\tfprintf(trace, \"<SyncSampleEntry sampleNumber=\\\"%u\\\"/>\\n\", p->sampleNumbers[i]);\n\t\t}\n\t}\n\tif (!p->size) {\n\t\t\tfprintf(trace, \"<SyncSampleEntry sampleNumber=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SyncSampleBox\", a, trace);\n\treturn GF_OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CrosLibrary::TestApi::SetTouchpadLibrary(\n    TouchpadLibrary* library, bool own) {\n  library_->touchpad_lib_.SetImpl(library, own);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const unsigned int maxlen)\n {\n \tstruct gfs2_inode *ip = GFS2_I(inode);\n \tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n \tstruct buffer_head *dibh = mp->mp_bh[0];\n \tu64 bn, dblock = 0;\n \tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n \tunsigned dblks = 0;\n \tunsigned ptrs_per_blk;\n \tconst unsigned end_of_metadata = height - 1;\n \tint eob = 0;\n \tenum alloc_state state;\n \t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]);\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_block(ip, &bn, &n);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n \t\t\tdblock = bn;\n \t\t\twhile (n-- > 0)\n \t\t\t\t*ptr++ = cpu_to_be64(bn++);\n \t\t\tbreak;\n \t\t}\n \t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static __maybe_unused int h2_peek_frame_hdr(const struct buffer *b, struct h2_fh *h)\n{\n\tuint64_t w;\n\n\tif (b->i < 9)\n\t\treturn 0;\n\n\tw = readv_n64(b_ptr(b,1), b_end(b) - b_ptr(b,1), b->data);\n\th->len = *b->p << 16;\n\th->sid = w & 0x7FFFFFFF; /* RFC7540#4.1: R bit must be ignored */\n\th->ff = w >> 32;\n\th->ft = w >> 40;\n\th->len += w >> 48;\n\treturn 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const\n{\n    return GetTime(pChapters, m_stop_timecode);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void snd_seq_dev_release(struct device *dev)\n{\n\tstruct snd_seq_device *sdev = to_seq_dev(dev);\n\n\tif (sdev->private_free)\n\t\tsdev->private_free(sdev);\n\tkfree(sdev);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void HeapCache::free_heap(const wp<IBinder>& binder)\n{\n    sp<IMemoryHeap> rel;\n {\n Mutex::Autolock _l(mHeapCacheLock);\n ssize_t i = mHeapCache.indexOfKey(binder);\n if (i>=0) {\n heap_info_t& info(mHeapCache.editValueAt(i));\n int32_t c = android_atomic_dec(&info.count);\n if (c == 1) {\n                ALOGD_IF(VERBOSE,\n \"removing binder=%p, heap=%p, size=%zu, fd=%d, count=%d\",\n                        binder.unsafe_get(), info.heap.get(),\n static_cast<BpMemoryHeap*>(info.heap.get())->mSize,\n static_cast<BpMemoryHeap*>(info.heap.get())->mHeapId,\n                        info.count);\n                rel = mHeapCache.valueAt(i).heap;\n                mHeapCache.removeItemsAt(i);\n }\n } else {\n            ALOGE(\"free_heap binder=%p not found!!!\", binder.unsafe_get());\n }\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t OMXNodeInstance::sendCommand(\n         OMX_COMMANDTYPE cmd, OMX_S32 param) {\n    const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());\n     if (bufferSource != NULL && cmd == OMX_CommandStateSet) {\n         if (param == OMX_StateIdle) {\n            bufferSource->omxIdle();\n } else if (param == OMX_StateLoaded) {\n            bufferSource->omxLoaded();\n            setGraphicBufferSource(NULL);\n }\n\n }\n\n Mutex::Autolock autoLock(mLock);\n\n {\n Mutex::Autolock _l(mDebugLock);\n        bumpDebugLevel_l(2 /* numInputBuffers */, 2 /* numOutputBuffers */);\n }\n\n const char *paramString =\n        cmd == OMX_CommandStateSet ? asString((OMX_STATETYPE)param) : portString(param);\n    CLOG_STATE(sendCommand, \"%s(%d), %s(%d)\", asString(cmd), cmd, paramString, param);\n    OMX_ERRORTYPE err = OMX_SendCommand(mHandle, cmd, param, NULL);\n    CLOG_IF_ERROR(sendCommand, err, \"%s(%d), %s(%d)\", asString(cmd), cmd, paramString, param);\n\n     return StatusFromOMXError(err);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void kvm_sched_in(struct preempt_notifier *pn, int cpu)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\n\tkvm_arch_vcpu_load(vcpu, cpu);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "delete_file_recursively (GFile          *file,\n                         GCancellable   *cancellable,\n                         DeleteCallback  callback,\n                         gpointer        callback_data)\n{\n    gboolean success;\n    g_autoptr (GError) error = NULL;\n\n    do\n    {\n        g_autoptr (GFileEnumerator) enumerator = NULL;\n\n        success = g_file_delete (file, cancellable, &error);\n        if (success ||\n            !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_EMPTY))\n        {\n            break;\n        }\n\n        g_clear_error (&error);\n\n        enumerator = g_file_enumerate_children (file,\n                                                G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                                G_FILE_QUERY_INFO_NONE,\n                                                cancellable, &error);\n\n        if (enumerator)\n        {\n            GFileInfo *info;\n\n            success = TRUE;\n\n            info = g_file_enumerator_next_file (enumerator,\n                                                cancellable,\n                                                &error);\n\n            while (info != NULL)\n            {\n                g_autoptr (GFile) child = NULL;\n\n                child = g_file_enumerator_get_child (enumerator, info);\n\n                success = success && delete_file_recursively (child,\n                                                              cancellable,\n                                                              callback,\n                                                              callback_data);\n\n                g_object_unref (info);\n\n                info = g_file_enumerator_next_file (enumerator,\n                                                    cancellable,\n                                                    &error);\n            }\n        }\n\n        if (error != NULL)\n        {\n            success = FALSE;\n        }\n    }\n    while (success);\n\n    if (callback)\n    {\n        callback (file, error, callback_data);\n    }\n\n    return success;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "TIFFDefaultStripSize(TIFF* tif, uint32 request)\n{\n\treturn (*tif->tif_defstripsize)(tif, request);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "BrowserContextDestroyer::BrowserContextDestroyer(\n    BrowserContext* context,\n    const std::set<content::RenderProcessHost*>& hosts)\n    : context_(context),\n      pending_hosts_(0) {\n  for (std::set<content::RenderProcessHost*>::iterator it = hosts.begin();\n       it != hosts.end(); ++it) {\n    (*it)->AddObserver(this);\n    ++pending_hosts_;\n   }\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata) {\n    const xmlChar *in;\n    int nbchar = 0;\n    int line = ctxt->input->line;\n    int col = ctxt->input->col;\n    int ccol;\n\n    SHRINK;\n    GROW;\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    if (!cdata) {\n\tin = ctxt->input->cur;\n\tdo {\nget_more_space:\n\t    while (*in == 0x20) { in++; ctxt->input->col++; }\n\t    if (*in == 0xA) {\n\t\tdo {\n\t\t    ctxt->input->line++; ctxt->input->col = 1;\n\t\t    in++;\n\t\t} while (*in == 0xA);\n\t\tgoto get_more_space;\n\t    }\n\t    if (*in == '<') {\n\t\tnbchar = in - ctxt->input->cur;\n\t\tif (nbchar > 0) {\n\t\t    const xmlChar *tmp = ctxt->input->cur;\n\t\t    ctxt->input->cur = in;\n\n\t\t    if ((ctxt->sax != NULL) &&\n\t\t        (ctxt->sax->ignorableWhitespace !=\n\t\t         ctxt->sax->characters)) {\n\t\t\tif (areBlanks(ctxt, tmp, nbchar, 1)) {\n\t\t\t    if (ctxt->sax->ignorableWhitespace != NULL)\n\t\t\t\tctxt->sax->ignorableWhitespace(ctxt->userData,\n\t\t\t\t\t\t       tmp, nbchar);\n\t\t\t} else {\n\t\t\t    if (ctxt->sax->characters != NULL)\n\t\t\t\tctxt->sax->characters(ctxt->userData,\n\t\t\t\t\t\t      tmp, nbchar);\n\t\t\t    if (*ctxt->space == -1)\n\t\t\t        *ctxt->space = -2;\n\t\t\t}\n\t\t    } else if ((ctxt->sax != NULL) &&\n\t\t               (ctxt->sax->characters != NULL)) {\n\t\t\tctxt->sax->characters(ctxt->userData,\n\t\t\t\t\t      tmp, nbchar);\n\t\t    }\n\t\t}\n\t\treturn;\n\t    }\n\nget_more:\n            ccol = ctxt->input->col;\n\t    while (test_char_data[*in]) {\n\t\tin++;\n\t\tccol++;\n\t    }\n\t    ctxt->input->col = ccol;\n\t    if (*in == 0xA) {\n\t\tdo {\n\t\t    ctxt->input->line++; ctxt->input->col = 1;\n\t\t    in++;\n\t\t} while (*in == 0xA);\n\t\tgoto get_more;\n\t    }\n\t    if (*in == ']') {\n\t\tif ((in[1] == ']') && (in[2] == '>')) {\n\t\t    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n\t\t    ctxt->input->cur = in;\n\t\t    return;\n\t\t}\n\t\tin++;\n\t\tctxt->input->col++;\n\t\tgoto get_more;\n\t    }\n\t    nbchar = in - ctxt->input->cur;\n\t    if (nbchar > 0) {\n\t\tif ((ctxt->sax != NULL) &&\n\t\t    (ctxt->sax->ignorableWhitespace !=\n\t\t     ctxt->sax->characters) &&\n\t\t    (IS_BLANK_CH(*ctxt->input->cur))) {\n\t\t    const xmlChar *tmp = ctxt->input->cur;\n\t\t    ctxt->input->cur = in;\n\n\t\t    if (areBlanks(ctxt, tmp, nbchar, 0)) {\n\t\t        if (ctxt->sax->ignorableWhitespace != NULL)\n\t\t\t    ctxt->sax->ignorableWhitespace(ctxt->userData,\n\t\t\t\t\t\t\t   tmp, nbchar);\n\t\t    } else {\n\t\t        if (ctxt->sax->characters != NULL)\n\t\t\t    ctxt->sax->characters(ctxt->userData,\n\t\t\t\t\t\t  tmp, nbchar);\n\t\t\tif (*ctxt->space == -1)\n\t\t\t    *ctxt->space = -2;\n\t\t    }\n                    line = ctxt->input->line;\n                    col = ctxt->input->col;\n\t\t} else if (ctxt->sax != NULL) {\n\t\t    if (ctxt->sax->characters != NULL)\n\t\t\tctxt->sax->characters(ctxt->userData,\n\t\t\t\t\t      ctxt->input->cur, nbchar);\n                    line = ctxt->input->line;\n                    col = ctxt->input->col;\n\t\t}\n                /* something really bad happened in the SAX callback */\n                if (ctxt->instate != XML_PARSER_CONTENT)\n                    return;\n\t    }\n\t    ctxt->input->cur = in;\n\t    if (*in == 0xD) {\n\t\tin++;\n\t\tif (*in == 0xA) {\n\t\t    ctxt->input->cur = in;\n\t\t    in++;\n\t\t    ctxt->input->line++; ctxt->input->col = 1;\n\t\t    continue; /* while */\n\t\t}\n\t\tin--;\n\t    }\n\t    if (*in == '<') {\n\t\treturn;\n\t    }\n\t    if (*in == '&') {\n\t\treturn;\n \t    }\n \t    SHRINK;\n \t    GROW;\n \t    in = ctxt->input->cur;\n \t} while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));\n \tnbchar = 0;\n    }\n    ctxt->input->line = line;\n    ctxt->input->col = col;\n    xmlParseCharDataComplex(ctxt, cdata);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tint ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\n\twhile (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {\n \t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n \t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n \t}\n \treturn ret;\n }\n /* }}} */"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static gdImagePtr gdImageScaleBilinearTC(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tlong dst_w = MAX(1, new_width);\n\tlong dst_h = MAX(1, new_height);\n\tfloat dx = (float)gdImageSX(im) / (float)dst_w;\n\tfloat dy = (float)gdImageSY(im) / (float)dst_h;\n\tgdFixed f_dx = gd_ftofx(dx);\n\tgdFixed f_dy = gd_ftofx(dy);\n\tgdFixed f_1 = gd_itofx(1);\n\n\tint dst_offset_h;\n\tint dst_offset_v = 0;\n\tlong i;\n\tgdImagePtr new_img;\n\n\tnew_img = gdImageCreateTrueColor(new_width, new_height);\n\tif (!new_img){\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i < dst_h; i++) {\n\t\tlong j;\n\t\tdst_offset_h = 0;\n\t\tfor (j=0; j < dst_w; j++) {\n\t\t\t/* Update bitmap */\n\t\t\tgdFixed f_i = gd_itofx(i);\n\t\t\tgdFixed f_j = gd_itofx(j);\n\t\t\tgdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\tgdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\tconst gdFixed m = gd_fxtoi(f_a);\n\t\t\tconst gdFixed n = gd_fxtoi(f_b);\n\t\t\tgdFixed f_f = f_a - gd_itofx(m);\n\t\t\tgdFixed f_g = f_b - gd_itofx(n);\n\n\t\t\tconst gdFixed f_w1 = gd_mulfx(f_1-f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w2 = gd_mulfx(f_1-f_f, f_g);\n\t\t\tconst gdFixed f_w3 = gd_mulfx(f_f, f_1-f_g);\n\t\t\tconst gdFixed f_w4 = gd_mulfx(f_f, f_g);\n\t\t\tunsigned int pixel1;\n\t\t\tunsigned int pixel2;\n\t\t\tunsigned int pixel3;\n\t\t\tunsigned int pixel4;\n\t\t\tregister gdFixed f_r1, f_r2, f_r3, f_r4,\n\t\t\t\t\tf_g1, f_g2, f_g3, f_g4,\n\t\t\t\t\tf_b1, f_b2, f_b3, f_b4,\n\t\t\t\t\tf_a1, f_a2, f_a3, f_a4;\n\t\t\t/* 0 for bgColor; (n,m) is supposed to be valid anyway */\n\t\t\tpixel1 = getPixelOverflowTC(im, n, m, 0);\n\t\t\tpixel2 = getPixelOverflowTC(im, n + 1, m, pixel1);\n\t\t\tpixel3 = getPixelOverflowTC(im, n, m + 1, pixel1);\n\t\t\tpixel4 = getPixelOverflowTC(im, n + 1, m + 1, pixel1);\n\n\t\t\tf_r1 = gd_itofx(gdTrueColorGetRed(pixel1));\n\t\t\tf_r2 = gd_itofx(gdTrueColorGetRed(pixel2));\n\t\t\tf_r3 = gd_itofx(gdTrueColorGetRed(pixel3));\n\t\t\tf_r4 = gd_itofx(gdTrueColorGetRed(pixel4));\n\t\t\tf_g1 = gd_itofx(gdTrueColorGetGreen(pixel1));\n\t\t\tf_g2 = gd_itofx(gdTrueColorGetGreen(pixel2));\n\t\t\tf_g3 = gd_itofx(gdTrueColorGetGreen(pixel3));\n\t\t\tf_g4 = gd_itofx(gdTrueColorGetGreen(pixel4));\n\t\t\tf_b1 = gd_itofx(gdTrueColorGetBlue(pixel1));\n\t\t\tf_b2 = gd_itofx(gdTrueColorGetBlue(pixel2));\n\t\t\tf_b3 = gd_itofx(gdTrueColorGetBlue(pixel3));\n\t\t\tf_b4 = gd_itofx(gdTrueColorGetBlue(pixel4));\n\t\t\tf_a1 = gd_itofx(gdTrueColorGetAlpha(pixel1));\n\t\t\tf_a2 = gd_itofx(gdTrueColorGetAlpha(pixel2));\n\t\t\tf_a3 = gd_itofx(gdTrueColorGetAlpha(pixel3));\n\t\t\tf_a4 = gd_itofx(gdTrueColorGetAlpha(pixel4));\n\t\t\t{\n\t\t\t\tconst unsigned char red   = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_r1) + gd_mulfx(f_w2, f_r2) + gd_mulfx(f_w3, f_r3) + gd_mulfx(f_w4, f_r4));\n\t\t\t\tconst unsigned char green = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_g1) + gd_mulfx(f_w2, f_g2) + gd_mulfx(f_w3, f_g3) + gd_mulfx(f_w4, f_g4));\n\t\t\t\tconst unsigned char blue  = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_b1) + gd_mulfx(f_w2, f_b2) + gd_mulfx(f_w3, f_b3) + gd_mulfx(f_w4, f_b4));\n\t\t\t\tconst unsigned char alpha = (unsigned char) gd_fxtoi(gd_mulfx(f_w1, f_a1) + gd_mulfx(f_w2, f_a2) + gd_mulfx(f_w3, f_a3) + gd_mulfx(f_w4, f_a4));\n\n\t\t\t\tnew_img->tpixels[dst_offset_v][dst_offset_h] = gdTrueColorAlpha(red, green, blue, alpha);\n\t\t\t}\n\n\t\t\tdst_offset_h++;\n\t\t}\n\n\t\tdst_offset_v++;\n\t}\n\treturn new_img;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-191"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void write_data_page(struct dnode_of_data *dn, struct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = fio->sbi;\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\n\tf2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\tdo_write_page(&sum, fio);\n\tf2fs_update_data_blkaddr(dn, fio->new_blkaddr);\n\n\tf2fs_update_iostat(sbi, fio->io_type, F2FS_BLKSIZE);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PHP_METHOD(snmp, __construct)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1, *a2;\n\tint a1_len, a2_len;\n\tlong timeout = SNMP_DEFAULT_TIMEOUT;\n\tlong retries = SNMP_DEFAULT_RETRIES;\n\tlong version = SNMP_DEFAULT_VERSION;\n\tint argc = ZEND_NUM_ARGS();\n\tzend_error_handling error_handling;\n \n        snmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);\n        zend_replace_error_handling(EH_THROW, NULL, &error_handling TSRMLS_CC);\n        if (zend_parse_parameters(argc TSRMLS_CC, \"lss|ll\", &version, &a1, &a1_len, &a2, &a2_len, &timeout, &retries) == FAILURE) {\n                zend_restore_error_handling(&error_handling TSRMLS_CC);\n                return;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\n\tswitch(version) {\n\t\tcase SNMP_VERSION_1:\n\t\tcase SNMP_VERSION_2c:\n\t\tcase SNMP_VERSION_3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzend_throw_exception(zend_exception_get_default(TSRMLS_C), \"Unknown SNMP protocol version\", 0 TSRMLS_CC);\n\t\t\treturn;\n\t}\n\n\t/* handle re-open of snmp session */\n        if (snmp_object->session) {\n                netsnmp_session_free(&(snmp_object->session));\n        }\n        if (netsnmp_session_init(&(snmp_object->session), version, a1, a2, timeout, retries TSRMLS_CC)) {\n                return;\n        }\n\tsnmp_object->max_oids = 0;\n\tsnmp_object->valueretrieval = SNMP_G(valueretrieval);\n\tsnmp_object->enum_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);\n\tsnmp_object->oid_output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n\tsnmp_object->quick_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n\tsnmp_object->oid_increasing_check = TRUE;\n\tsnmp_object->exceptions_enabled = 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t MPEG4DataSource::getSize(off64_t *size) {\n return mSource->getSize(size);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool ExtensionDevToolsInfoBarDelegate::Cancel() {\n  InfoBarDismissed();\n  return false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Element* Document::createElementNS(const AtomicString& namespace_uri,\n                                   const AtomicString& qualified_name,\n                                   ExceptionState& exception_state) {\n  QualifiedName q_name(\n      CreateQualifiedName(namespace_uri, qualified_name, exception_state));\n  if (q_name == QualifiedName::Null())\n    return nullptr;\n\n  CreateElementFlags flags = CreateElementFlags::ByCreateElement();\n  if (CustomElement::ShouldCreateCustomElement(q_name))\n    return CustomElement::CreateCustomElement(*this, q_name, flags);\n  if (RegistrationContext() && V0CustomElement::IsValidName(q_name.LocalName()))\n    return RegistrationContext()->CreateCustomTagElement(*this, q_name);\n  return CreateRawElement(q_name, flags);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int ip_queue_xmit(struct sk_buff *skb)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;\n \tstruct rtable *rt;\n \tstruct iphdr *iph;\n \tint res;\n\n\t/* Skip all of this if the packet is already routed,\n \t * f.e. by something like SCTP.\n \t */\n \trcu_read_lock();\n \trt = skb_rtable(skb);\n \tif (rt != NULL)\n \t\tgoto packet_routed;\n\n\t/* Make sure we can route this packet. */\n\trt = (struct rtable *)__sk_dst_check(sk, 0);\n\tif (rt == NULL) {\n\t\t__be32 daddr;\n \n \t\t/* Use correct destination address if we have options. */\n \t\tdaddr = inet->inet_daddr;\n\t\tif(opt && opt->srr)\n\t\t\tdaddr = opt->faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport,\n\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol,\n\t\t\t\t\t   RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n \tskb_dst_set_noref(skb, &rt->dst);\n \n packet_routed:\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n \t\tgoto no_route;\n \n \t/* OK, we know where to send it, allocate and build IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n \tskb_reset_network_header(skb);\n \tiph = ip_hdr(skb);\n \t*((__be16 *)iph) = htons((4 << 12) | (5 << 8) | (inet->tos & 0xff));\n\tif (ip_dont_fragment(sk, &rt->dst) && !skb->local_df)\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->protocol = sk->sk_protocol;\n\tiph->saddr    = rt->rt_src;\n \tiph->daddr    = rt->rt_dst;\n \t/* Transport layer set skb->h.foo itself. */\n \n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen >> 2;\n\t\tip_options_build(skb, opt, inet->inet_daddr, rt, 0);\n \t}\n \n \tip_select_ident_more(iph, &rt->dst, sk,\n\t\t\t     (skb_shinfo(skb)->gso_segs ?: 1) - 1);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tres = ip_local_out(skb);\n\trcu_read_unlock();\n\treturn res;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool PrintRenderFrameHelper::PrintPagesNative(blink::WebLocalFrame* frame,\n                                              int page_count) {\n  const PrintMsg_PrintPages_Params& params = *print_pages_params_;\n  const PrintMsg_Print_Params& print_params = params.params;\n\n  std::vector<int> printed_pages = GetPrintedPages(params, page_count);\n  if (printed_pages.empty())\n    return false;\n\n  PdfMetafileSkia metafile(print_params.printed_doc_type);\n  CHECK(metafile.Init());\n\n  for (int page_number : printed_pages) {\n    PrintPageInternal(print_params, page_number, page_count, frame, &metafile,\n                      nullptr, nullptr);\n  }\n\n  FinishFramePrinting();\n\n  metafile.FinishDocument();\n\n#if defined(OS_ANDROID)\n  int sequence_number = -1;\n  base::FileDescriptor fd;\n\n  Send(new PrintHostMsg_AllocateTempFileForPrinting(routing_id(), &fd,\n                                                    &sequence_number));\n  if (!SaveToFD(metafile, fd))\n    return false;\n\n  Send(new PrintHostMsg_TempFileForPrintingWritten(\n      routing_id(), sequence_number, printed_pages.size()));\n   return true;\n #else\n   PrintHostMsg_DidPrintDocument_Params page_params;\n  if (!CopyMetafileDataToSharedMem(metafile,\n                                   &page_params.metafile_data_handle)) {\n     return false;\n   }\n \n  page_params.data_size = metafile.GetDataSize();\n  page_params.document_cookie = print_params.document_cookie;\n  Send(new PrintHostMsg_DidPrintDocument(routing_id(), page_params));\n  return true;\n#endif  // defined(OS_ANDROID)\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "eXosip_reset_transports (struct eXosip_t *excontext)\n{\n  int i = OSIP_WRONG_STATE;\n\n  if (excontext->eXtl_transport.tl_reset)\n    i = excontext->eXtl_transport.tl_reset (excontext);\n  return i;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "GahpClient::blah_job_cancel(const char *job_id)\n{\n\tstatic const char* command = \"BLAH_JOB_CANCEL\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!job_id) job_id=NULLSTRING;\n\tstd::string reqline;\n\tint x = sprintf( reqline, \"%s\", escapeGahpString( job_id ) );\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,deleg_proxy);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\tif ( result ) {\n\t\tif (result->argc != 3) {\n\t\t\tEXCEPT(\"Bad %s Result\",command);\n\t\t}\n\t\tint rc = atoi( result->argv[1] );\n\t\tif ( strcasecmp(result->argv[2], NULLSTRING) ) {\n\t\t\terror_string = result->argv[2];\n\t\t} else {\n\t\t\terror_string = \"\";\n\t\t}\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\tsprintf( error_string, \"%s timed out\", command );\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-134"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void tpacket_set_protocol(const struct net_device *dev,\n\t\t\t\t struct sk_buff *skb)\n{\n\tif (dev->type == ARPHRD_ETHER) {\n\t\tskb_reset_mac_header(skb);\n\t\tskb->protocol = eth_hdr(skb)->h_proto;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PassRefPtr<DocumentFragment> createFragmentFromNodes(Document *document, const Vector<Node*>& nodes)\n{\n    if (!document)\n        return 0;\n\n    if (document->frame())\n        document->frame()->editor()->deleteButtonController()->disable();\n\n    RefPtr<DocumentFragment> fragment = document->createDocumentFragment();\n\n    ExceptionCode ec = 0;\n    size_t size = nodes.size();\n    for (size_t i = 0; i < size; ++i) {\n        RefPtr<Element> element = createDefaultParagraphElement(document);\n        element->appendChild(nodes[i], ec);\n        ASSERT(!ec);\n        fragment->appendChild(element.release(), ec);\n        ASSERT(!ec);\n    }\n\n    if (document->frame())\n        document->frame()->editor()->deleteButtonController()->enable();\n\n    return fragment.release();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PHP_METHOD(Phar, offsetUnset)\n{\n\tchar *fname, *error;\n\tsize_t fname_len;\n\tphar_entry_info *entry;\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Write operations disabled by the php.ini setting phar.readonly\");\n                return;\n        }\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\n                return;\n        }\n \n\tif (zend_hash_str_exists(&phar_obj->archive->manifest, fname, (uint) fname_len)) {\n\t\tif (NULL != (entry = zend_hash_str_find_ptr(&phar_obj->archive->manifest, fname, (uint) fname_len))) {\n\t\t\tif (entry->is_deleted) {\n\t\t\t\t/* entry is deleted, but has not been flushed to disk yet */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (phar_obj->archive->is_persistent) {\n\t\t\t\tif (FAILURE == phar_copy_on_write(&(phar_obj->archive))) {\n\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->archive->fname);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/* re-populate entry after copy on write */\n\t\t\t\tentry = zend_hash_str_find_ptr(&phar_obj->archive->manifest, fname, (uint) fname_len);\n\t\t\t}\n\t\t\tentry->is_modified = 0;\n\t\t\tentry->is_deleted = 1;\n\t\t\t/* we need to \"flush\" the stream to save the newly deleted file on disk */\n\t\t\tphar_flush(phar_obj->archive, 0, 0, 0, &error);\n\n\t\t\tif (error) {\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"%s\", error);\n\t\t\t\tefree(error);\n\t\t\t}\n\n\t\t\tRETURN_TRUE;\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "qboolean CL_GetLimboString( int index, char *buf ) {\n\tif ( index >= LIMBOCHAT_HEIGHT ) {\n\t\treturn qfalse;\n\t}\n\n\tstrncpy( buf, cl.limboChatMsgs[index], 140 );\n\treturn qtrue;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-269"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "CreateCommandBufferResult RenderThreadImpl::CreateViewCommandBuffer(\n      int32 surface_id,\n      const GPUCreateCommandBufferConfig& init_params,\n      int32 route_id) {\n  TRACE_EVENT1(\"gpu\",\n               \"RenderThreadImpl::CreateViewCommandBuffer\",\n               \"surface_id\",\n               surface_id);\n\n  CreateCommandBufferResult result = CREATE_COMMAND_BUFFER_FAILED;\n  IPC::Message* message = new GpuHostMsg_CreateViewCommandBuffer(\n      surface_id,\n      init_params,\n      route_id,\n      &result);\n\n  thread_safe_sender()->Send(message);\n\n  return result;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    AVCodecParameters *par = trk->par;\n    unsigned int samples_in_chunk = 0;\n    int size = pkt->size, ret = 0;\n    uint8_t *reformatted_data = NULL;\n\n    ret = check_pkt(s, pkt);\n    if (ret < 0)\n        return ret;\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {\n        int ret;\n        if (mov->moov_written || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n            if (mov->frag_interleave && mov->fragments > 0) {\n                if (trk->entry - trk->entries_flushed >= mov->frag_interleave) {\n                    if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)\n                        return ret;\n                }\n            }\n\n            if (!trk->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = trk->mdat_buf;\n        } else {\n            if (!mov->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = mov->mdat_buf;\n        }\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AMR_NB) {\n        /* We must find out how many AMR blocks there are in one packet */\n        static const uint16_t packed_size[16] =\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};\n        int len = 0;\n\n        while (len < size && samples_in_chunk < 100) {\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n            samples_in_chunk++;\n        }\n        if (samples_in_chunk > 1) {\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n            return -1;\n        }\n    } else if (par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n               par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {\n        samples_in_chunk = trk->par->frame_size;\n    } else if (trk->sample_size)\n        samples_in_chunk = size / trk->sample_size;\n     else\n         samples_in_chunk = 1;\n \n     /* copy extradata if it exists */\n     if (trk->vos_len == 0 && par->extradata_size > 0 &&\n         !TAG_IS_AVCI(trk->tag) &&\n        (par->codec_id != AV_CODEC_ID_DNXHD)) {\n        trk->vos_len  = par->extradata_size;\n        trk->vos_data = av_malloc(trk->vos_len);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, par->extradata, trk->vos_len);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&\n        (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {\n        if (!s->streams[pkt->stream_index]->nb_frames) {\n            av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"\n                   \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"\n                   \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");\n            return -1;\n        }\n        av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");\n    }\n    if (par->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {\n        /* from x264 or from bytestream H.264 */\n        /* NAL reformatting needed */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,\n                                       &size);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            if (trk->cenc.aes_ctr) {\n                size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);\n                if (size < 0) {\n                    ret = size;\n                    goto err;\n                }\n            } else {\n                size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);\n            }\n        }\n    } else if (par->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&\n               (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {\n        /* extradata is Annex B, assume the bitstream is too and convert it */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);\n        }\n#if CONFIG_AC3_PARSER\n    } else if (par->codec_id == AV_CODEC_ID_EAC3) {\n        size = handle_eac3(mov, pkt, trk);\n        if (size < 0)\n            return size;\n        else if (!size)\n            goto end;\n        avio_write(pb, pkt->data, size);\n#endif\n    } else {\n        if (trk->cenc.aes_ctr) {\n            if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {\n                int nal_size_length = (par->extradata[4] & 0x3) + 1;\n                ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);\n            } else {\n                ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);\n            }\n\n            if (ret) {\n                goto err;\n            }\n        } else {\n            avio_write(pb, pkt->data, size);\n        }\n    }\n\n    if ((par->codec_id == AV_CODEC_ID_DNXHD ||\n         par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {\n        /* copy frame to create needed atoms */\n        trk->vos_len  = size;\n        trk->vos_data = av_malloc(size);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, pkt->data, size);\n    }\n\n    if (trk->entry >= trk->cluster_capacity) {\n        unsigned new_capacity = 2 * (trk->entry + MOV_INDEX_CLUSTER_SIZE);\n        if (av_reallocp_array(&trk->cluster, new_capacity,\n                              sizeof(*trk->cluster))) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        trk->cluster_capacity = new_capacity;\n    }\n\n    trk->cluster[trk->entry].pos              = avio_tell(pb) - size;\n    trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;\n    trk->cluster[trk->entry].chunkNum         = 0;\n    trk->cluster[trk->entry].size             = size;\n    trk->cluster[trk->entry].entries          = samples_in_chunk;\n    trk->cluster[trk->entry].dts              = pkt->dts;\n    trk->cluster[trk->entry].pts              = pkt->pts;\n    if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {\n        if (!trk->frag_discont) {\n            /* First packet of a new fragment. We already wrote the duration\n             * of the last packet of the previous fragment based on track_duration,\n             * which might not exactly match our dts. Therefore adjust the dts\n             * of this packet to be what the previous packets duration implies. */\n            trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;\n            /* We also may have written the pts and the corresponding duration\n             * in sidx/tfrf/tfxd tags; make sure the sidx pts and duration match up with\n             * the next fragment. This means the cts of the first sample must\n             * be the same in all fragments, unless end_pts was updated by\n             * the packet causing the fragment to be written. */\n            if ((mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) ||\n                mov->mode == MODE_ISM)\n                pkt->pts = pkt->dts + trk->end_pts - trk->cluster[trk->entry].dts;\n        } else {\n            /* New fragment, but discontinuous from previous fragments.\n             * Pretend the duration sum of the earlier fragments is\n             * pkt->dts - trk->start_dts. */\n            trk->frag_start = pkt->dts - trk->start_dts;\n            trk->end_pts = AV_NOPTS_VALUE;\n            trk->frag_discont = 0;\n        }\n    }\n\n    if (!trk->entry && trk->start_dts == AV_NOPTS_VALUE && !mov->use_editlist &&\n        s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {\n        /* Not using edit lists and shifting the first track to start from zero.\n         * If the other streams start from a later timestamp, we won't be able\n         * to signal the difference in starting time without an edit list.\n         * Thus move the timestamp for this first sample to 0, increasing\n         * its duration instead. */\n        trk->cluster[trk->entry].dts = trk->start_dts = 0;\n    }\n    if (trk->start_dts == AV_NOPTS_VALUE) {\n        trk->start_dts = pkt->dts;\n        if (trk->frag_discont) {\n            if (mov->use_editlist) {\n                /* Pretend the whole stream started at pts=0, with earlier fragments\n                 * already written. If the stream started at pts=0, the duration sum\n                 * of earlier fragments would have been pkt->pts. */\n                trk->frag_start = pkt->pts;\n                trk->start_dts  = pkt->dts - pkt->pts;\n            } else {\n                /* Pretend the whole stream started at dts=0, with earlier fragments\n                 * already written, with a duration summing up to pkt->dts. */\n                trk->frag_start = pkt->dts;\n                trk->start_dts  = 0;\n            }\n            trk->frag_discont = 0;\n        } else if (pkt->dts && mov->moov_written)\n            av_log(s, AV_LOG_WARNING,\n                   \"Track %d starts with a nonzero dts %\"PRId64\", while the moov \"\n                   \"already has been written. Set the delay_moov flag to handle \"\n                   \"this case.\\n\",\n                   pkt->stream_index, pkt->dts);\n    }\n    trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;\n    trk->last_sample_is_subtitle_end = 0;\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n        pkt->pts = pkt->dts;\n    }\n    if (pkt->dts != pkt->pts)\n        trk->flags |= MOV_TRACK_CTTS;\n    trk->cluster[trk->entry].cts   = pkt->pts - pkt->dts;\n    trk->cluster[trk->entry].flags = 0;\n    if (trk->start_cts == AV_NOPTS_VALUE)\n        trk->start_cts = pkt->pts - pkt->dts;\n    if (trk->end_pts == AV_NOPTS_VALUE)\n        trk->end_pts = trk->cluster[trk->entry].dts +\n                       trk->cluster[trk->entry].cts + pkt->duration;\n    else\n        trk->end_pts = FFMAX(trk->end_pts, trk->cluster[trk->entry].dts +\n                                           trk->cluster[trk->entry].cts +\n                                           pkt->duration);\n\n    if (par->codec_id == AV_CODEC_ID_VC1) {\n        mov_parse_vc1_frame(pkt, trk);\n    } else if (pkt->flags & AV_PKT_FLAG_KEY) {\n        if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&\n            trk->entry > 0) { // force sync sample for the first key frame\n            mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);\n            if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)\n                trk->flags |= MOV_TRACK_STPS;\n        } else {\n            trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;\n        }\n        if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)\n            trk->has_keyframes++;\n    }\n    if (pkt->flags & AV_PKT_FLAG_DISPOSABLE) {\n        trk->cluster[trk->entry].flags |= MOV_DISPOSABLE_SAMPLE;\n        trk->has_disposable++;\n    }\n    trk->entry++;\n    trk->sample_count += samples_in_chunk;\n    mov->mdat_size    += size;\n\n    if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)\n        ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,\n                                 reformatted_data, size);\n\nend:\nerr:\n\n    av_free(reformatted_data);\n    return ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-369"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline size_t GetPSDRowSize(Image *image)\n {\n   if (image->depth == 1)\n    return((image->columns+7)/8);\n   else\n     return(image->columns*GetPSDPacketSize(image));\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "arcSegmentSide(const pointObj *p1, const pointObj *p2, const pointObj *q)\n{\n  double side = ( (q->x - p1->x) * (p2->y - p1->y) - (p2->x - p1->x) * (q->y - p1->y) );\n  if ( FP_EQ(side,0.0) ) {\n    return FP_COLINEAR;\n  } else {\n    if ( side < 0.0 )\n      return FP_LEFT;\n    else\n      return FP_RIGHT;\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-89"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "juniper_pppoe_atm_print(netdissect_options *ndo,\n                        const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\tuint16_t extracted_ethertype;\n\n        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n \n         p+=l2info.header_len;\n \n         extracted_ethertype = EXTRACT_16BITS(p);\n         /* this DLT contains nothing but raw PPPoE frames,\n          * prepended with a type field*/\n        if (ethertype_print(ndo, extracted_ethertype,\n                              p+ETHERTYPE_LEN,\n                              l2info.length-ETHERTYPE_LEN,\n                              l2info.caplen-ETHERTYPE_LEN,\n                              NULL, NULL) == 0)\n            /* ether_type not known, probably it wasn't one */\n             ND_PRINT((ndo, \"unknown ethertype 0x%04x\", extracted_ethertype));\n \n         return l2info.header_len;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void ext4_put_super(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i, err;\n\n\text4_unregister_li_request(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\tflush_workqueue(sbi->rsv_conversion_wq);\n\tdestroy_workqueue(sbi->rsv_conversion_wq);\n\n\tif (sbi->s_journal) {\n\t\terr = jbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t\tif (err < 0)\n\t\t\text4_abort(sb, \"Couldn't clean up the journal\");\n\t}\n\n\text4_unregister_sysfs(sb);\n\text4_es_unregister_shrinker(sbi);\n\tdel_timer_sync(&sbi->s_err_report);\n \text4_release_system_zone(sb);\n \text4_mb_release(sb);\n \text4_ext_release(sb);\n\text4_xattr_put_super(sb);\n \n \tif (!(sb->s_flags & MS_RDONLY)) {\n \t\text4_clear_feature_journal_needs_recovery(sb);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\n\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tsync_blockdev(sb->s_bdev);\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text4_blkdev_remove(sbi);\n\t}\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\n\tsb->s_fs_info = NULL;\n\t/*\n\t * Now that we are completely done shutting down the\n\t * superblock, we need to actually destroy the kobject.\n\t */\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-19"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n {\n     int i, j, v;\n \n     if (get_bits1(gb)) {\n         /* intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n \n     if (get_bits1(gb)) {\n         /* non_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n \n     if (get_bits1(gb)) {\n         /* chroma_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n \n     if (get_bits1(gb)) {\n         /* chroma_non_intra_quantiser_matrix */\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n \n     next_start_code_studio(gb);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\t/*\n\t * Blow out the MMU to ensure that no other VCPU has an active mapping\n\t * to ensure that the updated hypercall appears atomically across all\n\t * VCPUs.\n\t */\n\tkvm_mmu_zap_all(vcpu->kvm);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3, NULL);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n {\n\tstruct desc_struct *desc;\n \tunsigned long limit;\n \tshort sel;\n \n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n \tif (!sel)\n \t\treturn 0;\n \n\tdesc = get_desc(sel);\n\tif (!desc)\n \t\treturn 0;\n \n \t/*\n\t * If the granularity bit is set, the limit is given in multiples\n\t * of 4096. This also means that the 12 least significant bits are\n \t * not tested when checking the segment limits. In practice,\n \t * this means that the segment ends in (limit << 12) + 0xfff.\n \t */\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n \t\tlimit = (limit << 12) + 0xfff;\n \n \treturn limit;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void nfs4_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)\n{\n\tdata->timestamp   = jiffies;\n\tdata->read_done_cb = nfs4_read_done_cb;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void gmc1_motion(MpegEncContext *s,\n                        uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                        uint8_t **ref_picture)\n{\n    uint8_t *ptr;\n    int src_x, src_y, motion_x, motion_y;\n    ptrdiff_t offset, linesize, uvlinesize;\n    int emu = 0;\n\n    motion_x   = s->sprite_offset[0][0];\n    motion_y   = s->sprite_offset[0][1];\n    src_x      = s->mb_x * 16 + (motion_x >> (s->sprite_warping_accuracy + 1));\n    src_y      = s->mb_y * 16 + (motion_y >> (s->sprite_warping_accuracy + 1));\n    motion_x <<= (3 - s->sprite_warping_accuracy);\n    motion_y <<= (3 - s->sprite_warping_accuracy);\n    src_x      = av_clip(src_x, -16, s->width);\n    if (src_x == s->width)\n        motion_x = 0;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y == s->height)\n        motion_y = 0;\n\n    linesize   = s->linesize;\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0] + src_y * linesize + src_x;\n\n    if ((unsigned)src_x >= FFMAX(s->h_edge_pos - 17, 0) ||\n        (unsigned)src_y >= FFMAX(s->v_edge_pos - 17, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 linesize, linesize,\n                                 17, 17,\n                                 src_x, src_y,\n                                 s->h_edge_pos, s->v_edge_pos);\n        ptr = s->sc.edge_emu_buffer;\n    }\n\n    if ((motion_x | motion_y) & 7) {\n        s->mdsp.gmc1(dest_y, ptr, linesize, 16,\n                     motion_x & 15, motion_y & 15, 128 - s->no_rounding);\n        s->mdsp.gmc1(dest_y + 8, ptr + 8, linesize, 16,\n                     motion_x & 15, motion_y & 15, 128 - s->no_rounding);\n    } else {\n        int dxy;\n\n        dxy = ((motion_x >> 3) & 1) | ((motion_y >> 2) & 2);\n        if (s->no_rounding) {\n            s->hdsp.put_no_rnd_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);\n        } else {\n            s->hdsp.put_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);\n        }\n    }\n\n    if (CONFIG_GRAY && s->avctx->flags & AV_CODEC_FLAG_GRAY)\n        return;\n\n    motion_x   = s->sprite_offset[1][0];\n    motion_y   = s->sprite_offset[1][1];\n    src_x      = s->mb_x * 8 + (motion_x >> (s->sprite_warping_accuracy + 1));\n    src_y      = s->mb_y * 8 + (motion_y >> (s->sprite_warping_accuracy + 1));\n    motion_x <<= (3 - s->sprite_warping_accuracy);\n    motion_y <<= (3 - s->sprite_warping_accuracy);\n    src_x      = av_clip(src_x, -8, s->width >> 1);\n    if (src_x == s->width >> 1)\n        motion_x = 0;\n    src_y = av_clip(src_y, -8, s->height >> 1);\n    if (src_y == s->height >> 1)\n        motion_y = 0;\n\n    offset = (src_y * uvlinesize) + src_x;\n    ptr    = ref_picture[1] + offset;\n    if ((unsigned)src_x >= FFMAX((s->h_edge_pos >> 1) - 9, 0) ||\n        (unsigned)src_y >= FFMAX((s->v_edge_pos >> 1) - 9, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 uvlinesize, uvlinesize,\n                                 9, 9,\n                                 src_x, src_y,\n                                 s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n        ptr = s->sc.edge_emu_buffer;\n        emu = 1;\n    }\n    s->mdsp.gmc1(dest_cb, ptr, uvlinesize, 8,\n                 motion_x & 15, motion_y & 15, 128 - s->no_rounding);\n\n    ptr = ref_picture[2] + offset;\n    if (emu) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 uvlinesize, uvlinesize,\n                                 9, 9,\n                                 src_x, src_y,\n                                 s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n        ptr = s->sc.edge_emu_buffer;\n    }\n    s->mdsp.gmc1(dest_cr, ptr, uvlinesize, 8,\n                 motion_x & 15, motion_y & 15, 128 - s->no_rounding);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n  int c, tag, len;\n   uchar data[0x10000];\n   const uchar *dp;\n \n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CoordinatorImpl::BindHeapProfilerHelperRequest(\n    mojom::HeapProfilerHelperRequest request,\n    const service_manager::BindSourceInfo& source_info) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  bindings_heap_profiler_helper_.AddBinding(this, std::move(request),\n                                            source_info.identity);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void dev_set_group(struct net_device *dev, int new_group)\n{\n\tdev->group = new_group;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-400"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool vmxnet_tx_pkt_parse_headers(struct VmxnetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG];\n \n     bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                             ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < ETH_MAX_L2_HDR_LEN) {\n         l2_hdr->iov_len = 0;\n         return false;\n    } else {\n        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n     }\n \n     l3_proto = eth_get_l3_proto(l2_hdr->iov_base, l2_hdr->iov_len);\n        l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n        pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n\n        /* copy optional IPv4 header data */\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags,\n                                l2_hdr->iov_len + sizeof(struct ip_header),\n                                l3_hdr->iov_base + sizeof(struct ip_header),\n                                l3_hdr->iov_len - sizeof(struct ip_header));\n        if (bytes_read < l3_hdr->iov_len - sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n        break;\n\n    case ETH_P_IPV6:\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                               &pkt->l4proto, &full_ip6hdr_len)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_base = g_malloc(full_ip6hdr_len);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ahash_def_finup_finish1(struct ahash_request *req, int err)\n{\n\tif (err)\n\t\tgoto out;\n\n\treq->base.complete = ahash_def_finup_done2;\n\treq->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\n\terr = crypto_ahash_reqtfm(req)->final(req);\n\nout:\n\tahash_def_finup_finish2(req, err);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "}static inline void WriteResourceLong(unsigned char *p,\n   const unsigned int quantum)\n {"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ScreenOrientation::orientationLockTimerFired(Timer<ScreenOrientation>*)\n{\n    if (m_lockedOrientations == WebScreenOrientationDefault)\n        blink::Platform::current()->unlockOrientation();\n    else\n        blink::Platform::current()->lockOrientation(m_lockedOrientations);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n\n     if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n         return (NULL);\n     }\n     if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n         ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n     } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "choose_filters(struct archive_read *a)\n {\n\tint number_bidders, i, bid, best_bid;\n \tstruct archive_read_filter_bidder *bidder, *best_bidder;\n \tstruct archive_read_filter *filter;\n \tssize_t avail;\n \tint r;\n \n\tfor (;;) {\n \t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n \n \t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If no bidder, we're done. */\n\t\tif (best_bidder == NULL) {\n\t\t\t/* Verify the filter by asking it for some data. */\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n \t\t\treturn (ARCHIVE_FATAL);\n \t\t}\n \t}\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 4;\n     fwd_txfm_ref = fht4x4_ref;\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GDataCache::Pin(const std::string& resource_id,\n                     const std::string& md5,\n                     FileOperationType file_operation_type,\n                     base::PlatformFileError* error) {\n  AssertOnSequencedWorkerPool();\n  DCHECK(error);\n\n  FilePath source_path;\n  FilePath dest_path;\n  FilePath symlink_path;\n  bool create_symlink = true;\n  int cache_state = CACHE_STATE_PINNED;\n  CacheSubDirectoryType sub_dir_type = CACHE_TYPE_PERSISTENT;\n\n  scoped_ptr<CacheEntry> cache_entry = GetCacheEntry(resource_id, md5);\n\n  if (!cache_entry.get()) {  // Entry does not exist in cache.\n    dest_path = FilePath::FromUTF8Unsafe(util::kSymLinkToDevNull);\n     source_path = dest_path;\n \n    sub_dir_type = CACHE_TYPE_PINNED;\n  } else {  // File exists in cache, determines destination path.\n    cache_state |= cache_entry->cache_state;\n\n\n    if (cache_entry->IsDirty() || cache_entry->IsMounted()) {\n      DCHECK_EQ(CACHE_TYPE_PERSISTENT, cache_entry->sub_dir_type);\n      dest_path = GetCacheFilePath(resource_id,\n                                   md5,\n                                   cache_entry->sub_dir_type,\n                                   CACHED_FILE_LOCALLY_MODIFIED);\n      source_path = dest_path;\n    } else {\n      source_path = GetCacheFilePath(resource_id,\n                                     md5,\n                                     cache_entry->sub_dir_type,\n                                     CACHED_FILE_FROM_SERVER);\n\n      if (cache_entry->sub_dir_type == CACHE_TYPE_PINNED) {\n        dest_path = source_path;\n        create_symlink = false;\n      } else {  // File exists, move it to persistent dir.\n        dest_path = GetCacheFilePath(resource_id,\n                                     md5,\n                                     CACHE_TYPE_PERSISTENT,\n                                     CACHED_FILE_FROM_SERVER);\n      }\n    }\n  }\n\n  if (create_symlink) {\n    symlink_path = GetCacheFilePath(resource_id,\n                                    std::string(),\n                                    CACHE_TYPE_PINNED,\n                                    CACHED_FILE_FROM_SERVER);\n  }\n\n  *error = ModifyCacheState(source_path,\n                            dest_path,\n                            file_operation_type,\n                            symlink_path,\n                            create_symlink);\n\n  if (*error == base::PLATFORM_FILE_OK) {\n    metadata_->UpdateCache(resource_id, md5, sub_dir_type, cache_state);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ipcget_new(struct ipc_namespace *ns, struct ipc_ids *ids,\n\t\tconst struct ipc_ops *ops, struct ipc_params *params)\n{\n\tint err;\n\n\tdown_write(&ids->rwsem);\n\terr = ops->getnew(ns, params);\n\tup_write(&ids->rwsem);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n \tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n \tunsigned int len;\n \n\tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n\n\t/*\n\t * Our caller has ensured that the length is >= 4.\n\t */\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool should_attach_gdb(const debugger_request_t& request) {\n if (request.action == DEBUGGER_ACTION_CRASH) {\n return property_get_bool(\"debug.debuggerd.wait_for_gdb\", false);\n }\n return false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void TabLoader::RemoveTab(NavigationController* tab) {\n  registrar_.Remove(this, content::NOTIFICATION_WEB_CONTENTS_DESTROYED,\n                    content::Source<WebContents>(tab->GetWebContents()));\n  registrar_.Remove(this, content::NOTIFICATION_LOAD_STOP,\n                    content::Source<NavigationController>(tab));\n  registrar_.Remove(this, content::NOTIFICATION_LOAD_START,\n                    content::Source<NavigationController>(tab));\n\n  TabsLoading::iterator i = tabs_loading_.find(tab);\n  if (i != tabs_loading_.end())\n    tabs_loading_.erase(i);\n\n  TabsToLoad::iterator j =\n      find(tabs_to_load_.begin(), tabs_to_load_.end(), tab);\n  if (j != tabs_to_load_.end())\n    tabs_to_load_.erase(j);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n \t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n \t\t\tbreak;\n \t\tcase SIG('E', 'R'):\n \t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n \t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n \t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "usage(int iExitCode)\n {\n        char word[32];\n       sprintf( word, getJobActionString(mode) );\n        fprintf( stderr, \"Usage: %s [options] [constraints]\\n\", MyName );\n        fprintf( stderr, \" where [options] is zero or more of:\\n\" );\n        fprintf( stderr, \"  -help               Display this message and exit\\n\" );\n\tfprintf( stderr, \"  -version            Display version information and exit\\n\" );\n\n\n\tfprintf( stderr, \"  -name schedd_name   Connect to the given schedd\\n\" );\n\tfprintf( stderr, \"  -pool hostname      Use the given central manager to find daemons\\n\" );\n\tfprintf( stderr, \"  -addr <ip:port>     Connect directly to the given \\\"sinful string\\\"\\n\" );\n\tif( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {\n\t\tfprintf( stderr, \"  -reason reason      Use the given RemoveReason\\n\");\n\t} else if( mode == JA_RELEASE_JOBS ) {\n\t\tfprintf( stderr, \"  -reason reason      Use the given ReleaseReason\\n\");\n\t} else if( mode == JA_HOLD_JOBS ) {\n\t\tfprintf( stderr, \"  -reason reason      Use the given HoldReason\\n\");\n\t\tfprintf( stderr, \"  -subcode number     Set HoldReasonSubCode\\n\");\n\t}\n\n\tif( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {\n\t\tfprintf( stderr,\n\t\t\t\t     \"  -forcex             Force the immediate local removal of jobs in the X state\\n\"\n\t\t         \"                      (only affects jobs already being removed)\\n\" );\n\t}\n\tif( mode == JA_VACATE_JOBS || mode == JA_VACATE_FAST_JOBS ) {\n\t\tfprintf( stderr,\n\t\t\t\t     \"  -fast               Use a fast vacate (hardkill)\\n\" );\n\t}\n\tfprintf( stderr, \" and where [constraints] is one of:\\n\" );\n\tfprintf( stderr, \"  cluster.proc        %s the given job\\n\", word );\n\tfprintf( stderr, \"  cluster             %s the given cluster of jobs\\n\", word );\n\tfprintf( stderr, \"  user                %s all jobs owned by user\\n\", word );\n\tfprintf( stderr, \"  -constraint expr    %s all jobs matching the boolean expression\\n\", word );\n\tfprintf( stderr, \"  -all                %s all jobs \"\n\t\t\t \"(cannot be used with other constraints)\\n\", word );\n\texit( iExitCode );\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-134"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "LIBOPENMPT_MODPLUG_API int ModPlug_GetModuleType(ModPlugFile* file)\n{\n\tconst char* type;\n\tint retval;\n\tif(!file) return 0;\n\ttype = openmpt_module_get_metadata(file->mod,\"type\");\n\tretval = MOD_TYPE_NONE;\n\tif(!type){\n\t\treturn retval;\n\t}\n\tif(!strcmp(type,\"mod\")){\n\t\tretval = MOD_TYPE_MOD;\n\t}else if(!strcmp(type,\"s3m\")){\n\t\tretval = MOD_TYPE_S3M;\n\t}else if(!strcmp(type,\"xm\")){\n\t\tretval = MOD_TYPE_XM;\n\t}else if(!strcmp(type,\"med\")){\n\t\tretval = MOD_TYPE_MED;\n\t}else if(!strcmp(type,\"mtm\")){\n\t\tretval = MOD_TYPE_MTM;\n\t}else if(!strcmp(type,\"it\")){\n\t\tretval = MOD_TYPE_IT;\n\t}else if(!strcmp(type,\"669\")){\n\t\tretval = MOD_TYPE_669;\n\t}else if(!strcmp(type,\"ult\")){\n\t\tretval = MOD_TYPE_ULT;\n\t}else if(!strcmp(type,\"stm\")){\n\t\tretval = MOD_TYPE_STM;\n\t}else if(!strcmp(type,\"far\")){\n\t\tretval = MOD_TYPE_FAR;\n\t}else if(!strcmp(type,\"s3m\")){\n\t\tretval = MOD_TYPE_WAV;\n\t}else if(!strcmp(type,\"amf\")){\n\t\tretval = MOD_TYPE_AMF;\n\t}else if(!strcmp(type,\"ams\")){\n\t\tretval = MOD_TYPE_AMS;\n\t}else if(!strcmp(type,\"dsm\")){\n\t\tretval = MOD_TYPE_DSM;\n\t}else if(!strcmp(type,\"mdl\")){\n\t\tretval = MOD_TYPE_MDL;\n\t}else if(!strcmp(type,\"okt\")){\n\t\tretval = MOD_TYPE_OKT;\n\t}else if(!strcmp(type,\"mid\")){\n\t\tretval = MOD_TYPE_MID;\n\t}else if(!strcmp(type,\"dmf\")){\n\t\tretval = MOD_TYPE_DMF;\n\t}else if(!strcmp(type,\"ptm\")){\n\t\tretval = MOD_TYPE_PTM;\n\t}else if(!strcmp(type,\"dbm\")){\n\t\tretval = MOD_TYPE_DBM;\n\t}else if(!strcmp(type,\"mt2\")){\n\t\tretval = MOD_TYPE_MT2;\n\t}else if(!strcmp(type,\"amf0\")){\n\t\tretval = MOD_TYPE_AMF0;\n\t}else if(!strcmp(type,\"psm\")){\n\t\tretval = MOD_TYPE_PSM;\n\t}else if(!strcmp(type,\"j2b\")){\n\t\tretval = MOD_TYPE_J2B;\n\t}else if(!strcmp(type,\"abc\")){\n\t\tretval = MOD_TYPE_ABC;\n\t}else if(!strcmp(type,\"pat\")){\n\t\tretval = MOD_TYPE_PAT;\n\t}else if(!strcmp(type,\"umx\")){\n\t\tretval = MOD_TYPE_UMX;\n\t}else{\n\t\tretval = MOD_TYPE_IT; /* fallback, most complex type */\n\t}\n\topenmpt_free_string(type);\n\treturn retval;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-120"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static IW_INLINE void translate_coords(struct iw_context *ctx,\n\tint x, int y, int *prx, int *pry)\n{\n\tif(ctx->img1.orient_transform==0) {\n\t\t*prx = ctx->input_start_x+x;\n\t\t*pry = ctx->input_start_y+y;\n\t\treturn;\n\t}\n\n\tswitch(ctx->img1.orient_transform) {\n\tcase 1: // mirror-x\n\t\t*prx = ctx->img1.width - 1 - (ctx->input_start_x+x);\n\t\t*pry = ctx->input_start_y+y;\n\t\tbreak;\n\tcase 2: // mirror-y\n\t\t*prx = ctx->input_start_x+x;\n\t\t*pry = ctx->img1.height - 1 - (ctx->input_start_y+y);\n\t\tbreak;\n\tcase 3: // mirror-x, mirror-y\n\t\t*prx = ctx->img1.width - 1 - (ctx->input_start_x+x);\n\t\t*pry = ctx->img1.height - 1 - (ctx->input_start_y+y);\n\t\tbreak;\n\tcase 4:\n\t\t*prx = ctx->input_start_y+y;\n\t\t*pry = ctx->input_start_x+x;\n\t\tbreak;\n\tcase 5:\n\t\t*prx = ctx->input_start_y+y;\n\t\t*pry = ctx->img1.width - 1 - (ctx->input_start_x+x);\n\t\tbreak;\n\tcase 6:\n\t\t*prx = ctx->img1.height - 1 - (ctx->input_start_y+y);\n\t\t*pry = ctx->input_start_x+x;\n\t\tbreak;\n\tcase 7:\n\t\t*prx = ctx->img1.height - 1 - (ctx->input_start_y+y);\n\t\t*pry = ctx->img1.width - 1 - (ctx->input_start_x+x);\n\t\tbreak;\n\tdefault:\n\t\t*prx = 0;\n\t\t*pry = 0;\n\t\tbreak;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n \t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n \t\treturn -3;\n \t}\n \t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n \t * - 2.2.20.PortMappingDescription :\n \t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "gfx::Rect BrowserView::GetRestoredBounds() const {\n  return frame_->GetRestoredBounds();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\n\tperf_read_regs(regs);\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n \t\tif ((int)val < 0) {\n \t\t\t/* event has overflowed */\n \t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n \t\t}\n \t}\n \n\t/*\n\t * In case we didn't find and reset the event that caused\n\t * the interrupt, scan all events and reset any that are\n\t * negative, to avoid getting continual interrupts.\n\t * Any that we processed in the previous loop will not be negative.\n\t */\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif (pmc_overflow(val))\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\n\t/*\n\t * Reset MMCR0 to its normal value.  This will set PMXE and\n\t * clear FC (freeze counters) and PMAO (perf mon alert occurred)\n\t * and thus allow interrupts to occur again.\n\t * XXX might want to use MSR.PM to keep the events frozen until\n\t * we get back out of this interrupt.\n\t */\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline gfp_t htlb_alloc_mask(struct hstate *h)\n{\n\tif (hugepage_migration_supported(h))\n\t\treturn GFP_HIGHUSER_MOVABLE;\n\telse\n\t\treturn GFP_HIGHUSER;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ftp_genlist(ftpbuf_t *ftp, const char *cmd, const char *path TSRMLS_DC)\n{\n\tphp_stream\t*tmpstream = NULL;\n\tdatabuf_t\t*data = NULL;\n\tchar\t\t*ptr;\n\tint\t\tch, lastch;\n\tsize_t\t\tsize, rcvd;\n\tsize_t\t\tlines;\n\tchar\t\t**ret = NULL;\n\tchar\t\t**entry;\n\tchar\t\t*text;\n\n\n\tif ((tmpstream = php_stream_fopen_tmpfile()) == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to create temporary file.  Check permissions in temporary files directory.\");\n\t\treturn NULL;\n\t}\n\n\tif (!ftp_type(ftp, FTPTYPE_ASCII)) {\n\t\tgoto bail;\n\t}\n\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tftp->data = data;\n\n\tif (!ftp_putcmd(ftp, cmd, path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125 && ftp->resp != 226)) {\n\t\tgoto bail;\n\t}\n\n\t/* some servers don't open a ftp-data connection if the directory is empty */\n\tif (ftp->resp == 226) {\n\t\tftp->data = data_close(ftp, data);\n\t\tphp_stream_close(tmpstream);\n\t\treturn ecalloc(1, sizeof(char*));\n\t}\n\n\t/* pull data buffer into tmpfile */\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tsize = 0;\n\tlines = 0;\n\tlastch = 0;\n\twhile ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n\t\tif (rcvd == -1 || rcvd > ((size_t)(-1))-size) {\n\t\t\tgoto bail;\n\t\t}\n\n\t\tphp_stream_write(tmpstream, data->buf, rcvd);\n\n\t\tsize += rcvd;\n                for (ptr = data->buf; rcvd; rcvd--, ptr++) {\n                        if (*ptr == '\\n' && lastch == '\\r') {\n                                lines++;\n                       } else {\n                               size++;\n                        }\n                        lastch = *ptr;\n                }\n\t\t\tlastch = *ptr;\n\t\t}\n\t}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Document::queryCommandState(const String& commandName)\n{\n    return command(this, commandName).state() == TrueTriState;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int run_script(const char *name, const char *section,\n\t\t      const char *script, ...)\n{\n\tint ret;\n\tchar *buffer, *p;\n\tsize_t size = 0;\n\tva_list ap;\n\n\tINFO(\"Executing script '%s' for container '%s', config section '%s'\",\n\t     script, name, section);\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *)))\n\t\tsize += strlen(p) + 1;\n\tva_end(ap);\n\n\tsize += strlen(script);\n\tsize += strlen(name);\n\tsize += strlen(section);\n\tsize += 3;\n\n\tif (size > INT_MAX)\n\t\treturn -1;\n\n\tbuffer = alloca(size);\n\tif (!buffer) {\n\t\tERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tret = snprintf(buffer, size, \"%s %s %s\", script, name, section);\n\tif (ret < 0 || ret >= size) {\n\t\tERROR(\"Script name too long\");\n\t\treturn -1;\n\t}\n\n\tva_start(ap, script);\n\twhile ((p = va_arg(ap, char *))) {\n\t\tint len = size-ret;\n\t\tint rc;\n\t\trc = snprintf(buffer + ret, len, \" %s\", p);\n\t\tif (rc < 0 || rc >= len) {\n\t\t\tERROR(\"Script args too long\");\n\t\t\treturn -1;\n\t\t}\n\t\tret += rc;\n\t}\n\tva_end(ap);\n\n\treturn run_buffer(buffer);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-59"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Tab::GetHitTestMask(SkPath* mask) const {\n  *mask = tab_style()->GetPath(\n      TabStyle::PathType::kHitTest,\n      GetWidget()->GetCompositor()->device_scale_factor(),\n      /* force_active */ false, TabStyle::RenderUnits::kDips);\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ParseConfigurationArguments(const base::ListValue* args,\n                                 SyncConfigInfo* config,\n                                 const base::Value** callback_id) {\n  std::string json;\n  if (args->Get(0, callback_id) && args->GetString(1, &json) && !json.empty())\n    CHECK(GetConfiguration(json, config));\n  else\n    NOTREACHED();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n \tint n;\n \tconst char *bufptr;\n \n \tbufptr = buf;\n \n \tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n \n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n \t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n \n\t\tkfree(ucounts);\n\t}\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "tChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                            PARANDIS_ADAPTER *pContext,\n                                            ULONG virtioFlags,\n                                            tCompletePhysicalAddress *pPacketPages,\n                                            ULONG ulPacketLength,\n                                             ULONG ulDataOffset)\n {\n     tOffloadSettingsFlags f = pContext->Offload.flags;\n    tChecksumCheckResult res, resIp;\n     tTcpIpPacketParsingResult ppr;\n     ULONG flagsToCalculate = 0;\n     res.value = 0;\n    resIp.value = 0;\n \n\n    if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum; // check only\n\n    if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))\n    {\n        if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)\n        {\n            flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;\n        }\n        else\n        {\n            if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;\n            if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;\n            if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;\n            if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;\n        }\n    }\n \n     ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);\n \n     if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)\n     {\n         pContext->extraStatistics.framesRxCSHwOK++;\n        ppr.xxpCheckSum = ppresCSOK;\n    }\n\n    if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)\n    {\n        if (f.fRxIPChecksum)\n        {\n            res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;\n            res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;\n        }\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if (f.fRxTCPChecksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else /* UDP */\n            {\n                if (f.fRxUDPChecksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n    else if (ppr.ipStatus == ppresIPV6)\n    {\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if (f.fRxTCPv6Checksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else /* UDP */\n            {\n                if (f.fRxUDPv6Checksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n\n    return res;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SYSCALL_DEFINE5(perf_event_open,\n\t\tstruct perf_event_attr __user *, attr_uptr,\n\t\tpid_t, pid, int, cpu, int, group_fd, unsigned long, flags)\n{\n \tstruct perf_event *group_leader = NULL, *output_event = NULL;\n \tstruct perf_event *event, *sibling;\n \tstruct perf_event_attr attr;\n\tstruct perf_event_context *ctx;\n \tstruct file *event_file = NULL;\n \tstruct fd group = {NULL, 0};\n \tstruct task_struct *task = NULL;\n\tstruct pmu *pmu;\n\tint event_fd;\n\tint move_group = 0;\n\tint err;\n\tint f_flags = O_RDWR;\n\n\t/* for future expandability... */\n\tif (flags & ~PERF_FLAG_ALL)\n\t\treturn -EINVAL;\n\n\terr = perf_copy_attr(attr_uptr, &attr);\n\tif (err)\n\t\treturn err;\n\n\tif (!attr.exclude_kernel) {\n\t\tif (perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (attr.freq) {\n\t\tif (attr.sample_freq > sysctl_perf_event_sample_rate)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (attr.sample_period & (1ULL << 63))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * In cgroup mode, the pid argument is used to pass the fd\n\t * opened to the cgroup directory in cgroupfs. The cpu argument\n\t * designates the cpu on which to monitor threads from that\n\t * cgroup.\n\t */\n\tif ((flags & PERF_FLAG_PID_CGROUP) && (pid == -1 || cpu == -1))\n\t\treturn -EINVAL;\n\n\tif (flags & PERF_FLAG_FD_CLOEXEC)\n\t\tf_flags |= O_CLOEXEC;\n\n\tevent_fd = get_unused_fd_flags(f_flags);\n\tif (event_fd < 0)\n\t\treturn event_fd;\n\n\tif (group_fd != -1) {\n\t\terr = perf_fget_light(group_fd, &group);\n\t\tif (err)\n\t\t\tgoto err_fd;\n\t\tgroup_leader = group.file->private_data;\n\t\tif (flags & PERF_FLAG_FD_OUTPUT)\n\t\t\toutput_event = group_leader;\n\t\tif (flags & PERF_FLAG_FD_NO_GROUP)\n\t\t\tgroup_leader = NULL;\n\t}\n\n\tif (pid != -1 && !(flags & PERF_FLAG_PID_CGROUP)) {\n\t\ttask = find_lively_task_by_vpid(pid);\n\t\tif (IS_ERR(task)) {\n\t\t\terr = PTR_ERR(task);\n\t\t\tgoto err_group_fd;\n\t\t}\n\t}\n\n\tif (task && group_leader &&\n\t    group_leader->attr.inherit != attr.inherit) {\n\t\terr = -EINVAL;\n\t\tgoto err_task;\n\t}\n\n\tget_online_cpus();\n\n\tevent = perf_event_alloc(&attr, cpu, task, group_leader, NULL,\n\t\t\t\t NULL, NULL);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err_cpus;\n\t}\n\n\tif (flags & PERF_FLAG_PID_CGROUP) {\n\t\terr = perf_cgroup_connect(pid, event, &attr, group_leader);\n\t\tif (err) {\n\t\t\t__free_event(event);\n\t\t\tgoto err_cpus;\n\t\t}\n\t}\n\n\tif (is_sampling_event(event)) {\n\t\tif (event->pmu->capabilities & PERF_PMU_CAP_NO_INTERRUPT) {\n\t\t\terr = -ENOTSUPP;\n\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\taccount_event(event);\n\n\t/*\n\t * Special case software events and allow them to be part of\n\t * any hardware group.\n\t */\n\tpmu = event->pmu;\n\n\tif (group_leader &&\n\t    (is_software_event(event) != is_software_event(group_leader))) {\n\t\tif (is_software_event(event)) {\n\t\t\t/*\n\t\t\t * If event and group_leader are not both a software\n\t\t\t * event, and event is, then group leader is not.\n\t\t\t *\n\t\t\t * Allow the addition of software events to !software\n\t\t\t * groups, this is safe because software events never\n\t\t\t * fail to schedule.\n\t\t\t */\n\t\t\tpmu = group_leader->pmu;\n\t\t} else if (is_software_event(group_leader) &&\n\t\t\t   (group_leader->group_flags & PERF_GROUP_SOFTWARE)) {\n\t\t\t/*\n\t\t\t * In case the group is a pure software group, and we\n\t\t\t * try to add a hardware event, move the whole group to\n\t\t\t * the hardware context.\n\t\t\t */\n\t\t\tmove_group = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\tctx = find_get_context(pmu, task, event->cpu);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_alloc;\n\t}\n\n\tif (task) {\n\t\tput_task_struct(task);\n\t\ttask = NULL;\n\t}\n\n\t/*\n\t * Look up the group leader (we will attach this event to it):\n\t */\n\tif (group_leader) {\n\t\terr = -EINVAL;\n\n\t\t/*\n\t\t * Do not allow a recursive hierarchy (this new sibling\n\t\t * becoming part of another group-sibling):\n\t\t */\n\t\tif (group_leader->group_leader != group_leader)\n\t\t\tgoto err_context;\n\t\t/*\n\t\t * Do not allow to attach to a group in a different\n\t\t * task or CPU context:\n\t\t */\n\t\tif (move_group) {\n\t\t\t/*\n\t\t\t * Make sure we're both on the same task, or both\n\t\t\t * per-cpu events.\n\t\t\t */\n\t\t\tif (group_leader->ctx->task != ctx->task)\n\t\t\t\tgoto err_context;\n\n\t\t\t/*\n\t\t\t * Make sure we're both events for the same CPU;\n\t\t\t * grouping events for different CPUs is broken; since\n\t\t\t * you can never concurrently schedule them anyhow.\n\t\t\t */\n\t\t\tif (group_leader->cpu != event->cpu)\n\t\t\t\tgoto err_context;\n\t\t} else {\n\t\t\tif (group_leader->ctx != ctx)\n\t\t\t\tgoto err_context;\n\t\t}\n\n\t\t/*\n\t\t * Only a group leader can be exclusive or pinned\n\t\t */\n\t\tif (attr.exclusive || attr.pinned)\n\t\t\tgoto err_context;\n\t}\n\n\tif (output_event) {\n\t\terr = perf_event_set_output(event, output_event);\n\t\tif (err)\n\t\t\tgoto err_context;\n\t}\n\n\tevent_file = anon_inode_getfile(\"[perf_event]\", &perf_fops, event,\n\t\t\t\t\tf_flags);\n\tif (IS_ERR(event_file)) {\n\t\terr = PTR_ERR(event_file);\n\t\tgoto err_context;\n \t}\n \n \tif (move_group) {\n\t\tstruct perf_event_context *gctx = group_leader->ctx;\n \n\t\tmutex_lock(&gctx->mutex);\n \t\tperf_remove_from_context(group_leader, false);\n \n \t\t/*\n\t\t * Removing from the context ends up with disabled\n\t\t * event. What we want here is event in the initial\n\t\t * startup state, ready to be add into new context.\n\t\t */\n\t\tperf_event__state_init(group_leader);\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_remove_from_context(sibling, false);\n \t\t\tperf_event__state_init(sibling);\n \t\t\tput_ctx(gctx);\n \t\t}\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n \t}\n \n \tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n \n \tif (move_group) {\n \t\tsynchronize_rcu();\n \t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n \t\tget_ctx(ctx);\n \t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_install_in_context(ctx, sibling, sibling->cpu);\n\t\t\tget_ctx(ctx);\n\t\t}\n\t}\n \n \tperf_install_in_context(ctx, event, event->cpu);\n \tperf_unpin_context(ctx);\n \tmutex_unlock(&ctx->mutex);\n \n \tput_online_cpus();\n\n\tevent->owner = current;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_add_tail(&event->owner_entry, &current->perf_event_list);\n\tmutex_unlock(&current->perf_event_mutex);\n\n\t/*\n\t * Precalculate sample_data sizes\n\t */\n\tperf_event__header_size(event);\n\tperf_event__id_header_size(event);\n\n\t/*\n\t * Drop the reference on the group_event after placing the\n\t * new event on the sibling_list. This ensures destruction\n\t * of the group leader will find the pointer to itself in\n\t * perf_group_detach().\n\t */\n\tfdput(group);\n\tfd_install(event_fd, event_file);\n\treturn event_fd;\n\nerr_context:\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_alloc:\n\tfree_event(event);\nerr_cpus:\n\tput_online_cpus();\nerr_task:\n\tif (task)\n\t\tput_task_struct(task);\nerr_group_fd:\n\tfdput(group);\nerr_fd:\n\tput_unused_fd(event_fd);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline size_t php_mb3_int_to_char(unsigned char *buf, unsigned k)\n{\n\tassert(k <= 0xFFFFFFU);\n\t/* one to three bytes */\n\tif (k <= 0xFFU) { /* 1 */\n\t\tbuf[0] = k;\n\t\treturn 1U;\n\t} else if (k <= 0xFFFFU) { /* 2 */\n\t\tbuf[0] = k >> 8;\n\t\tbuf[1] = k & 0xFFU;\n\t\treturn 2U;\n\t} else {\n\t\tbuf[0] = k >> 16;\n\t\tbuf[1] = (k >> 8) & 0xFFU;\n\t\tbuf[2] = k & 0xFFU;\n\t\treturn 3U;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static size_t iwbmp_calc_bpr(int bpp, size_t width)\n{\n\treturn ((bpp*width+31)/32)*4;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool challenge_match(git_http_auth_scheme *scheme, void *data)\n{\n\tconst char *scheme_name = scheme->name;\n\tconst char *challenge = (const char *)data;\n\tsize_t scheme_len;\n\n\tscheme_len = strlen(scheme_name);\n\treturn (strncasecmp(challenge, scheme_name, scheme_len) == 0 &&\n\t\t(challenge[scheme_len] == '\\0' || challenge[scheme_len] == ' '));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool DebuggerFunction::InitAgentHost() {\n   if (debuggee_.tab_id) {\n     WebContents* web_contents = NULL;\n     bool result = ExtensionTabUtil::GetTabById(*debuggee_.tab_id,\n                                               GetProfile(),\n                                               include_incognito(),\n                                               NULL,\n                                               NULL,\n                                                &web_contents,\n                                                NULL);\n     if (result && web_contents) {\n      if (content::HasWebUIScheme(web_contents->GetURL())) {\n        error_ = ErrorUtils::FormatErrorMessage(\n            keys::kAttachToWebUIError,\n            web_contents->GetURL().scheme());\n         return false;\n      }\n       agent_host_ = DevToolsAgentHost::GetOrCreateFor(web_contents);\n     }\n   } else if (debuggee_.extension_id) {\n    ExtensionHost* extension_host =\n        ExtensionSystem::Get(GetProfile())\n             ->process_manager()\n             ->GetBackgroundHostForExtension(*debuggee_.extension_id);\n     if (extension_host) {\n       agent_host_ = DevToolsAgentHost::GetOrCreateFor(\n           extension_host->render_view_host());\n     }\n  } else if (debuggee_.target_id) {\n    agent_host_ = DevToolsAgentHost::GetForId(*debuggee_.target_id);\n  } else {\n    error_ = keys::kInvalidTargetError;\n    return false;\n  }\n\n  if (!agent_host_.get()) {\n    FormatErrorMessage(keys::kNoTargetError);\n    return false;\n  }\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "get_name_owner (DBusConnection     *connection,\n\t\tconst char         *name,\n\t\tGError            **error)\n{\n  DBusError derror;\n  DBusMessage *request, *reply;\n  char *base_name;\n  \n  dbus_error_init (&derror);\n\n  base_name = NULL;\n  reply = NULL;\n\n  request = dbus_message_new_method_call (DBUS_SERVICE_DBUS,\n\t\t\t\t\t  DBUS_PATH_DBUS,\n\t\t\t\t\t  DBUS_INTERFACE_DBUS,\n\t\t\t\t\t  \"GetNameOwner\");\n  if (request == NULL)\n    g_error (\"Out of memory\");\n  \n  if (!dbus_message_append_args (request, \n\t\t\t\t DBUS_TYPE_STRING, &name, \n\t\t\t\t DBUS_TYPE_INVALID))\n    g_error (\"Out of memory\");\n\n  reply =\n    dbus_connection_send_with_reply_and_block (connection,\n                                               request,\n                                               2000, &derror);\n  if (reply == NULL)\n    goto error;\n\n  if (dbus_set_error_from_message (&derror, reply))\n    goto error;\n\n  if (!dbus_message_get_args (reply, &derror, \n\t\t\t      DBUS_TYPE_STRING, &base_name, \n\t\t\t      DBUS_TYPE_INVALID))\n    goto error;\n\n  base_name = g_strdup (base_name);\n  goto out;\n\n error:\n  g_assert (dbus_error_is_set (&derror));\n  dbus_set_g_error (error, &derror);\n  dbus_error_free (&derror);\n\n out:\n  if (request)\n    dbus_message_unref (request);\n  if (reply)\n    dbus_message_unref (reply);\n\n  return base_name;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int main(int argc, char *argv[] ) {\n\tint i, fails_count=0;\n\tCU_pSuite cryptoUtilsTestSuite, parserTestSuite;\n\n\tCU_pSuite *suites[] = {\n\t\t&cryptoUtilsTestSuite,\n\t\t&parserTestSuite,\n\t\tNULL\n\t};\n\n\tif (argc>1) {\n\t\tif (argv[1][0] == '-') {\n\t\t\tif (strcmp(argv[1], \"-verbose\") == 0) {\n\t\t\t\tverbose = 1;\n\t\t\t} else {\n\t\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n#ifdef HAVE_LIBXML2\n\txmlInitParser();\n#endif\n\t\n\t/* initialize the CUnit test registry */\n\tif (CUE_SUCCESS != CU_initialize_registry()) {\n\t\treturn CU_get_error();\n\t}\n\n\t/* Add the cryptoUtils suite to the registry */\n\tcryptoUtilsTestSuite = CU_add_suite(\"Bzrtp Crypto Utils\", NULL, NULL);\n\tCU_add_test(cryptoUtilsTestSuite, \"zrtpKDF\", test_zrtpKDF);\n\tCU_add_test(cryptoUtilsTestSuite, \"CRC32\", test_CRC32);\n\tCU_add_test(cryptoUtilsTestSuite, \"algo agreement\", test_algoAgreement);\n\tCU_add_test(cryptoUtilsTestSuite, \"context algo setter and getter\", test_algoSetterGetter);\n\tCU_add_test(cryptoUtilsTestSuite, \"adding mandatory crypto algorithms if needed\", test_addMandatoryCryptoTypesIfNeeded);\n\n \t/* Add the parser suite to the registry */\n \tparserTestSuite = CU_add_suite(\"Bzrtp ZRTP Packet Parser\", NULL, NULL);\n \tCU_add_test(parserTestSuite, \"Parse\", test_parser);\n \tCU_add_test(parserTestSuite, \"Parse Exchange\", test_parserComplete);\n \tCU_add_test(parserTestSuite, \"State machine\", test_stateMachine);\n \n\t/* Run all suites */\n\tfor(i=0; suites[i]; i++){\n\t\tCU_basic_run_suite(*suites[i]);\n\t\tfails_count += CU_get_number_of_tests_failed();\n\t}\n\t\n\t/* cleanup the CUnit registry */\n\tCU_cleanup_registry();\n\n#ifdef HAVE_LIBXML2\n\t/* cleanup libxml2 */\n\txmlCleanupParser();\n#endif\n\n\treturn (fails_count == 0 ? 0 : 1);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void __napi_complete(struct napi_struct *n)\n{\n\tBUG_ON(!test_bit(NAPI_STATE_SCHED, &n->state));\n\n\tlist_del_init(&n->poll_list);\n\tsmp_mb__before_atomic();\n\tclear_bit(NAPI_STATE_SCHED, &n->state);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-400"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool CreateIpcChannel(\n     const std::string& channel_name,\n     const std::string& pipe_security_descriptor,\n    scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,\n    IPC::Listener* delegate,\n    scoped_ptr<IPC::ChannelProxy>* channel_out) {\n   SECURITY_ATTRIBUTES security_attributes;\n   security_attributes.nLength = sizeof(security_attributes);\n  security_attributes.bInheritHandle = FALSE;\n\n  ULONG security_descriptor_length = 0;\n  if (!ConvertStringSecurityDescriptorToSecurityDescriptor(\n          UTF8ToUTF16(pipe_security_descriptor).c_str(),\n          SDDL_REVISION_1,\n          reinterpret_cast<PSECURITY_DESCRIPTOR*>(\n              &security_attributes.lpSecurityDescriptor),\n          &security_descriptor_length)) {\n    LOG_GETLASTERROR(ERROR) <<\n        \"Failed to create a security descriptor for the Chromoting IPC channel\";\n    return false;\n  }\n\n  std::string pipe_name(kChromePipeNamePrefix);\n  pipe_name.append(channel_name);\n\n  base::win::ScopedHandle pipe;\n  pipe.Set(CreateNamedPipe(\n      UTF8ToUTF16(pipe_name).c_str(),\n      PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,\n      PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,\n      1,\n      IPC::Channel::kReadBufferSize,\n      IPC::Channel::kReadBufferSize,\n      5000,\n      &security_attributes));\n  if (!pipe.IsValid()) {\n    LOG_GETLASTERROR(ERROR) <<\n        \"Failed to create the server end of the Chromoting IPC channel\";\n    LocalFree(security_attributes.lpSecurityDescriptor);\n    return false;\n  }\n \n   LocalFree(security_attributes.lpSecurityDescriptor);\n \n  channel_out->reset(new IPC::ChannelProxy(\n      IPC::ChannelHandle(pipe),\n      IPC::Channel::MODE_SERVER,\n      delegate,\n      io_task_runner));\n   return true;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ui::MenuSourceType context_menu_source_type() const {\n    return context_menu_params_.source_type;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "uint8_t ndp_msgra_curhoplimit(struct ndp_msgra *msgra)\n{\n\treturn msgra->ra->nd_ra_curhoplimit;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tstruct ext4_ext_path *path;\n\tstruct ext4_extent *extent;\n\text4_lblk_t offset_lblk, len_lblk, ee_start_lblk = 0;\n\tunsigned int credits, ee_len;\n\tint ret = 0, depth, split_flag = 0;\n\tloff_t ioffset;\n\n\t/*\n\t * We need to test this early because xfstests assumes that an\n\t * insert range of (0, 1) will return EOPNOTSUPP if the file\n\t * system does not support insert range.\n\t */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Insert range works only on fs block size aligned offsets. */\n\tif (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||\n\t\t\tlen & (EXT4_CLUSTER_SIZE(sb) - 1))\n\t\treturn -EINVAL;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_insert_range(inode, offset, len);\n\n\toffset_lblk = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tlen_lblk = len >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* Call ext4_force_commit to flush all data in case of data=journal */\n\tif (ext4_should_journal_data(inode)) {\n\t\tret = ext4_force_commit(inode->i_sb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Need to round down to align start offset to page size boundary\n\t * for page size > block size.\n\t */\n\tioffset = round_down(offset, PAGE_SIZE);\n\n\t/* Write out all dirty pages */\n\tret = filemap_write_and_wait_range(inode->i_mapping, ioffset,\n\t\t\tLLONG_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take mutex lock */\n\tmutex_lock(&inode->i_mutex);\n\n\t/* Currently just for extent based files */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Check for wrap through zero */\n\tif (inode->i_size + len > inode->i_sb->s_maxbytes) {\n\t\tret = -EFBIG;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Offset should be less than i_size */\n\tif (offset >= i_size_read(inode)) {\n\t\tret = -EINVAL;\n \t\tgoto out_mutex;\n \t}\n \n\ttruncate_pagecache(inode, ioffset);\n \t/* Wait for existing dio to complete */\n \text4_inode_block_unlocked_dio(inode);\n \tinode_dio_wait(inode);\n \n \tcredits = ext4_writepage_trans_blocks(inode);\n \thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n \tif (IS_ERR(handle)) {\n \t\tret = PTR_ERR(handle);\n\t\tgoto out_dio;\n \t}\n \n \t/* Expand file to avoid data loss if there is error while shifting */\n\tinode->i_size += len;\n\tEXT4_I(inode)->i_disksize += len;\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\tret = ext4_mark_inode_dirty(handle, inode);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tpath = ext4_find_extent(inode, offset_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tdepth = ext_depth(inode);\n\textent = path[depth].p_ext;\n\tif (extent) {\n\t\tee_start_lblk = le32_to_cpu(extent->ee_block);\n\t\tee_len = ext4_ext_get_actual_len(extent);\n\n\t\t/*\n\t\t * If offset_lblk is not the starting block of extent, split\n\t\t * the extent @offset_lblk\n\t\t */\n\t\tif ((offset_lblk > ee_start_lblk) &&\n\t\t\t\t(offset_lblk < (ee_start_lblk + ee_len))) {\n\t\t\tif (ext4_ext_is_unwritten(extent))\n\t\t\t\tsplit_flag = EXT4_EXT_MARK_UNWRIT1 |\n\t\t\t\t\tEXT4_EXT_MARK_UNWRIT2;\n\t\t\tret = ext4_split_extent_at(handle, inode, &path,\n\t\t\t\t\toffset_lblk, split_flag,\n\t\t\t\t\tEXT4_EX_NOCACHE |\n\t\t\t\t\tEXT4_GET_BLOCKS_PRE_IO |\n\t\t\t\t\tEXT4_GET_BLOCKS_METADATA_NOFAIL);\n\t\t}\n\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\tif (ret < 0) {\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto out_stop;\n\t\t}\n\t}\n\n\tret = ext4_es_remove_extent(inode, offset_lblk,\n\t\t\tEXT_MAX_BLOCKS - offset_lblk);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\t/*\n\t * if offset_lblk lies in a hole which is at start of file, use\n\t * ee_start_lblk to shift extents\n\t */\n\tret = ext4_ext_shift_extents(inode, handle,\n\t\tee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk,\n\t\tlen_lblk, SHIFT_RIGHT);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n \n out_stop:\n \text4_journal_stop(handle);\nout_dio:\n \text4_inode_resume_unlocked_dio(inode);\n out_mutex:\n \tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "gpk_parse_fileinfo(sc_card_t *card,\n\t\tconst u8 *buf, size_t buflen,\n\t\tsc_file_t *file)\n{\n\tconst u8\t*sp, *end, *next;\n\tint\t\ti, rc;\n\n\tmemset(file, 0, sizeof(*file));\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_add_acl_entry(file, i, SC_AC_UNKNOWN, SC_AC_KEY_REF_NONE);\n\n\tend = buf + buflen;\n\tfor (sp = buf; sp + 2 < end; sp = next) {\n\t\tnext = sp + 2 + sp[1];\n\t\tif (next > end)\n\t\t\tbreak;\n\t\tif (sp[0] == 0x84) {\n\t\t\t/* ignore if name is longer than what it should be */\n\t\t\tif (sp[1] > sizeof(file->name))\n\t\t\t\tcontinue;\n\t\t\tmemset(file->name, 0, sizeof(file->name));\n\t\t\tmemcpy(file->name, sp+2, sp[1]);\n\t\t} else\n \t\tif (sp[0] == 0x85) {\n \t\t\tunsigned int\tac[3], n;\n \n \t\t\tfile->id = (sp[4] << 8) | sp[5];\n \t\t\tfile->size = (sp[8] << 8) | sp[9];\n \t\t\tfile->record_length = sp[7];\n\n\t\t\t/* Map ACLs. Note the third AC byte is\n\t\t\t * valid of EFs only */\n\t\t\tfor (n = 0; n < 3; n++)\n\t\t\t\tac[n] = (sp[10+2*n] << 8) | sp[11+2*n];\n\n\t\t\t/* Examine file type */\n\t\t\tswitch (sp[6] & 7) {\n\t\t\tcase 0x01: case 0x02: case 0x03: case 0x04:\n\t\t\tcase 0x05: case 0x06: case 0x07:\n\t\t\t\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\t\t\t\tfile->ef_structure = sp[6] & 7;\n\t\t\t\tac_to_acl(ac[0], file, SC_AC_OP_UPDATE);\n\t\t\t\tac_to_acl(ac[1], file, SC_AC_OP_WRITE);\n\t\t\t\tac_to_acl(ac[2], file, SC_AC_OP_READ);\n\t\t\t\tbreak;\n\t\t\tcase 0x00: /* 0x38 is DF */\n\t\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\t\t/* Icky: the GPK uses different ACLs\n\t\t\t\t * for creating data files and\n\t\t\t\t * 'sensitive' i.e. key files */\n\t\t\t\tac_to_acl(ac[0], file, SC_AC_OP_LOCK);\n\t\t\t\tac_to_acl(ac[1], file, SC_AC_OP_CREATE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_SELECT,\n\t\t\t\t\tSC_AC_NONE, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_DELETE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tsc_file_add_acl_entry(file, SC_AC_OP_LIST_FILES,\n\t\t\t\t\tSC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\tif (sp[0] == 0x6f) {\n\t\t\t/* oops - this is a directory with an IADF.\n\t\t\t * This happens with the personalized GemSafe cards\n\t\t\t * for instance. */\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t\trc = gpk_parse_fci(card, sp + 2, sp[1], file);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (file->record_length)\n\t\tfile->record_count = file->size / file->record_length;\n\tfile->magic = SC_FILE_MAGIC;\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void atl2_reinit_locked(struct atl2_adapter *adapter)\n{\n\tWARN_ON(in_interrupt());\n\twhile (test_and_set_bit(__ATL2_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\tatl2_down(adapter);\n\tatl2_up(adapter);\n\tclear_bit(__ATL2_RESETTING, &adapter->flags);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "RenderFrameHostManager::GetSiteInstanceForNavigationRequest(\n    const NavigationRequest& request) {\n  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();\n  bool no_renderer_swap_allowed = false;\n  bool was_server_redirect = request.navigation_handle() &&\n                             request.navigation_handle()->WasServerRedirect();\n\n  if (frame_tree_node_->IsMainFrame()) {\n    bool can_renderer_initiate_transfer =\n        (request.state() == NavigationRequest::FAILED &&\n         SiteIsolationPolicy::IsErrorPageIsolationEnabled(\n             true /* in_main_frame */)) ||\n        (render_frame_host_->IsRenderFrameLive() &&\n         IsURLHandledByNetworkStack(request.common_params().url) &&\n         IsRendererTransferNeededForNavigation(render_frame_host_.get(),\n                                               request.common_params().url));\n    no_renderer_swap_allowed |=\n        request.from_begin_navigation() && !can_renderer_initiate_transfer;\n  } else {\n     no_renderer_swap_allowed |= !CanSubframeSwapProcess(\n         request.common_params().url, request.source_site_instance(),\n        request.dest_site_instance(), was_server_redirect);\n   }\n \n   if (no_renderer_swap_allowed)\n    return scoped_refptr<SiteInstance>(current_site_instance);\n\n  SiteInstance* candidate_site_instance =\n      speculative_render_frame_host_\n          ? speculative_render_frame_host_->GetSiteInstance()\n          : nullptr;\n\n  scoped_refptr<SiteInstance> dest_site_instance = GetSiteInstanceForNavigation(\n      request.common_params().url, request.source_site_instance(),\n      request.dest_site_instance(), candidate_site_instance,\n      request.common_params().transition,\n      request.state() == NavigationRequest::FAILED,\n      request.restore_type() != RestoreType::NONE, request.is_view_source(),\n      was_server_redirect);\n\n  return dest_site_instance;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-285"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "FT_Outline_Decompose( const FT_Outline*        outline,\n                        const FT_Outline_Funcs*  func_interface,\n                        void*                    user )\n  {\n#undef SCALED\n#define SCALED( x )  ( ( (x) << shift ) - delta )\n\n    FT_Vector   v_last;\n    FT_Vector   v_control;\n    FT_Vector   v_start;\n\n    FT_Vector*  point;\n    FT_Vector*  limit;\n    char*       tags;\n\n    int         error;\n\n    int   n;         /* index of contour in outline     */\n    int   first;     /* index of first point in contour */\n    char  tag;       /* current point's state           */\n\n    int   shift;\n    TPos  delta;\n\n\n    if ( !outline || !func_interface )\n      return ErrRaster_Invalid_Argument;\n\n    shift = func_interface->shift;\n    delta = func_interface->delta;\n    first = 0;\n\n    for ( n = 0; n < outline->n_contours; n++ )\n    {\n      int  last;  /* index of last point in contour */\n\n\n      FT_TRACE5(( \"FT_Outline_Decompose: Outline %d\\n\", n ));\n\n      last  = outline->contours[n];\n      if ( last < 0 )\n        goto Invalid_Outline;\n      limit = outline->points + last;\n\n      v_start   = outline->points[first];\n      v_start.x = SCALED( v_start.x );\n      v_start.y = SCALED( v_start.y );\n\n      v_last   = outline->points[last];\n      v_last.x = SCALED( v_last.x );\n      v_last.y = SCALED( v_last.y );\n\n      v_control = v_start;\n\n      point = outline->points + first;\n      tags  = outline->tags   + first;\n      tag   = FT_CURVE_TAG( tags[0] );\n\n      /* A contour cannot start with a cubic control point! */\n      if ( tag == FT_CURVE_TAG_CUBIC )\n        goto Invalid_Outline;\n\n      /* check first point to determine origin */\n      if ( tag == FT_CURVE_TAG_CONIC )\n      {\n        /* first point is conic control.  Yes, this happens. */\n        if ( FT_CURVE_TAG( outline->tags[last] ) == FT_CURVE_TAG_ON )\n        {\n          /* start at last point if it is on the curve */\n          v_start = v_last;\n          limit--;\n        }\n        else\n        {\n          /* if both first and last points are conic,         */\n          /* start at their middle and record its position    */\n          /* for closure                                      */\n          v_start.x = ( v_start.x + v_last.x ) / 2;\n          v_start.y = ( v_start.y + v_last.y ) / 2;\n\n          v_last = v_start;\n        }\n        point--;\n        tags--;\n      }\n\n      FT_TRACE5(( \"  move to (%.2f, %.2f)\\n\",\n                  v_start.x / 64.0, v_start.y / 64.0 ));\n      error = func_interface->move_to( &v_start, user );\n      if ( error )\n        goto Exit;\n\n      while ( point < limit )\n      {\n        point++;\n        tags++;\n\n        tag = FT_CURVE_TAG( tags[0] );\n        switch ( tag )\n        {\n        case FT_CURVE_TAG_ON:  /* emit a single line_to */\n          {\n            FT_Vector  vec;\n\n\n            vec.x = SCALED( point->x );\n            vec.y = SCALED( point->y );\n\n            FT_TRACE5(( \"  line to (%.2f, %.2f)\\n\",\n                        vec.x / 64.0, vec.y / 64.0 ));\n            error = func_interface->line_to( &vec, user );\n            if ( error )\n              goto Exit;\n            continue;\n          }\n\n        case FT_CURVE_TAG_CONIC:  /* consume conic arcs */\n          v_control.x = SCALED( point->x );\n          v_control.y = SCALED( point->y );\n\n        Do_Conic:\n          if ( point < limit )\n          {\n            FT_Vector  vec;\n            FT_Vector  v_middle;\n\n\n            point++;\n            tags++;\n            tag = FT_CURVE_TAG( tags[0] );\n\n            vec.x = SCALED( point->x );\n            vec.y = SCALED( point->y );\n\n            if ( tag == FT_CURVE_TAG_ON )\n            {\n              FT_TRACE5(( \"  conic to (%.2f, %.2f)\"\n                          \" with control (%.2f, %.2f)\\n\",\n                          vec.x / 64.0, vec.y / 64.0,\n                          v_control.x / 64.0, v_control.y / 64.0 ));\n              error = func_interface->conic_to( &v_control, &vec, user );\n              if ( error )\n                goto Exit;\n              continue;\n            }\n\n            if ( tag != FT_CURVE_TAG_CONIC )\n              goto Invalid_Outline;\n\n            v_middle.x = ( v_control.x + vec.x ) / 2;\n            v_middle.y = ( v_control.y + vec.y ) / 2;\n\n            FT_TRACE5(( \"  conic to (%.2f, %.2f)\"\n                        \" with control (%.2f, %.2f)\\n\",\n                        v_middle.x / 64.0, v_middle.y / 64.0,\n                        v_control.x / 64.0, v_control.y / 64.0 ));\n            error = func_interface->conic_to( &v_control, &v_middle, user );\n            if ( error )\n              goto Exit;\n\n            v_control = vec;\n            goto Do_Conic;\n          }\n\n          FT_TRACE5(( \"  conic to (%.2f, %.2f)\"\n                      \" with control (%.2f, %.2f)\\n\",\n                      v_start.x / 64.0, v_start.y / 64.0,\n                      v_control.x / 64.0, v_control.y / 64.0 ));\n          error = func_interface->conic_to( &v_control, &v_start, user );\n          goto Close;\n\n        default:  /* FT_CURVE_TAG_CUBIC */\n          {\n            FT_Vector  vec1, vec2;\n\n\n            if ( point + 1 > limit                             ||\n                 FT_CURVE_TAG( tags[1] ) != FT_CURVE_TAG_CUBIC )\n              goto Invalid_Outline;\n\n            point += 2;\n            tags  += 2;\n\n            vec1.x = SCALED( point[-2].x );\n            vec1.y = SCALED( point[-2].y );\n\n            vec2.x = SCALED( point[-1].x );\n            vec2.y = SCALED( point[-1].y );\n\n            if ( point <= limit )\n            {\n              FT_Vector  vec;\n\n\n              vec.x = SCALED( point->x );\n              vec.y = SCALED( point->y );\n\n              FT_TRACE5(( \"  cubic to (%.2f, %.2f)\"\n                          \" with controls (%.2f, %.2f) and (%.2f, %.2f)\\n\",\n                          vec.x / 64.0, vec.y / 64.0,\n                          vec1.x / 64.0, vec1.y / 64.0,\n                          vec2.x / 64.0, vec2.y / 64.0 ));\n              error = func_interface->cubic_to( &vec1, &vec2, &vec, user );\n              if ( error )\n                goto Exit;\n              continue;\n            }\n\n            FT_TRACE5(( \"  cubic to (%.2f, %.2f)\"\n                        \" with controls (%.2f, %.2f) and (%.2f, %.2f)\\n\",\n                        v_start.x / 64.0, v_start.y / 64.0,\n                        vec1.x / 64.0, vec1.y / 64.0,\n                        vec2.x / 64.0, vec2.y / 64.0 ));\n            error = func_interface->cubic_to( &vec1, &vec2, &v_start, user );\n            goto Close;\n          }\n        }\n      }\n\n      /* close the contour with a line segment */\n      FT_TRACE5(( \"  line to (%.2f, %.2f)\\n\",\n                  v_start.x / 64.0, v_start.y / 64.0 ));\n      error = func_interface->line_to( &v_start, user );\n\n   Close:\n      if ( error )\n        goto Exit;\n\n      first = last + 1;\n    }\n\n    FT_TRACE5(( \"FT_Outline_Decompose: Done\\n\", n ));\n    return 0;\n\n  Exit:\n    FT_TRACE5(( \"FT_Outline_Decompose: Error %d\\n\", error ));\n    return error;\n\n  Invalid_Outline:\n    return ErrRaster_Invalid_Outline;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MaxTextExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      InheritException(exception,&image->exception);\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->x_resolution=(double) jpeg_info.X_density;\n      image->y_resolution=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize for us.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n   if (option != (const char *) NULL)\n     if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((jpeg_info.output_components == 1) &&\n      (jpeg_info.quantize_colors == 0))\n     {\n       size_t\n         colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image);\n  (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            size_t\n              pixel;\n\n            pixel=(size_t) (scale*GETJSAMPLE(*p));\n            index=ConstrainColormapIndex(image,pixel);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));\n          SetPixelIndex(indexes+x,index);\n          SetPixelRGBO(q,image->colormap+(ssize_t) index);\n          p++;\n          q++;\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n \tstruct se_cmd *cmd;\n \tstruct se_session *sess = ch->sess;\n \tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n \tint tcm_tmr;\n \tint rc;\n \n\tBUG_ON(!send_ioctx);\n\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\n \tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n \tsend_ioctx->cmd.tag = srp_tsk->tag;\n \ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n \tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n \t\t\t\t       sizeof(srp_tsk->lun));\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n \trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n \t\t\t\tTARGET_SCF_ACK_KREF);\n \tif (rc != 0) {\n \t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); // XXX:\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\n\tINFO(\"Mounting container /dev\");\n\n\t/* $(rootfs->mount) + \"/dev/pts\" + '\\0' */\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n \t\treturn 0;\n \t}\n \n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n \t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n \t\treturn false;\n \t}\n\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\t/*\n\t * If we are running on a devtmpfs mapping, dev/pts may already exist.\n\t * If not, then create it and exit if that fails...\n\t */\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-59"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "htmlParseElementInternal(htmlParserCtxtPtr ctxt) {\n     const xmlChar *name;\n     const htmlElemDesc * info;\n    htmlParserNodeInfo node_info = { 0, };\n     int failed;\n \n     if ((ctxt == NULL) || (ctxt->input == NULL)) {\n\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t     \"htmlParseElementInternal: context error\\n\", NULL, NULL);\n\treturn;\n    }\n\n    if (ctxt->instate == XML_PARSER_EOF)\n        return;\n\n    /* Capture start position */\n    if (ctxt->record_info) {\n        node_info.begin_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n\tnode_info.begin_line = ctxt->input->line;\n    }\n\n    failed = htmlParseStartTag(ctxt);\n    name = ctxt->name;\n    if ((failed == -1) || (name == NULL)) {\n\tif (CUR == '>')\n\t    NEXT;\n        return;\n    }\n\n    /*\n     * Lookup the info for that element.\n     */\n    info = htmlTagLookup(name);\n    if (info == NULL) {\n\thtmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n\t             \"Tag %s invalid\\n\", name, NULL);\n    }\n\n    /*\n     * Check for an Empty Element labeled the XML/SGML way\n     */\n    if ((CUR == '/') && (NXT(1) == '>')) {\n        SKIP(2);\n\tif ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n\t    ctxt->sax->endElement(ctxt->userData, name);\n\thtmlnamePop(ctxt);\n\treturn;\n    }\n\n    if (CUR == '>') {\n        NEXT;\n    } else {\n\thtmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n\t             \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n\n\t/*\n\t * end of parsing of this node.\n\t */\n\tif (xmlStrEqual(name, ctxt->name)) {\n\t    nodePop(ctxt);\n\t    htmlnamePop(ctxt);\n\t}\n\n        if (ctxt->record_info)\n            htmlNodeInfoPush(ctxt, &node_info);\n        htmlParserFinishElementParsing(ctxt);\n\treturn;\n    }\n\n    /*\n     * Check for an Empty Element from DTD definition\n     */\n    if ((info != NULL) && (info->empty)) {\n\tif ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n\t    ctxt->sax->endElement(ctxt->userData, name);\n\thtmlnamePop(ctxt);\n\treturn;\n    }\n\n    if (ctxt->record_info)\n        htmlNodeInfoPush(ctxt, &node_info);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static const char *getcmdid(struct connectdata *conn)\n{\n  static const char * const ids[]= {\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\"\n  };\n\n  struct imap_conn *imapc = &conn->proto.imapc;\n\n  /* get the next id, but wrap at end of table */\n  imapc->cmdid = (int)((imapc->cmdid+1) % (sizeof(ids)/sizeof(ids[0])));\n\n  return ids[imapc->cmdid];\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-89"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int X509_verify(X509 *a, EVP_PKEY *r)\n \t{\n \treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n \t\ta->signature,a->cert_info,r));\n \t}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n {\n \tu32 data;\n\tvoid *vapic;\n \n \tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n \t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n \n \tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n \t\treturn;\n \n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n \n \tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    (void) ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name,exception);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    (void) count;\n    image->columns=iris_info.columns;\n     image->rows=iris_info.rows;\n     image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n     if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*\n        iris_info.bytes_per_pixel,MAGICKCORE_QUANTUM_DEPTH);\n     if (iris_info.depth < 3)\n       {\n         image->storage_class=PseudoClass;\n         image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;\n       }\n     if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets == (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength == (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info == (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  1L*iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n           \n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  1L*iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait : \n      UndefinedPixelTrait;\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))),q);\n                SetPixelGreen(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))),q);\n                SetPixelBlue(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))),q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(image,(Quantum) quantum,q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p,q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image,exception);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void print_maps(struct pid_info_t* info)\n {\n     FILE *maps;\n     size_t offset;\n     char device[10];\n     long int inode;\n    char file[PATH_MAX];\n \n     strlcat(info->path, \"maps\", sizeof(info->path));\n \n    maps = fopen(info->path, \"r\");\n\n     if (!maps)\n         goto out;\n \n    while (fscanf(maps, \"%*x-%*x %*s %zx %s %ld %s\\n\", &offset, device, &inode,\n            file) == 4) {\n         if (inode == 0 || !strcmp(device, \"00:00\"))\n             continue;\n\n        printf(\"%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\\n\",\n                info->cmdline, info->pid, info->user, \"mem\",\n \"???\", device, offset, inode, file);\n }\n\n    fclose(maps);\n\nout:\n    info->path[info->parent_length] = '\\0';\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n               bpp=BitmapHeader2.Depth;\n \n             UnpackRaster:      \n               if ((image->colors == 0) && (bpp != 24))\n                 {\n                   image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                 }\n               image->columns=Bitmap2Header1.Width;\n               image->rows=Bitmap2Header1.Height;\n \n               if ((image->colors == 0) && (bpp != 24))\n                 {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    (void) RemoveLastImageFromList(&image);\n                    AppendImageToList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     (void) RemoveLastImageFromList(&image);\n                     AppendImageToList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n          ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n       }\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n \n  Finish:\n   (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "BookmarksIOFunction::BookmarksIOFunction() {}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "reply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply) {\n\tint error;\n\tchar addrbuf[128];\n\tstatic const int error_codes[] = {\n\t\tDNS_ERR_FORMAT, DNS_ERR_SERVERFAILED, DNS_ERR_NOTEXIST,\n\t\tDNS_ERR_NOTIMPL, DNS_ERR_REFUSED\n\t};\n\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (flags & 0x020f || !reply || !reply->have_answer) {\n\t\t/* there was an error */\n\t\tif (flags & 0x0200) {\n\t\t\terror = DNS_ERR_TRUNCATED;\n\t\t} else if (flags & 0x000f) {\n\t\t\tu16 error_code = (flags & 0x000f) - 1;\n\t\t\tif (error_code > 4) {\n\t\t\t\terror = DNS_ERR_UNKNOWN;\n\t\t\t} else {\n\t\t\t\terror = error_codes[error_code];\n\t\t\t}\n\t\t} else if (reply && !reply->have_answer) {\n\t\t\terror = DNS_ERR_NODATA;\n\t\t} else {\n\t\t\terror = DNS_ERR_UNKNOWN;\n\t\t}\n\n\t\tswitch (error) {\n\t\tcase DNS_ERR_NOTIMPL:\n\t\tcase DNS_ERR_REFUSED:\n\t\t\t/* we regard these errors as marking a bad nameserver */\n\t\t\tif (req->reissue_count < req->base->global_max_reissues) {\n\t\t\t\tchar msg[64];\n\t\t\t\tevutil_snprintf(msg, sizeof(msg), \"Bad response %d (%s)\",\n\t\t\t\t\t error, evdns_err_to_string(error));\n\t\t\t\tnameserver_failed(req->ns, msg);\n\t\t\t\tif (!request_reissue(req)) return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_ERR_SERVERFAILED:\n\t\t\t/* rcode 2 (servfailed) sometimes means \"we\n\t\t\t * are broken\" and sometimes (with some binds)\n\t\t\t * means \"that request was very confusing.\"\n\t\t\t * Treat this as a timeout, not a failure.\n\t\t\t */\n\t\t\tlog(EVDNS_LOG_DEBUG, \"Got a SERVERFAILED from nameserver\"\n\t\t\t\t\"at %s; will allow the request to time out.\",\n\t\t\t    evutil_format_sockaddr_port_(\n\t\t\t\t    (struct sockaddr *)&req->ns->address,\n\t\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t\t/* Call the timeout function */\n\t\t\tevdns_request_timeout_callback(0, 0, req);\n\t\t\treturn;\n\t\tdefault:\n\t\t\t/* we got a good reply from the nameserver: it is up. */\n\t\t\tif (req->handle == req->ns->probe_request) {\n\t\t\t\t/* Avoid double-free */\n\t\t\t\treq->ns->probe_request = NULL;\n\t\t\t}\n\n\t\t\tnameserver_up(req->ns);\n\t\t}\n\n\t\tif (req->handle->search_state &&\n\t\t    req->request_type != TYPE_PTR) {\n\t\t\t/* if we have a list of domains to search in,\n\t\t\t * try the next one */\n\t\t\tif (!search_try_next(req->handle)) {\n\t\t\t\t/* a new request was issued so this\n\t\t\t\t * request is finished and */\n\t\t\t\t/* the user callback will be made when\n\t\t\t\t * that request (or a */\n\t\t\t\t/* child of it) finishes. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* all else failed. Pass the failure up */\n\t\treply_schedule_callback(req, ttl, error, NULL);\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t} else {\n\t\t/* all ok, tell the user */\n\t\treply_schedule_callback(req, ttl, 0, reply);\n\t\tif (req->handle == req->ns->probe_request)\n\t\t\treq->ns->probe_request = NULL; /* Avoid double-free */\n\t\tnameserver_up(req->ns);\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "nfsd_break_deleg_cb(struct file_lock *fl)\n{\n\tbool ret = false;\n\tstruct nfs4_file *fp = (struct nfs4_file *)fl->fl_owner;\n\tstruct nfs4_delegation *dp;\n\n\tif (!fp) {\n\t\tWARN(1, \"(%p)->fl_owner NULL\\n\", fl);\n\t\treturn ret;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tWARN(1, \"duplicate break on %p\\n\", fp);\n\t\treturn ret;\n\t}\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a delegation isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_had_conflict = true;\n\t/*\n\t * If there are no delegations on the list, then return true\n\t * so that the lease code will go ahead and delete it.\n\t */\n\tif (list_empty(&fp->fi_delegations))\n\t\tret = true;\n\telse\n\t\tlist_for_each_entry(dp, &fp->fi_delegations, dl_perfile)\n\t\t\tnfsd_break_one_deleg(dp);\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-404"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static xmlDocPtr dom_document_parser(zval *id, int mode, char *source, int source_len, int options TSRMLS_DC) /* {{{ */\n{\n    xmlDocPtr ret;\n    xmlParserCtxtPtr ctxt = NULL;\n\tdom_doc_propsptr doc_props;\n\tdom_object *intern;\n\tphp_libxml_ref_obj *document = NULL;\n\tint validate, recover, resolve_externals, keep_blanks, substitute_ent;\n\tint resolved_path_len;\n\tint old_error_reporting = 0;\n\tchar *directory=NULL, resolved_path[MAXPATHLEN];\n\n\tif (id != NULL) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tdocument = intern->document;\n\t}\n\n\tdoc_props = dom_get_doc_props(document);\n\tvalidate = doc_props->validateonparse;\n\tresolve_externals = doc_props->resolveexternals;\n\tkeep_blanks = doc_props->preservewhitespace;\n\tsubstitute_ent = doc_props->substituteentities;\n\trecover = doc_props->recover;\n\n\tif (document == NULL) {\n\t\tefree(doc_props);\n\t}\n\n        xmlInitParser();\n \n        if (mode == DOM_LOAD_FILE) {\n                char *file_dest = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);\n                if (file_dest) {\n                        ctxt = xmlCreateFileParserCtxt(file_dest);\n\t\tctxt = xmlCreateMemoryParserCtxt(source, source_len);\n\t}\n\n\tif (ctxt == NULL) {\n\t\treturn(NULL);\n\t}\n\n\t/* If loading from memory, we need to set the base directory for the document */\n\tif (mode != DOM_LOAD_FILE) {\n#if HAVE_GETCWD\n\t\tdirectory = VCWD_GETCWD(resolved_path, MAXPATHLEN);\n#elif HAVE_GETWD\n\t\tdirectory = VCWD_GETWD(resolved_path);\n#endif\n\t\tif (directory) {\n\t\t\tif(ctxt->directory != NULL) {\n\t\t\t\txmlFree((char *) ctxt->directory);\n\t\t\t}\n\t\t\tresolved_path_len = strlen(resolved_path);\n\t\t\tif (resolved_path[resolved_path_len - 1] != DEFAULT_SLASH) {\n\t\t\t\tresolved_path[resolved_path_len] = DEFAULT_SLASH;\n\t\t\t\tresolved_path[++resolved_path_len] = '\\0';\n\t\t\t}\n\t\t\tctxt->directory = (char *) xmlCanonicPath((const xmlChar *) resolved_path);\n\t\t}\n\t}\n\n\tctxt->vctxt.error = php_libxml_ctx_error;\n\tctxt->vctxt.warning = php_libxml_ctx_warning;\n\n\tif (ctxt->sax != NULL) {\n\t\tctxt->sax->error = php_libxml_ctx_error;\n\t\tctxt->sax->warning = php_libxml_ctx_warning;\n\t}\n\n\tif (validate && ! (options & XML_PARSE_DTDVALID)) {\n\t\toptions |= XML_PARSE_DTDVALID;\n\t}\n\tif (resolve_externals && ! (options & XML_PARSE_DTDATTR)) {\n\t\toptions |= XML_PARSE_DTDATTR;\n\t}\n\tif (substitute_ent && ! (options & XML_PARSE_NOENT)) {\n\t\toptions |= XML_PARSE_NOENT;\n\t}\n\tif (keep_blanks == 0 && ! (options & XML_PARSE_NOBLANKS)) {\n\t\toptions |= XML_PARSE_NOBLANKS;\n\t}\n\n\txmlCtxtUseOptions(ctxt, options);\n\n\tctxt->recovery = recover;\n\tif (recover) {\n\t\told_error_reporting = EG(error_reporting);\n\t\tEG(error_reporting) = old_error_reporting | E_WARNING;\n\t}\n\n\txmlParseDocument(ctxt);\n\n\tif (ctxt->wellFormed || recover) {\n\t\tret = ctxt->myDoc;\n\t\tif (ctxt->recovery) {\n\t\t\tEG(error_reporting) = old_error_reporting;\n\t\t}\n\t\t/* If loading from memory, set the base reference uri for the document */\n\t\tif (ret && ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\tret->URL = xmlStrdup(ctxt->directory);\n\t\t}\n\t} else {\n\t\tret = NULL;\n\t\txmlFreeDoc(ctxt->myDoc);\n\t\tctxt->myDoc = NULL;\n\t}\n\n\txmlFreeParserCtxt(ctxt);\n\n\treturn(ret);\n}\n/* }}} */\n\n/* {{{ static void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) */\nstatic void dom_parse_document(INTERNAL_FUNCTION_PARAMETERS, int mode) {\n\tzval *id;\n\txmlDoc *docp = NULL, *newdoc;\n\tdom_doc_propsptr doc_prop;\n\tdom_object *intern;\n\tchar *source;\n\tint source_len, refcount, ret;\n\tlong options = 0;\n\n\tid = getThis();\n\tif (id != NULL && ! instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {\n\t\tid = NULL;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &source, &source_len, &options) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!source_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string supplied as input\");\n\t\tRETURN_FALSE;\n\t}\n\n\tnewdoc = dom_document_parser(id, mode, source, source_len, options TSRMLS_CC);\n\n\tif (!newdoc)\n\t\tRETURN_FALSE;\n\n\tif (id != NULL) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tif (intern != NULL) {\n\t\t\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\t\t\tdoc_prop = NULL;\n\t\t\tif (docp != NULL) {\n\t\t\t\tphp_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);\n\t\t\t\tdoc_prop = intern->document->doc_props;\n\t\t\t\tintern->document->doc_props = NULL;\n\t\t\t\trefcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);\n\t\t\t\tif (refcount != 0) {\n\t\t\t\t\tdocp->_private = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tintern->document = NULL;\n\t\t\tif (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tintern->document->doc_props = doc_prop;\n\t\t}\n\n\t\tphp_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);\n\n\t\tRETURN_TRUE;\n\t} else {\n\t\tDOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);\n\t}\n}\n/* }}} end dom_parser_document */\n\n/* {{{ proto DOMNode dom_document_load(string source [, int options]);\nURL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-load\nSince: DOM Level 3\n*/\nPHP_METHOD(domdocument, load)\n{\n\tdom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);\n}\n/* }}} end dom_document_load */\n\n/* {{{ proto DOMNode dom_document_loadxml(string source [, int options]);\nURL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-loadXML\nSince: DOM Level 3\n*/\nPHP_METHOD(domdocument, loadXML)\n{\n\tdom_parse_document(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);\n}\n/* }}} end dom_document_loadxml */\n\n/* {{{ proto int dom_document_save(string file);\nConvenience method to save to file\n*/\nPHP_FUNCTION(dom_document_save)\n{\n\tzval *id;\n\txmlDoc *docp;\n\tint file_len = 0, bytes, format, saveempty = 0;\n\tdom_object *intern;\n\tdom_doc_propsptr doc_props;\n\tchar *file;\n\tlong options = 0;\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Os|l\", &id, dom_document_class_entry, &file, &file_len, &options) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (file_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid Filename\");\n\t\tRETURN_FALSE;\n\t}\n\n\tDOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n\n\t/* encoding handled by property on doc */\n\n\tdoc_props = dom_get_doc_props(intern->document);\n\tformat = doc_props->formatoutput;\n\tif (options & LIBXML_SAVE_NOEMPTYTAG) {\n\t\tsaveempty = xmlSaveNoEmptyTags;\n\t\txmlSaveNoEmptyTags = 1;\n\t}\n\tbytes = xmlSaveFormatFileEnc(file, docp, NULL, format);\n\tif (options & LIBXML_SAVE_NOEMPTYTAG) {\n\t\txmlSaveNoEmptyTags = saveempty;\n\t}\n\tif (bytes == -1) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(bytes);\n}\n/* }}} end dom_document_save */\n\n/* {{{ proto string dom_document_savexml([node n]);\nURL: http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#LS-DocumentLS-saveXML\nSince: DOM Level 3\n*/\nPHP_FUNCTION(dom_document_savexml)\n{\n\tzval *id, *nodep = NULL;\n\txmlDoc *docp;\n\txmlNode *node;\n\txmlBufferPtr buf;\n\txmlChar *mem;\n\tdom_object *intern, *nodeobj;\n\tdom_doc_propsptr doc_props;\n\tint size, format, saveempty = 0;\n\tlong options = 0;\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O|O!l\", &id, dom_document_class_entry, &nodep, dom_node_class_entry, &options) == FAILURE) {\n\t\treturn;\n\t}\n\n\tDOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n\n\tdoc_props = dom_get_doc_props(intern->document);\n\tformat = doc_props->formatoutput;\n\n\tif (nodep != NULL) {\n\t\t/* Dump contents of Node */\n\t\tDOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);\n\t\tif (node->doc != docp) {\n\t\t\tphp_dom_throw_error(WRONG_DOCUMENT_ERR, dom_get_strict_error(intern->document) TSRMLS_CC);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tbuf = xmlBufferCreate();\n\t\tif (!buf) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not fetch buffer\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (options & LIBXML_SAVE_NOEMPTYTAG) {\n\t\t\tsaveempty = xmlSaveNoEmptyTags;\n\t\t\txmlSaveNoEmptyTags = 1;\n\t\t}\n\t\txmlNodeDump(buf, docp, node, 0, format);\n\t\tif (options & LIBXML_SAVE_NOEMPTYTAG) {\n\t\t\txmlSaveNoEmptyTags = saveempty;\n\t\t}\n\t\tmem = (xmlChar*) xmlBufferContent(buf);\n\t\tif (!mem) {\n\t\t\txmlBufferFree(buf);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tRETVAL_STRING(mem, 1);\n\t\txmlBufferFree(buf);\n\t} else {\n\t\tif (options & LIBXML_SAVE_NOEMPTYTAG) {\n\t\t\tsaveempty = xmlSaveNoEmptyTags;\n\t\t\txmlSaveNoEmptyTags = 1;\n\t\t}\n\t\t/* Encoding is handled from the encoding property set on the document */\n\t\txmlDocDumpFormatMemory(docp, &mem, &size, format);\n\t\tif (options & LIBXML_SAVE_NOEMPTYTAG) {\n\t\t\txmlSaveNoEmptyTags = saveempty;\n\t\t}\n\t\tif (!size) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tRETVAL_STRINGL(mem, size, 1);\n\t\txmlFree(mem);\n\t}\n}\n/* }}} end dom_document_savexml */\n\nstatic xmlNodePtr php_dom_free_xinclude_node(xmlNodePtr cur TSRMLS_DC) /* {{{ */\n{\n\txmlNodePtr xincnode;\n\n\txincnode = cur;\n\tcur = cur->next;\n\txmlUnlinkNode(xincnode);\n\tphp_libxml_node_free_resource(xincnode TSRMLS_CC);\n\n\treturn cur;\n}\n/* }}} */\n\nstatic void php_dom_remove_xinclude_nodes(xmlNodePtr cur TSRMLS_DC) /* {{{ */\n{\n\twhile(cur) {\n\t\tif (cur->type == XML_XINCLUDE_START) {\n\t\t\tcur = php_dom_free_xinclude_node(cur TSRMLS_CC);\n\n\t\t\t/* XML_XINCLUDE_END node will be a sibling of XML_XINCLUDE_START */\n\t\t\twhile(cur && cur->type != XML_XINCLUDE_END) {\n\t\t\t\t/* remove xinclude processing nodes from recursive xincludes */\n\t\t\t\tif (cur->type == XML_ELEMENT_NODE) {\n\t\t\t\t\t   php_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);\n\t\t\t\t}\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (cur && cur->type == XML_XINCLUDE_END) {\n\t\t\t\tcur = php_dom_free_xinclude_node(cur TSRMLS_CC);\n\t\t\t}\n\t\t} else {\n\t\t\tif (cur->type == XML_ELEMENT_NODE) {\n\t\t\t\tphp_dom_remove_xinclude_nodes(cur->children TSRMLS_CC);\n\t\t\t}\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto int dom_document_xinclude([int options])\n   Substitutues xincludes in a DomDocument */\nPHP_FUNCTION(dom_document_xinclude)\n{\n\tzval *id;\n\txmlDoc *docp;\n\txmlNodePtr root;\n\tlong flags = 0; \n\tint err;\n\tdom_object *intern;\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O|l\", &id, dom_document_class_entry, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tDOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n\n\terr = xmlXIncludeProcessFlags(docp, flags);\n\n\t/* XML_XINCLUDE_START and XML_XINCLUDE_END nodes need to be removed as these\n\tare added via xmlXIncludeProcess to mark beginning and ending of xincluded document \n\tbut are not wanted in resulting document - must be done even if err as it could fail after\n\thaving processed some xincludes */\n\troot = (xmlNodePtr) docp->children;\n\twhile(root && root->type != XML_ELEMENT_NODE && root->type != XML_XINCLUDE_START) {\n\t\troot = root->next;\n\t}\n\tif (root) {\n\t\tphp_dom_remove_xinclude_nodes(root TSRMLS_CC);\n\t}\n\n\tif (err) {\n\t\tRETVAL_LONG(err);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n    \n}\n/* }}} */\n\n/* {{{ proto boolean dom_document_validate();\nSince: DOM extended\n*/\nPHP_FUNCTION(dom_document_validate)\n{\n\tzval *id;\n\txmlDoc *docp;\n\tdom_object *intern;\n\txmlValidCtxt *cvp;\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\", &id, dom_document_class_entry) == FAILURE) {\n\t\treturn;\n\t}\n\n\tDOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n\n\tcvp = xmlNewValidCtxt();\n\t\n\tcvp->userData = NULL;\n\tcvp->error    = (xmlValidityErrorFunc) php_libxml_error_handler;\n\tcvp->warning  = (xmlValidityErrorFunc) php_libxml_error_handler;\n\t\n\tif (xmlValidateDocument(cvp, docp)) {\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\t\n\txmlFreeValidCtxt(cvp);\n\t\n}\n/* }}} */\n\n#if defined(LIBXML_SCHEMAS_ENABLED)\nstatic void _dom_document_schema_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tzval *id;\n\txmlDoc *docp;\n\tdom_object *intern;\n\tchar *source = NULL, *valid_file = NULL;\n\tint source_len = 0;\n\txmlSchemaParserCtxtPtr  parser;\n\txmlSchemaPtr            sptr;\n\txmlSchemaValidCtxtPtr   vptr;\n\tint                     is_valid;\n\tchar resolved_path[MAXPATHLEN + 1];\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Op\", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (source_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid Schema source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tDOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n\n\tswitch (type) {\n\tcase DOM_LOAD_FILE:\n\t\tvalid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);\n\t\tif (!valid_file) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid Schema file source\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tparser = xmlSchemaNewParserCtxt(valid_file);\n\t\tbreak;\n\tcase DOM_LOAD_STRING:\n\t\tparser = xmlSchemaNewMemParserCtxt(source, source_len);\n\t\t/* If loading from memory, we need to set the base directory for the document \n\t\t   but it is not apparent how to do that for schema's */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\txmlSchemaSetParserErrors(parser,\n\t\t(xmlSchemaValidityErrorFunc) php_libxml_error_handler,\n\t\t(xmlSchemaValidityWarningFunc) php_libxml_error_handler,\n\t\tparser);\n\tsptr = xmlSchemaParse(parser);\n\txmlSchemaFreeParserCtxt(parser);\n\tif (!sptr) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid Schema\");\n\t\tRETURN_FALSE;\n\t}\n\n\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\n\tvptr = xmlSchemaNewValidCtxt(sptr);\n\tif (!vptr) {\n\t\txmlSchemaFree(sptr);\n\t\tphp_error(E_ERROR, \"Invalid Schema Validation Context\");\n\t\tRETURN_FALSE;\n\t}\n\n\txmlSchemaSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);\n\tis_valid = xmlSchemaValidateDoc(vptr, docp);\n\txmlSchemaFree(sptr);\n\txmlSchemaFreeValidCtxt(vptr);\n\n\tif (is_valid == 0) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto boolean dom_document_schema_validate_file(string filename); */\nPHP_FUNCTION(dom_document_schema_validate_file)\n{\n\t_dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);\n}\n/* }}} end dom_document_schema_validate_file */\n\n/* {{{ proto boolean dom_document_schema_validate(string source); */\nPHP_FUNCTION(dom_document_schema_validate_xml)\n{\n\t_dom_document_schema_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);\n}\n/* }}} end dom_document_schema_validate */\n\nstatic void _dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tzval *id;\n\txmlDoc *docp;\n\tdom_object *intern;\n\tchar *source = NULL, *valid_file = NULL;\n\tint source_len = 0;\n\txmlRelaxNGParserCtxtPtr parser;\n\txmlRelaxNGPtr           sptr;\n\txmlRelaxNGValidCtxtPtr  vptr;\n\tint                     is_valid;\n\tchar resolved_path[MAXPATHLEN + 1];\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Op\", &id, dom_document_class_entry, &source, &source_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (source_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid Schema source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tDOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n\n\tswitch (type) {\n\tcase DOM_LOAD_FILE:\n\t\tvalid_file = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);\n\t\tif (!valid_file) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid RelaxNG file source\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tparser = xmlRelaxNGNewParserCtxt(valid_file);\n\t\tbreak;\n\tcase DOM_LOAD_STRING:\n\t\tparser = xmlRelaxNGNewMemParserCtxt(source, source_len);\n\t\t/* If loading from memory, we need to set the base directory for the document \n\t\t   but it is not apparent how to do that for schema's */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\txmlRelaxNGSetParserErrors(parser,\n\t\t(xmlRelaxNGValidityErrorFunc) php_libxml_error_handler,\n\t\t(xmlRelaxNGValidityWarningFunc) php_libxml_error_handler,\n\t\tparser);\n\tsptr = xmlRelaxNGParse(parser);\n\txmlRelaxNGFreeParserCtxt(parser);\n\tif (!sptr) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid RelaxNG\");\n\t\tRETURN_FALSE;\n\t}\n\n\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\n\tvptr = xmlRelaxNGNewValidCtxt(sptr);\n\tif (!vptr) {\n\t\txmlRelaxNGFree(sptr);\n\t\tphp_error(E_ERROR, \"Invalid RelaxNG Validation Context\");\n\t\tRETURN_FALSE;\n\t}\n\n\txmlRelaxNGSetValidErrors(vptr, php_libxml_error_handler, php_libxml_error_handler, vptr);\n\tis_valid = xmlRelaxNGValidateDoc(vptr, docp);\n\txmlRelaxNGFree(sptr);\n\txmlRelaxNGFreeValidCtxt(vptr);\n\n\tif (is_valid == 0) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto boolean dom_document_relaxNG_validate_file(string filename); */\nPHP_FUNCTION(dom_document_relaxNG_validate_file)\n{\n\t_dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_FILE);\n}\n/* }}} end dom_document_relaxNG_validate_file */\n\n/* {{{ proto boolean dom_document_relaxNG_validate_xml(string source); */\nPHP_FUNCTION(dom_document_relaxNG_validate_xml)\n{\n\t_dom_document_relaxNG_validate(INTERNAL_FUNCTION_PARAM_PASSTHRU, DOM_LOAD_STRING);\n}\n/* }}} end dom_document_relaxNG_validate_xml */\n\n#endif\n\n#if defined(LIBXML_HTML_ENABLED)\n\nstatic void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */\n{\n\tzval *id;\n\txmlDoc *docp = NULL, *newdoc;\n\tdom_object *intern;\n\tdom_doc_propsptr doc_prop;\n\tchar *source;\n\tint source_len, refcount, ret;\n\tlong options = 0;\n\thtmlParserCtxtPtr ctxt;\n\t\n\tid = getThis();\n\n        \n        id = getThis();\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &source, &source_len, &options) == FAILURE) {\n                return;\n        }\n\t}\n\n\tif (mode == DOM_LOAD_FILE) {\n\t\tctxt = htmlCreateFileParserCtxt(source, NULL);\n\t} else {\n\t\tsource_len = xmlStrlen(source);\n\t\tctxt = htmlCreateMemoryParserCtxt(source, source_len);\n\t}\n\n\tif (!ctxt) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (options) {\n\t\thtmlCtxtUseOptions(ctxt, options);\n\t}\n\n\tctxt->vctxt.error = php_libxml_ctx_error;\n\tctxt->vctxt.warning = php_libxml_ctx_warning;\n\tif (ctxt->sax != NULL) {\n\t\tctxt->sax->error = php_libxml_ctx_error;\n\t\tctxt->sax->warning = php_libxml_ctx_warning;\n\t}\n\thtmlParseDocument(ctxt);\n\tnewdoc = ctxt->myDoc;\n\thtmlFreeParserCtxt(ctxt);\n\t\n\tif (!newdoc)\n\t\tRETURN_FALSE;\n\n\tif (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tif (intern != NULL) {\n\t\t\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\t\t\tdoc_prop = NULL;\n\t\t\tif (docp != NULL) {\n\t\t\t\tphp_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);\n\t\t\t\tdoc_prop = intern->document->doc_props;\n\t\t\t\tintern->document->doc_props = NULL;\n\t\t\t\trefcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);\n\t\t\t\tif (refcount != 0) {\n\t\t\t\t\tdocp->_private = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tintern->document = NULL;\n\t\t\tif (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tintern->document->doc_props = doc_prop;\n\t\t}\n\n\t\tphp_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);\n\n\t\tRETURN_TRUE;\n\t} else {\n\t\tDOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);\n\t}\n}\n/* }}} */"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\t__be32 daddr;\n \t__be32 saddr;\n \tu8  tos;\n \tint err;\n \n \terr = -EMSGSIZE;\n \tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tstatic int complained;\n\t\t\tif (!complained++)\n\t\t\t\tprintk(KERN_INFO \"%s forgot to set AF_INET in \"\n\t\t\t\t\t\t \"raw sendmsg. Fix it!\\n\",\n\t\t\t\t\t\t current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n \tsaddr = ipc.addr;\n \tipc.addr = daddr;\n \n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n \n \tif (ipc.opt) {\n \t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n \t\t */\n \t\tif (inet->hdrincl)\n \t\t\tgoto done;\n\t\tif (ipc.opt->srr) {\n \t\t\tif (!daddr)\n \t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->faddr;\n \t\t}\n \t}\n \ttos = RT_CONN_FLAGS(sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t}\n\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t\t   FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0);\n\n\t\tif (!inet->hdrincl) {\n\t\t\terr = raw_probe_proto_opt(&fl4, msg);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_flow(sock_net(sk), &fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (inet->hdrincl)\n\t\terr = raw_send_hdrinc(sk, msg->msg_iov, len,\n\t\t\t\t\t&rt, msg->msg_flags);\n\n\t else {\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = rt->rt_dst;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, len, 0,\n\t\t\t\t\t&ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SplashPath *SplashFTFont::getGlyphPath(int c) {\n  static FT_Outline_Funcs outlineFuncs = {\n#if FREETYPE_MINOR <= 1\n    (int (*)(FT_Vector *, void *))&glyphPathMoveTo,\n    (int (*)(FT_Vector *, void *))&glyphPathLineTo,\n    (int (*)(FT_Vector *, FT_Vector *, void *))&glyphPathConicTo,\n    (int (*)(FT_Vector *, FT_Vector *, FT_Vector *, void *))&glyphPathCubicTo,\n#else\n    &glyphPathMoveTo,\n    &glyphPathLineTo,\n    &glyphPathConicTo,\n    &glyphPathCubicTo,\n#endif\n    0, 0\n  };\n  SplashFTFontFile *ff;\n  SplashFTFontPath path;\n  FT_GlyphSlot slot;\n  FT_UInt gid;\n  FT_Glyph glyph;\n\n  ff = (SplashFTFontFile *)fontFile;\n  ff->face->size = sizeObj;\n  FT_Set_Transform(ff->face, &textMatrix, NULL);\n  slot = ff->face->glyph;\n  if (ff->codeToGID && c < ff->codeToGIDLen) {\n    gid = ff->codeToGID[c];\n  } else {\n    gid = (FT_UInt)c;\n  }\n  if (ff->trueType && gid == 0) {\n    return NULL;\n  }\n  if (FT_Load_Glyph(ff->face, gid, FT_LOAD_NO_BITMAP)) {\n    return NULL;\n  }\n  if (FT_Get_Glyph(slot, &glyph)) {\n    return NULL;\n  }\n  path.path = new SplashPath();\n  path.textScale = textScale;\n  path.needClose = gFalse;\n  FT_Outline_Decompose(&((FT_OutlineGlyph)glyph)->outline,\n\t\t       &outlineFuncs, &path);\n  if (path.needClose) {\n    path.path->close();\n  }\n  FT_Done_Glyph(glyph);\n  return path.path;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size,\n\t\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint copied = 0;\n\tint target;\n\tint err = 0;\n\tlong timeo;\n\n\terr = -EOPNOTSUPP;\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n\tmsg->msg_namelen = 0;\n \t/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n\t */\n\terr = -EAGAIN;\n\tif (sk->sk_state == CAIF_CONNECTING)\n\t\tgoto out;\n\n\tcaif_read_lock(sk);\n\ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n\ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n\n\tdo {\n\t\tint chunk;\n\t\tstruct sk_buff *skb;\n\n\t\tlock_sock(sk);\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tcaif_check_flow_release(sk);\n\n\t\tif (skb == NULL) {\n\t\t\tif (copied >= target)\n\t\t\t\tgoto unlock;\n\t\t\t/*\n\t\t\t *\tPOSIX 1003.1g mandates this order.\n\t\t\t */\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t\terr = -ECONNRESET;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tgoto unlock;\n\n\t\t\terr = -EPIPE;\n\t\t\tif (sk->sk_state != CAIF_CONNECTED)\n\t\t\t\tgoto unlock;\n\t\t\tif (sock_flag(sk, SOCK_DEAD))\n\t\t\t\tgoto unlock;\n\n\t\t\trelease_sock(sk);\n\n\t\t\terr = -EAGAIN;\n\t\t\tif (!timeo)\n\t\t\t\tbreak;\n\n\t\t\tcaif_read_unlock(sk);\n\n\t\t\ttimeo = caif_stream_data_wait(sk, timeo);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcaif_read_lock(sk);\n\t\t\tcontinue;\nunlock:\n\t\t\trelease_sock(sk);\n\t\t\tbreak;\n\t\t}\n\t\trelease_sock(sk);\n\t\tchunk = min_t(unsigned int, skb->len, size);\n\t\tif (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\t/* Mark read part of skb as used */\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tskb_pull(skb, chunk);\n\n\t\t\t/* put the skb back if we didn't use it up. */\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * It is questionable, see note in unix_dgram_recvmsg.\n\t\t\t */\n\t\t\t/* put message back and return */\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\tcaif_read_unlock(sk);\n\nout:\n\treturn copied ? : err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool GLES2DecoderImpl::ResizeOffscreenFrameBuffer(const gfx::Size& size) {\n  bool is_offscreen = !!offscreen_target_frame_buffer_.get();\n  if (!is_offscreen) {\n    LOG(ERROR) << \"GLES2DecoderImpl::ResizeOffscreenFrameBuffer called \"\n               << \" with an onscreen framebuffer.\";\n    return false;\n  }\n\n  if (offscreen_size_ == size)\n    return true;\n\n  offscreen_size_ = size;\n  int w = offscreen_size_.width();\n  int h = offscreen_size_.height();\n  if (w < 0 || h < 0 || h >= (INT_MAX / 4) / (w ? w : 1)) {\n    LOG(ERROR) << \"GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed \"\n               << \"to allocate storage due to excessive dimensions.\";\n    return false;\n  }\n\n  DCHECK(offscreen_target_color_format_);\n  if (IsOffscreenBufferMultisampled()) {\n    if (!offscreen_target_color_render_buffer_->AllocateStorage(\n        offscreen_size_, offscreen_target_color_format_,\n        offscreen_target_samples_)) {\n      LOG(ERROR) << \"GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed \"\n                 << \"to allocate storage for offscreen target color buffer.\";\n      return false;\n    }\n  } else {\n    if (!offscreen_target_color_texture_->AllocateStorage(\n        offscreen_size_, offscreen_target_color_format_)) {\n      LOG(ERROR) << \"GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed \"\n                 << \"to allocate storage for offscreen target color texture.\";\n      return false;\n    }\n  }\n  if (offscreen_target_depth_format_ &&\n      !offscreen_target_depth_render_buffer_->AllocateStorage(\n      offscreen_size_, offscreen_target_depth_format_,\n      offscreen_target_samples_)) {\n    LOG(ERROR) << \"GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed \"\n               << \"to allocate storage for offscreen target depth buffer.\";\n    return false;\n  }\n  if (offscreen_target_stencil_format_ &&\n      !offscreen_target_stencil_render_buffer_->AllocateStorage(\n      offscreen_size_, offscreen_target_stencil_format_,\n      offscreen_target_samples_)) {\n    LOG(ERROR) << \"GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed \"\n               << \"to allocate storage for offscreen target stencil buffer.\";\n    return false;\n  }\n  TRACE_BACKBUFFER_MEMORY_TOTAL(this);\n\n  if (IsOffscreenBufferMultisampled()) {\n    offscreen_target_frame_buffer_->AttachRenderBuffer(\n        GL_COLOR_ATTACHMENT0,\n        offscreen_target_color_render_buffer_.get());\n  } else {\n    offscreen_target_frame_buffer_->AttachRenderTexture(\n        offscreen_target_color_texture_.get());\n  }\n  if (offscreen_target_depth_format_) {\n    offscreen_target_frame_buffer_->AttachRenderBuffer(\n        GL_DEPTH_ATTACHMENT,\n        offscreen_target_depth_render_buffer_.get());\n  }\n  const bool packed_depth_stencil =\n      offscreen_target_depth_format_ == GL_DEPTH24_STENCIL8;\n  if (packed_depth_stencil) {\n    offscreen_target_frame_buffer_->AttachRenderBuffer(\n        GL_STENCIL_ATTACHMENT,\n        offscreen_target_depth_render_buffer_.get());\n  } else if (offscreen_target_stencil_format_) {\n    offscreen_target_frame_buffer_->AttachRenderBuffer(\n        GL_STENCIL_ATTACHMENT,\n        offscreen_target_stencil_render_buffer_.get());\n  }\n\n  if (offscreen_target_frame_buffer_->CheckStatus() !=\n      GL_FRAMEBUFFER_COMPLETE) {\n      LOG(ERROR) << \"GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed \"\n                 << \"because offscreen FBO was incomplete.\";\n    return false;\n  }\n\n  {\n    ScopedFrameBufferBinder binder(this, offscreen_target_frame_buffer_->id());\n    glClearColor(0, 0, 0, (GLES2Util::GetChannelsForFormat(\n        offscreen_target_color_format_) & 0x0008) != 0 ? 0 : 1);\n    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);\n    glClearStencil(0);\n    glStencilMaskSeparate(GL_FRONT, -1);\n    glStencilMaskSeparate(GL_BACK, -1);\n    glClearDepth(0);\n    glDepthMask(GL_TRUE);\n    glDisable(GL_SCISSOR_TEST);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n    RestoreClearState();\n  }\n\n  if (offscreen_resolved_frame_buffer_.get())\n    offscreen_resolved_frame_buffer_->Destroy();\n  if (offscreen_resolved_color_texture_.get())\n    offscreen_resolved_color_texture_->Destroy();\n  offscreen_resolved_color_texture_.reset();\n  offscreen_resolved_frame_buffer_.reset();\n\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual InputMethodDescriptor previous_input_method() const {\n     return previous_input_method_;\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void setupexport(CLIENT* client) {\n\tint i;\n\toff_t laststartoff = 0, lastsize = 0;\n\tint multifile = (client->server->flags & F_MULTIFILE);\n\n\tclient->export = g_array_new(TRUE, TRUE, sizeof(FILE_INFO));\n\n\t/* If multi-file, open as many files as we can.\n\t * If not, open exactly one file.\n\t * Calculate file sizes as we go to get total size. */\n\tfor(i=0; ; i++) {\n\t\tFILE_INFO fi;\n\t\tgchar *tmpname;\n\t\tgchar* error_string;\n\t\tmode_t mode = (client->server->flags & F_READONLY) ? O_RDONLY : O_RDWR;\n\n\t\tif(multifile) {\n\t\t\ttmpname=g_strdup_printf(\"%s.%d\", client->exportname, i);\n\t\t} else {\n\t\t\ttmpname=g_strdup(client->exportname);\n\t\t}\n\t\tDEBUG2( \"Opening %s\\n\", tmpname );\n\t\tfi.fhandle = open(tmpname, mode);\n\t\tif(fi.fhandle == -1 && mode == O_RDWR) {\n\t\t\t/* Try again because maybe media was read-only */\n\t\t\tfi.fhandle = open(tmpname, O_RDONLY);\n\t\t\tif(fi.fhandle != -1) {\n\t\t\t\t/* Opening the base file in copyonwrite mode is\n\t\t\t\t * okay */\n\t\t\t\tif(!(client->server->flags & F_COPYONWRITE)) {\n\t\t\t\t\tclient->server->flags |= F_AUTOREADONLY;\n\t\t\t\t\tclient->server->flags |= F_READONLY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(fi.fhandle == -1) {\n\t\t\tif(multifile && i>0)\n\t\t\t\tbreak;\n\t\t\terror_string=g_strdup_printf(\n\t\t\t\t\"Could not open exported file %s: %%m\",\n\t\t\t\ttmpname);\n\t\t\terr(error_string);\n\t\t}\n\t\tfi.startoff = laststartoff + lastsize;\n\t\tg_array_append_val(client->export, fi);\n\t\tg_free(tmpname);\n\n\t\t/* Starting offset and size of this file will be used to\n\t\t * calculate starting offset of next file */\n\t\tlaststartoff = fi.startoff;\n\t\tlastsize = size_autodetect(fi.fhandle);\n\n\t\tif(!multifile)\n\t\t\tbreak;\n\t}\n\n\t/* Set export size to total calculated size */\n\tclient->exportsize = laststartoff + lastsize;\n\n\t/* Export size may be overridden */\n\tif(client->server->expected_size) {\n\t\t/* desired size must be <= total calculated size */\n\t\tif(client->server->expected_size > client->exportsize) {\n\t\t\terr(\"Size of exported file is too big\\n\");\n\t\t}\n\n\t\tclient->exportsize = client->server->expected_size;\n\t}\n\n\tmsg3(LOG_INFO, \"Size of exported file/device is %llu\", (unsigned long long)client->exportsize);\n\tif(multifile) {\n\t\tmsg3(LOG_INFO, \"Total number of files: %d\", i);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int raw_send_hdrinc(struct sock *sk, struct flowi4 *fl4,\n\t\t\t   void *from, size_t length,\n\t\t\t   struct rtable **rtp,\n\t\t\t   unsigned int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb;\n\tunsigned int iphlen;\n\tint err;\n\tstruct rtable *rt = *rtp;\n\tint hlen, tlen;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,\n\t\t\t       rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\thlen = LL_RESERVED_SPACE(rt->dst.dev);\n\ttlen = rt->dst.dev->needed_tailroom;\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\tskb_dst_set(skb, &rt->dst);\n\t*rtp = NULL;\n\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tskb_put(skb, length);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb->transport_header = skb->network_header;\n\terr = -EFAULT;\n\tif (memcpy_fromiovecend((void *)iph, from, 0, length))\n\t\tgoto error_free;\n\n\tiphlen = iph->ihl * 4;\n\n\t/*\n\t * We don't want to modify the ip header, but we do need to\n\t * be sure that it won't cause problems later along the network\n\t * stack.  Specifically we want to make sure that iph->ihl is a\n\t * sane value.  If ihl points beyond the length of the buffer passed\n\t * in, reject the frame as invalid\n\t */\n\terr = -EINVAL;\n\tif (iphlen > length)\n\t\tgoto error_free;\n\n\tif (iphlen >= sizeof(*iph)) {\n\t\tif (!iph->saddr)\n\t\t\tiph->saddr = fl4->saddr;\n\t\tiph->check   = 0;\n\t\tiph->tot_len = htons(length);\n\t\tif (!iph->id)\n\t\t\tip_select_ident(skb, &rt->dst, NULL);\n\n\t\tiph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\n\t}\n\tif (iph->protocol == IPPROTO_ICMP)\n\t\ticmp_out_count(net, ((struct icmphdr *)\n\t\t\tskb_transport_header(skb))->type);\n\n\terr = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT, skb, NULL,\n\t\t      rt->dst.dev, dst_output);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\tif (err)\n\t\tgoto error;\nout:\n\treturn 0;\n\nerror_free:\n\tkfree_skb(skb);\nerror:\n\tIP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);\n\tif (err == -ENOBUFS && !inet->recverr)\n\t\terr = 0;\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tint fault, sig, code;\n\n\tif (notify_page_fault(regs, fsr))\n\t\treturn 0;\n\n\ttsk = current;\n\tmm  = tsk->mm;\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\t/*\n\t * As per x86, we may deadlock here.  However, since the kernel only\n\t * validly references user space from well defined areas of the code,\n\t * we can bug out early if this is from code which shouldn't.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->ARM_pc))\n\t\t\tgoto no_context;\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in\n\t\t * which case, we'll have missed the might_sleep() from\n\t\t * down_read()\n\t\t */\n\t\tmight_sleep();\n#ifdef CONFIG_DEBUG_VM\n\t\tif (!user_mode(regs) &&\n\t\t    !search_exception_tables(regs->ARM_pc))\n\t\t\tgoto no_context;\n#endif\n\t}\n\n \tfault = __do_page_fault(mm, addr, fsr, tsk);\n \tup_read(&mm->mmap_sem);\n \n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, addr);\n \tif (fault & VM_FAULT_MAJOR)\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0, regs, addr);\n \telse if (fault & VM_FAULT_MINOR)\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0, regs, addr);\n \n \t/*\n \t * Handle the \"normal\" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR\n\t */\n\tif (likely(!(fault & (VM_FAULT_ERROR | VM_FAULT_BADMAP | VM_FAULT_BADACCESS))))\n\t\treturn 0;\n\n\tif (fault & VM_FAULT_OOM) {\n\t\t/*\n\t\t * We ran out of memory, call the OOM killer, and return to\n\t\t * userspace (which will retry the fault, or kill us if we\n\t\t * got oom-killed)\n\t\t */\n\t\tpagefault_out_of_memory();\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we are in kernel mode at this point, we\n\t * have no context to handle this fault with.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\n\tif (fault & VM_FAULT_SIGBUS) {\n\t\t/*\n\t\t * We had some memory, but were unable to\n\t\t * successfully fix up this page fault.\n\t\t */\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRERR;\n\t} else {\n\t\t/*\n\t\t * Something tried to access memory that\n\t\t * isn't in our memory map..\n\t\t */\n\t\tsig = SIGSEGV;\n\t\tcode = fault == VM_FAULT_BADACCESS ?\n\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n\t}\n\n\t__do_user_fault(tsk, addr, fsr, sig, code, regs);\n\treturn 0;\n\nno_context:\n\t__do_kernel_fault(mm, addr, fsr, regs);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual void TearDown() {\n    delete[] src_;\n    delete[] ref_;\n     libvpx_test::ClearSystemState();\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int kvm_arch_hardware_setup(void)\n{\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "GURL URLFixerUpper::FixupRelativeFile(const FilePath& base_dir,\n                                      const FilePath& text) {\n  FilePath old_cur_directory;\n  if (!base_dir.empty()) {\n    file_util::GetCurrentDirectory(&old_cur_directory);\n    file_util::SetCurrentDirectory(base_dir);\n  }\n\n  FilePath::StringType trimmed;\n   PrepareStringForFileOps(text, &trimmed);\n \n   bool is_file = true;\n   FilePath full_path;\n  if (!ValidPathForFile(trimmed, &full_path)) {\n#if defined(OS_WIN)\n    std::wstring unescaped = UTF8ToWide(UnescapeURLComponent(\n        WideToUTF8(trimmed),\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS));\n#elif defined(OS_POSIX)\n    std::string unescaped = UnescapeURLComponent(\n        trimmed,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);\n#endif\n\n    if (!ValidPathForFile(unescaped, &full_path))\n      is_file = false;\n  }\n\n  if (!base_dir.empty())\n    file_util::SetCurrentDirectory(old_cur_directory);\n\n  if (is_file) {\n    GURL file_url = net::FilePathToFileURL(full_path);\n    if (file_url.is_valid())\n      return GURL(UTF16ToUTF8(net::FormatUrl(file_url, std::string(),\n          net::kFormatUrlOmitUsernamePassword, UnescapeRule::NORMAL, NULL,\n          NULL, NULL)));\n  }\n\n#if defined(OS_WIN)\n  std::string text_utf8 = WideToUTF8(text.value());\n#elif defined(OS_POSIX)\n  std::string text_utf8 = text.value();\n#endif\n  return FixupURL(text_utf8, std::string());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n \n   if (array->items == NULL)\n   {\n    count = yr_max(64, (index + 1) * 2);\n \n     array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n         sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n   else if (index >= array->items->count)\n   {\n     count = array->items->count * 2;\n     array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n         array->items,\n         sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n {\n\tu8 obuf[] = { 0x51 };\n\tu8 ibuf[] = { 0 };\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x51 transfer failed.\");\n \n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n \n\tif (d->fe_adap[0].fe == NULL)\n \t\treturn -EIO;\n \n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n \t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n \t\tinfo(\"Attached RS2000/TS2020!\");\n \t\treturn 0;\n \t}\n\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csc_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose( l_csc_file_handle ); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n     } else {\n       /* if we are the first line after comment header, we allocate our data structures */\n       if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n           /* allocate CSC data structure matching mtx file */\n           *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n           *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csc_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n\n          /* init column idx */\n          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n            (*o_column_idx)[l_i] = *o_element_count;\n          }\n          /* init */\n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_DESC );\n          fclose( l_csc_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csc_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n           return;\n         }\n         /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n         /* add these values to row and value structure */\n         (*o_row_idx)[l_i] = l_row;\n         (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csc_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n    return;\n  }\n\n  if ( l_column_idx_id != NULL ) {\n    /* let's handle empty columns */\n    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n      if ( l_column_idx_id[l_i] == 0 ) {\n        (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_column_idx_id );\n   }\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count)\n{\n\tstruct ffs_epfile *epfile = epfiles;\n\n\tENTER();\n\n\tfor (; count; --count, ++epfile) {\n\t\tBUG_ON(mutex_is_locked(&epfile->mutex) ||\n\t\t       waitqueue_active(&epfile->wait));\n\t\tif (epfile->dentry) {\n\t\t\td_delete(epfile->dentry);\n\t\t\tdput(epfile->dentry);\n\t\t\tepfile->dentry = NULL;\n\t\t}\n\t}\n\n\tkfree(epfiles);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tbtrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n \tret = btrfs_insert_dir_item(trans, root, name, name_len,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST)\n \t\tgoto fail_dir_item;\n \telse if (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n     unsigned char *buf;\n \n     /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num > chm->num_chunks) return NULL;\n     \n     /* ensure chunk cache is available */\n     if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int PDFiumEngine::GetRenderingFlags() const {\n  int flags = FPDF_LCD_TEXT | FPDF_NO_CATCH;\n  if (render_grayscale_)\n    flags |= FPDF_GRAYSCALE;\n  if (client_->IsPrintPreview())\n    flags |= FPDF_PRINTING;\n  if (render_annots_)\n    flags |= FPDF_ANNOT;\n  return flags;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void r_pkcs7_free_attribute (RPKCS7Attribute* attribute) {\n\tif (attribute) {\n\t\tr_asn1_free_object (attribute->data);\n\t\tr_asn1_free_string (attribute->oid);\n\t\tfree (attribute);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "pango_glyph_string_new (void)\n{\n  PangoGlyphString *string = g_slice_new (PangoGlyphString);\n\n  string->num_glyphs = 0;\n  string->space = 0;\n  string->glyphs = NULL;\n  string->log_clusters = NULL;\n\n  return string;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "IW_IMPL(int) iw_stricmp(const char *s1, const char *s2)\n{\n#ifdef IW_WINDOWS\n\treturn _stricmp(s1,s2);\n#else\n\treturn strcasecmp(s1,s2);\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-682"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static MagickBooleanType ApplyPSDOpacityMask(Image *image,const Image *mask,\n  Quantum background,MagickBooleanType revert,ExceptionInfo *exception)\n{\n  Image\n    *complete_mask;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    color;\n\n  ssize_t\n    y;\n\n  if (image->alpha_trait == UndefinedPixelTrait)\n    return(MagickTrue);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  applying opacity mask\");\n  complete_mask=CloneImage(image,0,0,MagickTrue,exception);\n  if (complete_mask == (Image *) NULL)\n    return(MagickFalse);\n  complete_mask->alpha_trait=BlendPixelTrait;\n  GetPixelInfo(complete_mask,&color);\n  color.red=(MagickRealType) background;\n  (void) SetImageColor(complete_mask,&color,exception);\n  status=CompositeImage(complete_mask,mask,OverCompositeOp,MagickTrue,\n    mask->page.x-image->page.x,mask->page.y-image->page.y,exception);\n  if (status == MagickFalse)\n    {\n      complete_mask=DestroyImage(complete_mask);\n      return(status);\n    }\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static) shared(status) \\\n  magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register Quantum\n      *p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    p=GetAuthenticPixels(complete_mask,0,y,complete_mask->columns,1,exception);\n    if ((q == (Quantum *) NULL) || (p == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        alpha,\n        intensity;\n\n      alpha=(MagickRealType) GetPixelAlpha(image,q);\n      intensity=GetPixelIntensity(complete_mask,p);\n      if (revert == MagickFalse)\n        SetPixelAlpha(image,ClampToQuantum(intensity*(QuantumScale*alpha)),q);\n      else if (intensity > 0)\n        SetPixelAlpha(image,ClampToQuantum((alpha/intensity)*QuantumRange),q);\n      q+=GetPixelChannels(image);\n      p+=GetPixelChannels(complete_mask);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  complete_mask=DestroyImage(complete_mask);\n  return(status);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void NTPInfoObserver::OnTopSitesLoaded() {\n  request_ = top_sites_->StartQueryForMostVisited();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void LayerTreeHostImpl::DidAnimateScrollOffset() {\n  client_->SetNeedsCommitOnImplThread();\n  client_->RenewTreePriority();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CheckValueType(const Value::ValueType expected,\n                    const Value* const actual) {\n  DCHECK(actual != NULL) << \"Expected value to be non-NULL\";\n  DCHECK(expected == actual->GetType())\n      << \"Expected \" << print_valuetype(expected)\n      << \", but was \" << print_valuetype(actual->GetType());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void write_sse_reg(struct x86_emulate_ctxt *ctxt, sse128_t *data,\n\t\t\t  int reg)\n{\n\tctxt->ops->get_fpu(ctxt);\n\tswitch (reg) {\n\tcase 0: asm(\"movdqa %0, %%xmm0\" : : \"m\"(*data)); break;\n\tcase 1: asm(\"movdqa %0, %%xmm1\" : : \"m\"(*data)); break;\n\tcase 2: asm(\"movdqa %0, %%xmm2\" : : \"m\"(*data)); break;\n\tcase 3: asm(\"movdqa %0, %%xmm3\" : : \"m\"(*data)); break;\n\tcase 4: asm(\"movdqa %0, %%xmm4\" : : \"m\"(*data)); break;\n\tcase 5: asm(\"movdqa %0, %%xmm5\" : : \"m\"(*data)); break;\n\tcase 6: asm(\"movdqa %0, %%xmm6\" : : \"m\"(*data)); break;\n\tcase 7: asm(\"movdqa %0, %%xmm7\" : : \"m\"(*data)); break;\n#ifdef CONFIG_X86_64\n\tcase 8: asm(\"movdqa %0, %%xmm8\" : : \"m\"(*data)); break;\n\tcase 9: asm(\"movdqa %0, %%xmm9\" : : \"m\"(*data)); break;\n\tcase 10: asm(\"movdqa %0, %%xmm10\" : : \"m\"(*data)); break;\n\tcase 11: asm(\"movdqa %0, %%xmm11\" : : \"m\"(*data)); break;\n\tcase 12: asm(\"movdqa %0, %%xmm12\" : : \"m\"(*data)); break;\n\tcase 13: asm(\"movdqa %0, %%xmm13\" : : \"m\"(*data)); break;\n\tcase 14: asm(\"movdqa %0, %%xmm14\" : : \"m\"(*data)); break;\n\tcase 15: asm(\"movdqa %0, %%xmm15\" : : \"m\"(*data)); break;\n#endif\n\tdefault: BUG();\n\t}\n\tctxt->ops->put_fpu(ctxt);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,\n                         int normalize)\n{\n    xmlChar limit = 0;\n    const xmlChar *in = NULL, *start, *end, *last;\n    xmlChar *ret = NULL;\n\n    GROW;\n    in = (xmlChar *) CUR_PTR;\n    if (*in != '\"' && *in != '\\'') {\n        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n        return (NULL);\n    }\n    ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n\n    /*\n     * try to handle in this routine the most common case where no\n     * allocation of a new string is required and where content is\n     * pure ASCII.\n     */\n    limit = *in++;\n    end = ctxt->input->end;\n    start = in;\n    if (in >= end) {\n        const xmlChar *oldbase = ctxt->input->base;\n\tGROW;\n\tif (oldbase != ctxt->input->base) {\n\t    long delta = ctxt->input->base - oldbase;\n\t    start = start + delta;\n\t    in = in + delta;\n\t}\n\tend = ctxt->input->end;\n    }\n    if (normalize) {\n        /*\n\t * Skip any leading spaces\n\t */\n\twhile ((in < end) && (*in != limit) && \n\t       ((*in == 0x20) || (*in == 0x9) ||\n\t        (*in == 0xA) || (*in == 0xD))) {\n\t    in++;\n\t    start = in;\n \t    if (in >= end) {\n \t\tconst xmlChar *oldbase = ctxt->input->base;\n \t\tGROW;\n \t\tif (oldbase != ctxt->input->base) {\n \t\t    long delta = ctxt->input->base - oldbase;\n \t\t    start = start + delta;\n\t\t    in = in + delta;\n\t\t}\n\t\tend = ctxt->input->end;\n\t    }\n\t}\n\twhile ((in < end) && (*in != limit) && (*in >= 0x20) &&\n\t       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {\n\t    if ((*in++ == 0x20) && (*in == 0x20)) break;\n \t    if (in >= end) {\n \t\tconst xmlChar *oldbase = ctxt->input->base;\n \t\tGROW;\n \t\tif (oldbase != ctxt->input->base) {\n \t\t    long delta = ctxt->input->base - oldbase;\n \t\t    start = start + delta;\n\t\t    in = in + delta;\n\t\t}\n\t\tend = ctxt->input->end;\n\t    }\n\t}\n\tlast = in;\n\t/*\n\t * skip the trailing blanks\n\t */\n\twhile ((last[-1] == 0x20) && (last > start)) last--;\n\twhile ((in < end) && (*in != limit) && \n\t       ((*in == 0x20) || (*in == 0x9) ||\n\t        (*in == 0xA) || (*in == 0xD))) {\n\t    in++;\n \t    if (in >= end) {\n \t\tconst xmlChar *oldbase = ctxt->input->base;\n \t\tGROW;\n \t\tif (oldbase != ctxt->input->base) {\n \t\t    long delta = ctxt->input->base - oldbase;\n \t\t    start = start + delta;\n\t\t    in = in + delta;\n\t\t    last = last + delta;\n\t\t}\n\t\tend = ctxt->input->end;\n\t    }\n\t}\n\tif (*in != limit) goto need_complex;\n    } else {\n\twhile ((in < end) && (*in != limit) && (*in >= 0x20) &&\n\t       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {\n\t    in++;\n \t    if (in >= end) {\n \t\tconst xmlChar *oldbase = ctxt->input->base;\n \t\tGROW;\n \t\tif (oldbase != ctxt->input->base) {\n \t\t    long delta = ctxt->input->base - oldbase;\n \t\t    start = start + delta;\n\t\t    in = in + delta;\n\t\t}\n\t\tend = ctxt->input->end;\n\t    }\n\t}\n\tlast = in;\n\tif (*in != limit) goto need_complex;\n    }\n    in++;\n    if (len != NULL) {\n        *len = last - start;\n        ret = (xmlChar *) start;\n    } else {\n        if (alloc) *alloc = 1;\n        ret = xmlStrndup(start, last - start);\n    }\n    CUR_PTR = in;\n    if (alloc) *alloc = 0;\n    return ret;\nneed_complex:\n    if (alloc) *alloc = 1;\n    return xmlParseAttValueComplex(ctxt, len, normalize);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "my_object_get_value (MyObject *obj, guint *ret, GError **error)\n{\n  *ret = obj->val;\n  return TRUE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void toggle_fpga_eeprom_bus(bool cpu_own)\n {\n\tqrio_gpio_direction_output(GPIO_A, PROM_SEL_L, !cpu_own);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RenderFrameImpl::PopulateDocumentStateFromPending(\n    DocumentState* document_state) {\n  document_state->set_request_time(\n      pending_navigation_params_->request_params.request_time);\n\n  InternalDocumentStateData* internal_data =\n      InternalDocumentStateData::FromDocumentState(document_state);\n\n  if (!pending_navigation_params_->common_params.url.SchemeIs(\n          url::kJavaScriptScheme) &&\n      pending_navigation_params_->common_params.navigation_type ==\n          FrameMsg_Navigate_Type::RESTORE) {\n    internal_data->set_cache_policy_override(\n        WebURLRequest::UseProtocolCachePolicy);\n  }\n\n  if (IsReload(pending_navigation_params_->common_params.navigation_type))\n    document_state->set_load_type(DocumentState::RELOAD);\n  else if (pending_navigation_params_->request_params.page_state.IsValid())\n    document_state->set_load_type(DocumentState::HISTORY_LOAD);\n  else\n    document_state->set_load_type(DocumentState::NORMAL_LOAD);\n\n  internal_data->set_is_overriding_user_agent(\n      pending_navigation_params_->request_params.is_overriding_user_agent);\n  internal_data->set_must_reset_scroll_and_scale_state(\n      pending_navigation_params_->common_params.navigation_type ==\n      FrameMsg_Navigate_Type::RELOAD_ORIGINAL_REQUEST_URL);\n  document_state->set_can_load_local_resources(\n      pending_navigation_params_->request_params.can_load_local_resources);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "WarmupURLFetcher::WarmupURLFetcher(\n    CreateCustomProxyConfigCallback create_custom_proxy_config_callback,\n    WarmupURLFetcherCallback callback,\n    GetHttpRttCallback get_http_rtt_callback,\n    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,\n    const std::string& user_agent)\n    : is_fetch_in_flight_(false),\n      previous_attempt_counts_(0),\n      create_custom_proxy_config_callback_(create_custom_proxy_config_callback),\n      callback_(callback),\n      get_http_rtt_callback_(get_http_rtt_callback),\n       user_agent_(user_agent),\n       ui_task_runner_(ui_task_runner) {\n   DCHECK(create_custom_proxy_config_callback);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static PHP_METHOD(PDOStatement, getColumnMeta)\n{\n\tlong colno;\n\tstruct pdo_column_data *col;\n\tPHP_STMT_GET_OBJ;\n\n\tif (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &colno)) {\n\t\tRETURN_FALSE;\n\t}\n\tif(colno < 0) {\n\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"42P10\", \"column number must be non-negative\" TSRMLS_CC);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!stmt->methods->get_column_meta) {\n\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"IM001\", \"driver doesn't support meta data\" TSRMLS_CC);\n\t\tRETURN_FALSE;\n\t}\n\n\tPDO_STMT_CLEAR_ERR();\n\tif (FAILURE == stmt->methods->get_column_meta(stmt, colno, return_value TSRMLS_CC)) {\n\t\tPDO_HANDLE_STMT_ERR();\n\t\tRETURN_FALSE;\n\t}\n\n\t/* add stock items */\n\tcol = &stmt->columns[colno];\n\tadd_assoc_string(return_value, \"name\", col->name, 1);\n\tadd_assoc_long(return_value, \"len\", col->maxlen); /* FIXME: unsigned ? */\n\tadd_assoc_long(return_value, \"precision\", col->precision);\n\tif (col->param_type != PDO_PARAM_ZVAL) {\n\t\t/* if param_type is PDO_PARAM_ZVAL the driver has to provide correct data */\n\t\tadd_assoc_long(return_value, \"pdo_type\", col->param_type);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "T1_Get_Private_Dict( T1_Parser      parser,\n                       PSAux_Service  psaux )\n  {\n    FT_Stream  stream = parser->stream;\n    FT_Memory  memory = parser->root.memory;\n    FT_Error   error  = FT_Err_Ok;\n    FT_ULong   size;\n\n\n    if ( parser->in_pfb )\n    {\n      /* in the case of the PFB format, the private dictionary can be  */\n      /* made of several segments.  We thus first read the number of   */\n      /* segments to compute the total size of the private dictionary  */\n      /* then re-read them into memory.                                */\n      FT_ULong   start_pos = FT_STREAM_POS();\n      FT_UShort  tag;\n\n\n      parser->private_len = 0;\n      for (;;)\n      {\n        error = read_pfb_tag( stream, &tag, &size );\n        if ( error )\n          goto Fail;\n\n        if ( tag != 0x8002U )\n          break;\n\n        parser->private_len += size;\n\n        if ( FT_STREAM_SKIP( size ) )\n          goto Fail;\n      }\n\n      /* Check that we have a private dictionary there */\n      /* and allocate private dictionary buffer        */\n      if ( parser->private_len == 0 )\n      {\n        FT_ERROR(( \"T1_Get_Private_Dict:\"\n                   \" invalid private dictionary section\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Fail;\n      }\n\n      if ( FT_STREAM_SEEK( start_pos )                           ||\n           FT_ALLOC( parser->private_dict, parser->private_len ) )\n        goto Fail;\n\n      parser->private_len = 0;\n      for (;;)\n      {\n        error = read_pfb_tag( stream, &tag, &size );\n        if ( error || tag != 0x8002U )\n        {\n          error = FT_Err_Ok;\n          break;\n        }\n\n        if ( FT_STREAM_READ( parser->private_dict + parser->private_len,\n                             size ) )\n          goto Fail;\n\n        parser->private_len += size;\n      }\n    }\n    else\n    {\n      /* We have already `loaded' the whole PFA font file into memory; */\n      /* if this is a memory resource, allocate a new block to hold    */\n      /* the private dict.  Otherwise, simply overwrite into the base  */\n      /* dictionary block in the heap.                                 */\n\n      /* first of all, look at the `eexec' keyword */\n      FT_Byte*    cur   = parser->base_dict;\n      FT_Byte*    limit = cur + parser->base_len;\n      FT_Byte     c;\n      FT_Pointer  pos_lf;\n      FT_Bool     test_cr;\n\n\n    Again:\n      for (;;)\n      {\n        c = cur[0];\n        if ( c == 'e' && cur + 9 < limit )  /* 9 = 5 letters for `eexec' + */\n                                            /* whitespace + 4 chars        */\n        {\n          if ( cur[1] == 'e' &&\n               cur[2] == 'x' &&\n               cur[3] == 'e' &&\n               cur[4] == 'c' )\n            break;\n        }\n        cur++;\n        if ( cur >= limit )\n        {\n          FT_ERROR(( \"T1_Get_Private_Dict:\"\n                     \" could not find `eexec' keyword\\n\" ));\n          error = FT_THROW( Invalid_File_Format );\n          goto Exit;\n        }\n      }\n\n      /* check whether `eexec' was real -- it could be in a comment */\n      /* or string (as e.g. in u003043t.gsf from ghostscript)       */\n\n      parser->root.cursor = parser->base_dict;\n      /* set limit to `eexec' + whitespace + 4 characters */\n      parser->root.limit  = cur + 10;\n\n      cur   = parser->root.cursor;\n      limit = parser->root.limit;\n\n      while ( cur < limit )\n      {\n        if ( *cur == 'e' && ft_strncmp( (char*)cur, \"eexec\", 5 ) == 0 )\n          goto Found;\n\n        T1_Skip_PS_Token( parser );\n        if ( parser->root.error )\n          break;\n        T1_Skip_Spaces  ( parser );\n        cur = parser->root.cursor;\n      }\n\n      /* we haven't found the correct `eexec'; go back and continue */\n      /* searching                                                  */\n \n       cur   = limit;\n       limit = parser->base_dict + parser->base_len;\n       goto Again;\n \n       /* now determine where to write the _encrypted_ binary private  */\n\n      /* According to the Type 1 spec, the first cipher byte must not be */\n      /* an ASCII whitespace character code (blank, tab, carriage return */\n      /* or line feed).  We have seen Type 1 fonts with two line feed    */\n      /* characters...  So skip now all whitespace character codes.      */\n      /*                                                                 */\n      /* On the other hand, Adobe's Type 1 parser handles fonts just     */\n      /* fine that are violating this limitation, so we add a heuristic  */\n      /* test to stop at \\r only if it is not used for EOL.              */\n\n      pos_lf  = ft_memchr( cur, '\\n', (size_t)( limit - cur ) );\n      test_cr = FT_BOOL( !pos_lf                                       ||\n                         pos_lf > ft_memchr( cur,\n                                             '\\r',\n                                             (size_t)( limit - cur ) ) );\n\n      while ( cur < limit                    &&\n              ( *cur == ' '                ||\n                *cur == '\\t'               ||\n                (test_cr && *cur == '\\r' ) ||\n                *cur == '\\n'               ) )\n        ++cur;\n      if ( cur >= limit )\n      {\n        FT_ERROR(( \"T1_Get_Private_Dict:\"\n                   \" `eexec' not properly terminated\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      size = parser->base_len - (FT_ULong)( cur - parser->base_dict );\n\n      if ( parser->in_memory )\n      {\n        /* note that we allocate one more byte to put a terminating `0' */\n        if ( FT_ALLOC( parser->private_dict, size + 1 ) )\n          goto Fail;\n        parser->private_len = size;\n      }\n      else\n      {\n        parser->single_block = 1;\n        parser->private_dict = parser->base_dict;\n        parser->private_len  = size;\n        parser->base_dict    = NULL;\n        parser->base_len     = 0;\n      }\n\n      /* now determine whether the private dictionary is encoded in binary */\n      /* or hexadecimal ASCII format -- decode it accordingly              */\n\n      /* we need to access the next 4 bytes (after the final whitespace */\n      /* following the `eexec' keyword); if they all are hexadecimal    */\n      /* digits, then we have a case of ASCII storage                   */\n\n      if ( cur + 3 < limit                                &&\n           ft_isxdigit( cur[0] ) && ft_isxdigit( cur[1] ) &&\n           ft_isxdigit( cur[2] ) && ft_isxdigit( cur[3] ) )\n      {\n        /* ASCII hexadecimal encoding */\n        FT_ULong  len;\n\n\n        parser->root.cursor = cur;\n        (void)psaux->ps_parser_funcs->to_bytes( &parser->root,\n                                                parser->private_dict,\n                                                parser->private_len,\n                                                &len,\n                                                0 );\n        parser->private_len = len;\n\n        /* put a safeguard */\n        parser->private_dict[len] = '\\0';\n      }\n      else\n        /* binary encoding -- copy the private dict */\n        FT_MEM_MOVE( parser->private_dict, cur, size );\n    }\n\n    /* we now decrypt the encoded binary private dictionary */\n    psaux->t1_decrypt( parser->private_dict, parser->private_len, 55665U );\n\n    if ( parser->private_len < 4 )\n    {\n      FT_ERROR(( \"T1_Get_Private_Dict:\"\n                 \" invalid private dictionary section\\n\" ));\n      error = FT_THROW( Invalid_File_Format );\n      goto Fail;\n    }\n\n    /* replace the four random bytes at the beginning with whitespace */\n    parser->private_dict[0] = ' ';\n    parser->private_dict[1] = ' ';\n    parser->private_dict[2] = ' ';\n    parser->private_dict[3] = ' ';\n\n    parser->root.base   = parser->private_dict;\n    parser->root.cursor = parser->private_dict;\n    parser->root.limit  = parser->root.cursor + parser->private_len;\n\n  Fail:\n  Exit:\n    return error;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int lzh_read_input(struct kwajd_stream *lzh) {\n    int read;\n    if (lzh->input_end) {\n\tlzh->input_end += 8;\n\tlzh->inbuf[0] = 0;\n\tread = 1;\n    }\n    else {\n\tread = lzh->sys->read(lzh->input, &lzh->inbuf[0], KWAJ_INPUT_SIZE);\n\tif (read < 0) return MSPACK_ERR_READ;\n\tif (read == 0) {\n\t    lzh->input_end = 8;\n\t    lzh->inbuf[0] = 0;\n\t    read = 1;\n\t}\n    }\n\n    /* update i_ptr and i_end */\n    lzh->i_ptr = &lzh->inbuf[0];\n    lzh->i_end = &lzh->inbuf[read];\n    return MSPACK_ERR_OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tint err;\n\tint ds;\n\tint ss;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n\n \tsalg = shash_attr_alg(tb[1], 0, 0);\n \tif (IS_ERR(salg))\n \t\treturn PTR_ERR(salg);\n \n \terr = -EINVAL;\n \tds = salg->digestsize;\n \tss = salg->statesize;\n\talg = &salg->base;\n \tif (ds > alg->cra_blocksize ||\n \t    ss < alg->cra_blocksize)\n \t\tgoto out_put_alg;\n\n\tinst = shash_alloc_instance(\"hmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\terr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\n\t\t\t\t      shash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\n\tinst->alg.base.cra_init = hmac_init_tfm;\n\tinst->alg.base.cra_exit = hmac_exit_tfm;\n\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BrowserTabStripController::TabSelectionChanged(\n    TabStripModel* tab_strip_model,\n    const TabStripSelectionModel& old_model) {\n  tabstrip_->SetSelection(old_model, model_->selection_model());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n   }\n \n   (void) CloseBlob(image);\n  DestroyImage(RemoveFirstImageFromList(&image));\n   if (image_type == GIMP_GRAY)\n     image->type=GrayscaleType;\n   return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int do_recv_NPUTF8(rpc_message_t *message, void *p_value)\n{\n  NPUTF8 **string_p = (NPUTF8 **)p_value;\n  NPUTF8 *string = NULL;\n\n  uint32_t len;\n  int error = rpc_message_recv_uint32(message, &len);\n  if (error < 0)\n\treturn error;\n  if ((string = NPN_MemAlloc(len)) == NULL)\n\treturn RPC_ERROR_NO_MEMORY;\n  if (len > 0) {\n\tif ((error = rpc_message_recv_bytes(message, (unsigned char *)string, len)) < 0)\n\t  return error;\n  }\n\n  if (string_p)\n\t*string_p = string;\n  else if (string)\n\tNPN_MemFree(string);\n  return RPC_ERROR_NO_ERROR;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-59"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "XListFonts(\nregister Display *dpy,\n_Xconst char *pattern,  /* null-terminated */\nint maxNames,\nint *actualCount)\t/* RETURN */\n{\n    register long nbytes;\n    register unsigned i;\n    register int length;\n    char **flist = NULL;\n    char *ch = NULL;\n    char *chstart;\n    char *chend;\n    int count = 0;\n    xListFontsReply rep;\n    register xListFontsReq *req;\n    unsigned long rlen = 0;\n\n    LockDisplay(dpy);\n    GetReq(ListFonts, req);\n    req->maxNames = maxNames;\n    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;\n    req->length += (nbytes + 3) >> 2;\n    _XSend (dpy, pattern, nbytes);\n    /* use _XSend instead of Data, since following _XReply will flush buffer */\n\n    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {\n\t*actualCount = 0;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (char **) NULL;\n    }\n\n    if (rep.nFonts) {\n\tflist = Xmalloc (rep.nFonts * sizeof(char *));\n\tif (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t    rlen = rep.length << 2;\n\t    ch = Xmalloc(rlen + 1);\n\t    /* +1 to leave room for last null-terminator */\n\t}\n\n\tif ((! flist) || (! ch)) {\n\t    Xfree(flist);\n\t    Xfree(ch);\n\t    _XEatDataWords(dpy, rep.length);\n\t    *actualCount = 0;\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\n\t_XReadPad (dpy, ch, rlen);\n\t/*\n \t * unpack into null terminated strings.\n \t */\n \tchstart = ch;\n\tchend = ch + (rlen + 1);\n \tlength = *(unsigned char *)ch;\n \t*ch = 1; /* make sure it is non-zero for XFreeFontNames */\n \tfor (i = 0; i < rep.nFonts; i++) {\n \t    if (ch + length < chend) {\n \t\tflist[i] = ch + 1;  /* skip over length */\n \t\tch += length + 1;  /* find next length ... */\n\t\tif (ch <= chend) {\n\t\t    length = *(unsigned char *)ch;\n\t\t    *ch = '\\0';  /* and replace with null-termination */\n\t\t    count++;\n\t\t} else {\n                    Xfree(chstart);\n                    Xfree(flist);\n                    flist = NULL;\n                    count = 0;\n                    break;\n\t\t}\n \t    } else {\n                 Xfree(chstart);\n                 Xfree(flist);\n                    Xfree(flist);\n                    flist = NULL;\n                    count = 0;\n                    break;\n\t\t}\n\t    } else {\n                Xfree(chstart);\n                Xfree(flist);\n                flist = NULL;\n                count = 0;\n                break;\n            }\n\t}\n    }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-682"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void scm_detach_fds_compat(struct msghdr *kmsg, struct scm_cookie *scm)\n{\n\tstruct compat_cmsghdr __user *cm = (struct compat_cmsghdr __user *) kmsg->msg_control;\n\tint fdmax = (kmsg->msg_controllen - sizeof(struct compat_cmsghdr)) / sizeof(int);\n\tint fdnum = scm->fp->count;\n\tstruct file **fp = scm->fp->fp;\n\tint __user *cmfptr;\n\tint err = 0, i;\n\n\tif (fdnum < fdmax)\n\t\tfdmax = fdnum;\n\n\tfor (i = 0, cmfptr = (int __user *) CMSG_COMPAT_DATA(cm); i < fdmax; i++, cmfptr++) {\n\t\tint new_fd;\n\t\terr = security_file_receive(fp[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = get_unused_fd_flags(MSG_CMSG_CLOEXEC & kmsg->msg_flags\n\t\t\t\t\t  ? O_CLOEXEC : 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tnew_fd = err;\n\t\terr = put_user(new_fd, cmfptr);\n\t\tif (err) {\n\t\t\tput_unused_fd(new_fd);\n\t\t\tbreak;\n\t\t}\n\t\t/* Bump the usage count and install the file. */\n\t\tfd_install(new_fd, get_file(fp[i]));\n\t}\n\n\tif (i > 0) {\n\t\tint cmlen = CMSG_COMPAT_LEN(i * sizeof(int));\n\t\terr = put_user(SOL_SOCKET, &cm->cmsg_level);\n\t\tif (!err)\n\t\t\terr = put_user(SCM_RIGHTS, &cm->cmsg_type);\n\t\tif (!err)\n\t\t\terr = put_user(cmlen, &cm->cmsg_len);\n\t\tif (!err) {\n\t\t\tcmlen = CMSG_COMPAT_SPACE(i * sizeof(int));\n\t\t\tkmsg->msg_control += cmlen;\n\t\t\tkmsg->msg_controllen -= cmlen;\n\t\t}\n\t}\n\tif (i < fdnum)\n\t\tkmsg->msg_flags |= MSG_CTRUNC;\n\n\t/*\n\t * All of the files that fit in the message have had their\n\t * usage counts incremented, so we just free the list.\n\t */\n\t__scm_destroy(scm);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "unsigned long long Track::GetCodecDelay() const\n{\n    return m_info.codecDelay;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void buffer_slow_realign(struct buffer *buf)\n {\n       /* two possible cases :\n        *   - the buffer is in one contiguous block, we move it in-place\n        *   - the buffer is in two blocks, we move it via the swap_buffer\n        */\n       if (buf->i) {\n               int block1 = buf->i;\n               int block2 = 0;\n               if (buf->p + buf->i > buf->data + buf->size) {\n                       /* non-contiguous block */\n                       block1 = buf->data + buf->size - buf->p;\n                       block2 = buf->p + buf->i - (buf->data + buf->size);\n               }\n               if (block2)\n                       memcpy(swap_buffer, buf->data, block2);\n               memmove(buf->data, buf->p, block1);\n               if (block2)\n                       memcpy(buf->data + block1, swap_buffer, block2);\n        }\n \n        buf->p = buf->data;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool IsSmartVirtualKeyboardEnabled() {\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n           keyboard::switches::kEnableVirtualKeyboard)) {\n     return false;\n   }\n  return !base::CommandLine::ForCurrentProcess()->HasSwitch(\n      keyboard::switches::kDisableSmartVirtualKeyboard);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n     const vpx_rational_t tb = video->timebase();\n     timebase_ = static_cast<double>(tb.num) / tb.den;\n     duration_ = 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int snd_seq_device_dev_free(struct snd_device *device)\n {\n \tstruct snd_seq_device *dev = device->device_data;\n \n \tput_device(&dev->dev);\n \treturn 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool mkvparser::Match(\n    IMkvReader* pReader,\n    long long& pos,\n    unsigned long id_,\n    unsigned char*& buf,\n    size_t& buflen)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    long long total, available;\n \n    long status = pReader->Length(&total, &available);\n    assert(status >= 0);\n    assert((total < 0) || (available <= total));\n    if (status < 0)\n        return false;\n \n    long len;\n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);\n    assert(len > 0);\n    assert(len <= 8);\n    assert((pos + len) <= available);\n \n    if ((unsigned long)id != id_)\n        return false;\n \n    pos += len;  //consume id\n \n    const long long size_ = ReadUInt(pReader, pos, len);\n    assert(size_ >= 0);\n    assert(len > 0);\n    assert(len <= 8);\n    assert((pos + len) <= available);\n \n    pos += len;  //consume length of size of payload\n    assert((pos + size_) <= available);\n \n    const long buflen_ = static_cast<long>(size_);\n \n    buf = new (std::nothrow) unsigned char[buflen_];\n    assert(buf);  //TODO\n \n    status = pReader->Read(pos, buflen_, buf);\n    assert(status == 0);  //TODO\n \n    buflen = buflen_;\n \n    pos += size_;  //consume size of payload\n    return true;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PassRefPtr<RTCSessionDescriptionRequestImpl> RTCSessionDescriptionRequestImpl::create(ScriptExecutionContext* context, PassRefPtr<RTCSessionDescriptionCallback> successCallback, PassRefPtr<RTCErrorCallback> errorCallback)\n {\n    RefPtr<RTCSessionDescriptionRequestImpl> request = adoptRef(new RTCSessionDescriptionRequestImpl(context, successCallback, errorCallback));\n     request->suspendIfNeeded();\n     return request.release();\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void *fb_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&registration_lock);\n\treturn (*pos < FB_MAX) ? pos : NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "cib_connect(gboolean full)\n{\n    int rc = pcmk_ok;\n    static gboolean need_pass = TRUE;\n\n    CRM_CHECK(cib != NULL, return -EINVAL);\n\n    if (getenv(\"CIB_passwd\") != NULL) {\n        need_pass = FALSE;\n    }\n\n    if(watch_fencing && st == NULL) {\n        st = stonith_api_new();\n    }\n    \n    if(watch_fencing && st->state == stonith_disconnected) {\n        crm_trace(\"Connecting to stonith\");\n        rc = st->cmds->connect(st, crm_system_name, NULL);\n        if(rc == pcmk_ok) {\n            crm_trace(\"Setting up stonith callbacks\");\n            st->cmds->register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);\n        }\n    }\n    \n    if (cib->state != cib_connected_query && cib->state != cib_connected_command) {\n        crm_trace(\"Connecting to the CIB\");\n        if (as_console && need_pass && cib->variant == cib_remote) {\n            need_pass = FALSE;\n            print_as(\"Password:\");\n        }\n\n        rc = cib->cmds->signon(cib, crm_system_name, cib_query);\n\n        if (rc != pcmk_ok) {\n            return rc;\n        }\n\n        current_cib = get_cib_copy(cib);\n        mon_refresh_display(NULL);\n\n        if (full) {\n             if (rc == pcmk_ok) {\n                 rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                 if (rc == -EPROTONOSUPPORT) {\n                    print_as(\"Notification setup failed, won't be able to reconnect after failure\");\n                     if (as_console) {\n                         sleep(2);\n                     }\n                    rc = pcmk_ok;\n                }\n\n            }\n\n            if (rc == pcmk_ok) {\n                cib->cmds->del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n                rc = cib->cmds->add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n            }\n\n            if (rc != pcmk_ok) {\n                print_as(\"Notification setup failed, could not monitor CIB actions\");\n                if (as_console) {\n                    sleep(2);\n                }\n                clean_up(-rc);\n            }\n        }\n    }\n    return rc;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "prepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FLAG_IS_INHERITED;\n  sc->mt = kh_init(mt, mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, mrb_intern_lit(mrb, \"__attached__\"), mrb_obj_value(o));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void virtio_scsi_bad_req(void)\n{\n    error_report(\"wrong size for virtio-scsi headers\");\n    exit(1);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "DeactivatePointerGrab(DeviceIntPtr mouse)\n{\n    GrabPtr grab = mouse->deviceGrab.grab;\n    DeviceIntPtr dev;\n    Bool wasPassive = mouse->deviceGrab.fromPassiveGrab;\n    Bool wasImplicit = (mouse->deviceGrab.fromPassiveGrab &&\n                        mouse->deviceGrab.implicitGrab);\n    XID grab_resource = grab->resource;\n    int i;\n\n    /* If an explicit grab was deactivated, we must remove it from the head of\n     * all the touches' listener lists. */\n    for (i = 0; !wasPassive && mouse->touch && i < mouse->touch->num_touches; i++) {\n        TouchPointInfoPtr ti = mouse->touch->touches + i;\n        if (ti->active && TouchResourceIsOwner(ti, grab_resource)) {\n            int mode = XIRejectTouch;\n            /* Rejecting will generate a TouchEnd, but we must not\n               emulate a ButtonRelease here. So pretend the listener\n               already has the end event */\n            if (grab->grabtype == CORE || grab->grabtype == XI ||\n                    !xi2mask_isset(mouse->deviceGrab.grab->xi2mask, mouse, XI_TouchBegin)) {\n                mode = XIAcceptTouch;\n                /* NOTE: we set the state here, but\n                 * ProcessTouchOwnershipEvent() will still call\n                 * TouchEmitTouchEnd for this listener. The other half of\n                 * this hack is in DeliverTouchEndEvent */\n                ti->listeners[0].state = LISTENER_HAS_END;\n            }\n            TouchListenerAcceptReject(mouse, ti, 0, mode);\n        }\n    }\n\n    TouchRemovePointerGrab(mouse);\n\n    mouse->valuator->motionHintWindow = NullWindow;\n    mouse->deviceGrab.grab = NullGrab;\n    mouse->deviceGrab.sync.state = NOT_GRABBED;\n    mouse->deviceGrab.fromPassiveGrab = FALSE;\n\n    for (dev = inputInfo.devices; dev; dev = dev->next) {\n        if (dev->deviceGrab.sync.other == grab)\n            dev->deviceGrab.sync.other = NullGrab;\n    }\n    DoEnterLeaveEvents(mouse, mouse->id, grab->window,\n                       mouse->spriteInfo->sprite->win, NotifyUngrab);\n    if (grab->confineTo)\n        ConfineCursorToWindow(mouse, GetCurrentRootWindow(mouse), FALSE, FALSE);\n    PostNewCursor(mouse);\n\n    if (!wasImplicit && grab->grabtype == XI2)\n        ReattachToOldMaster(mouse);\n\n    ComputeFreezes();\n\n    FreeGrab(grab);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "_kdc_make_anonymous_principalname (PrincipalName *pn)\n{\n    pn->name_type = KRB5_NT_PRINCIPAL;\n    pn->name_string.len = 1;\n    pn->name_string.val = malloc(sizeof(*pn->name_string.val));\n    if (pn->name_string.val == NULL)\n\treturn ENOMEM;\n    pn->name_string.val[0] = strdup(\"anonymous\");\n    if (pn->name_string.val[0] == NULL) {\n\tfree(pn->name_string.val);\n\tpn->name_string.val = NULL;\n\treturn ENOMEM;\n    }\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void HTMLInputElement::onSearch()\n{\n    ASSERT(isSearchField());\n    if (m_inputType)\n        static_cast<SearchInputType*>(m_inputType.get())->stopSearchEventTimer();\n    dispatchEvent(Event::createBubble(EventTypeNames::search));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual void commitCompleteOnCCThread(CCLayerTreeHostImpl*)\n     {\n         m_numCommits++;\n     }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long sys_arch_prctl(int code, unsigned long addr)\n{\n\treturn do_arch_prctl(current, code, addr);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xscale1pmu_read_counter(int counter)\n{\n\tu32 val = 0;\n\n\tswitch (counter) {\n\tcase XSCALE_CYCLE_COUNTER:\n\t\tasm volatile(\"mrc p14, 0, %0, c1, c0, 0\" : \"=r\" (val));\n\t\tbreak;\n\tcase XSCALE_COUNTER0:\n\t\tasm volatile(\"mrc p14, 0, %0, c2, c0, 0\" : \"=r\" (val));\n\t\tbreak;\n\tcase XSCALE_COUNTER1:\n\t\tasm volatile(\"mrc p14, 0, %0, c3, c0, 0\" : \"=r\" (val));\n\t\tbreak;\n\t}\n\n\treturn val;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t buffer, uint32 samplecount){\n\n\tuint32 i=0;\n\n\tfor(i=0;i<samplecount;i++){\n\t\tif( (((unsigned char*)buffer)[(i*3)+1] & 0x80) !=0){\n\t\t\t((unsigned char*)buffer)[(i*3)+1] =\n\t\t\t\t(unsigned char)(0x80 + ((char*)buffer)[(i*3)+1]);\n\t\t} else {\n\t\t\t((unsigned char*)buffer)[(i*3)+1] |= 0x80;\n\t\t}\n\t\tif( (((unsigned char*)buffer)[(i*3)+2] & 0x80) !=0){\n\t\t\t((unsigned char*)buffer)[(i*3)+2] =\n\t\t\t\t(unsigned char)(0x80 + ((char*)buffer)[(i*3)+2]);\n\t\t} else {\n\t\t\t((unsigned char*)buffer)[(i*3)+2] |= 0x80;\n\t\t}\n\t}\n\n\treturn(samplecount*3);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int tg3_get_rxfh_indir(struct net_device *dev, u32 *indir)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)\n\t\tindir[i] = tp->rss_ind_tbl[i];\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RunSignBiasCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_output_block, 64);\n     int count_sign_block[64][2];\n     const int count_test_block = 100000;\n \n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n\n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = rnd.Rand8() - rnd.Rand8();\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 1125;\n      EXPECT_LT(diff, max_diff)\n           << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-255, 255] at index \" << j\n << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n\n\n     memset(count_sign_block, 0, sizeof(count_sign_block));\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = (rnd.Rand8() >> 4) - (rnd.Rand8() >> 4);\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 10000;\n      EXPECT_LT(diff, max_diff)\n          << \"Error: 4x4 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-15, 15] at index \" << j\n           << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n \t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n \t\t\t\tbuffer_caret++;\n \n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n \t\t\t\t\tgdFree( decompression_buffer );\n \t\t\t\t\tgdFree( conversion_buffer );\n \t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n \t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n \t\t\t\tbuffer_caret++;\n \n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n \t\t\t\t\tgdFree( decompression_buffer );\n \t\t\t\t\tgdFree( conversion_buffer );\n \t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void rpc_set_active(struct rpc_task *task)\n{\n\trpc_task_set_debuginfo(task);\n\tset_bit(RPC_TASK_ACTIVE, &task->tk_runstate);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Smb4KMountJob::fillArgs(Smb4KShare *share, QMap<QString, QVariant>& map)\n {\n  QString mount;\n  QStringList paths;\n  paths << \"/bin\";\n  paths << \"/sbin\";\n  paths << \"/usr/bin\";\n  paths << \"/usr/sbin\";\n  paths << \"/usr/local/bin\";\n  paths << \"/usr/local/sbin\";\n  for (int i = 0; i < paths.size(); ++i)\n  {\n    mount = KGlobal::dirs()->findExe(\"mount.cifs\", paths.at(i));\n    if (!mount.isEmpty())\n    {\n      map.insert(\"mh_command\", mount);\n      break;\n    }\n    else\n    {\n      continue;\n    }\n  }\n \n   if (mount.isEmpty())\n   {\n  paths << \"/sbin\";\n  paths << \"/usr/bin\";\n  paths << \"/usr/sbin\";\n  paths << \"/usr/local/bin\";\n  paths << \"/usr/local/sbin\";\n   }\n   \n   QMap<QString, QString> global_options = globalSambaOptions();\n   Smb4KCustomOptions *options  = Smb4KCustomOptionsManager::self()->findOptions(share);\n      break;\n    }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "qboolean FS_idPak(char *pak, char *base, int numPaks) {\n\tint i;\n\n\tif ( !FS_FilenameCompare( pak, va( \"%s/mp_bin\", base ) ) ) {\n\t\treturn qtrue;\n\t}\n\n\tfor ( i = 0; i < NUM_ID_PAKS; i++ ) {\n\t\tif ( !FS_FilenameCompare( pak, va( \"%s/mp_bin%d\", base, i ) ) ) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( !FS_FilenameCompare( pak, va( \"%s/pak%d\", base, i ) ) ) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( !FS_FilenameCompare( pak, va( \"%s/mp_pak%d\",base,i ) ) ) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( !FS_FilenameCompare( pak, va( \"%s/sp_pak%d\",base,i + 1) ) ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( i < numPaks ) {\n\t\treturn qtrue;\n\t}\n\treturn qfalse;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-269"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long Chapters::Edition::ParseAtom(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    if (!ExpandAtomsArray())\n        return -1;\n \n    Atom& a = m_atoms[m_atoms_count++];\n    a.Init();\n \n    return a.Parse(pReader, pos, size);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void QuotaTask::DeleteSoon() {\n   MessageLoop::current()->DeleteSoon(FROM_HERE, this);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "is_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server);\n\t}\n\n\treturn false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void bta_pan_callback_transfer(UINT16 event, char *p_param)\n{\n    tBTA_PAN *p_data = (tBTA_PAN *)p_param;\n\n switch(event)\n {\n case BTA_PAN_ENABLE_EVT:\n            BTIF_TRACE_DEBUG(\"BTA_PAN_ENABLE_EVT\");\n break;\n case BTA_PAN_SET_ROLE_EVT:\n {\n int btpan_role = bta_role_to_btpan(p_data->set_role.role);\n bt_status_t status = p_data->set_role.status == BTA_PAN_SUCCESS ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;\n btpan_control_state_t state = btpan_role == 0 ? BTPAN_STATE_DISABLED : BTPAN_STATE_ENABLED;\n                callback.control_state_cb(state, btpan_role, status, TAP_IF_NAME);\n break;\n }\n case BTA_PAN_OPENING_EVT:\n {\n btpan_conn_t* conn;\n bdstr_t bds;\n                bdaddr_to_string((bt_bdaddr_t *)p_data->opening.bd_addr, bds, sizeof(bds));\n                BTIF_TRACE_DEBUG(\"BTA_PAN_OPENING_EVT handle %d, addr: %s\", p_data->opening.handle, bds);\n                conn = btpan_find_conn_addr(p_data->opening.bd_addr);\n\n                asrt(conn != NULL);\n if (conn)\n {\n                    conn->handle = p_data->opening.handle;\n int btpan_conn_local_role = bta_role_to_btpan(conn->local_role);\n int btpan_remote_role = bta_role_to_btpan(conn->remote_role);\n                    callback.connection_state_cb(BTPAN_STATE_CONNECTING, BT_STATUS_SUCCESS,\n (const bt_bdaddr_t*)p_data->opening.bd_addr, btpan_conn_local_role, btpan_remote_role);\n }\n else\n                    BTIF_TRACE_ERROR(\"connection not found\");\n break;\n }\n case BTA_PAN_OPEN_EVT:\n {\n btpan_connection_state_t state;\n bt_status_t status;\n btpan_conn_t *conn = btpan_find_conn_handle(p_data->open.handle);\n\n                LOG_VERBOSE(\"%s pan connection open status: %d\", __func__, p_data->open.status);\n if (p_data->open.status == BTA_PAN_SUCCESS)\n {\n                    state = BTPAN_STATE_CONNECTED;\n                    status = BT_STATUS_SUCCESS;\n                    btpan_open_conn(conn, p_data);\n }\n else\n {\n                    state = BTPAN_STATE_DISCONNECTED;\n                    status = BT_STATUS_FAIL;\n                    btpan_cleanup_conn(conn);\n }\n /* debug(\"BTA_PAN_OPEN_EVT handle:%d, conn:%p\",  p_data->open.handle, conn); */\n /* debug(\"conn bta local_role:%d, bta remote role:%d\", conn->local_role, conn->remote_role); */\n int btpan_conn_local_role = bta_role_to_btpan(p_data->open.local_role);\n int btpan_remote_role = bta_role_to_btpan(p_data->open.peer_role);\n                callback.connection_state_cb(state, status, (const bt_bdaddr_t*)p_data->open.bd_addr,\n                        btpan_conn_local_role, btpan_remote_role);\n break;\n }\n case BTA_PAN_CLOSE_EVT:\n {\n btpan_conn_t* conn = btpan_find_conn_handle(p_data->close.handle);\n\n                LOG_INFO(\"%s: event = BTA_PAN_CLOSE_EVT handle %d\", __FUNCTION__, p_data->close.handle);\n                btpan_close_conn(conn);\n\n if (conn && conn->handle >= 0)\n {\n int btpan_conn_local_role = bta_role_to_btpan(conn->local_role);\n int btpan_remote_role = bta_role_to_btpan(conn->remote_role);\n                    callback.connection_state_cb(BTPAN_STATE_DISCONNECTED, 0, (const bt_bdaddr_t*)conn->peer,\n                            btpan_conn_local_role, btpan_remote_role);\n                    btpan_cleanup_conn(conn);\n }\n else\n                    BTIF_TRACE_ERROR(\"pan handle not found (%d)\", p_data->close.handle);\n break;\n }\n default:\n            BTIF_TRACE_WARNING(\"Unknown pan event %d\", event);\n break;\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void stream_int_chk_snd_conn(struct stream_interface *si)\n{\n\tstruct channel *ob = si->ob;\n\tstruct connection *conn = __objt_conn(si->end);\n\n\tif (unlikely(si->state > SI_ST_EST || (ob->flags & CF_SHUTW)))\n\t\treturn;\n\n\tif (unlikely(channel_is_empty(ob)))  /* called with nothing to send ! */\n\t\treturn;\n\n\tif (!ob->pipe &&                          /* spliced data wants to be forwarded ASAP */\n\t    !(si->flags & SI_FL_WAIT_DATA))       /* not waiting for data */\n\t\treturn;\n\n\tif (conn->flags & (CO_FL_DATA_WR_ENA|CO_FL_CURR_WR_ENA)) {\n\t\t/* already subscribed to write notifications, will be called\n\t\t * anyway, so let's avoid calling it especially if the reader\n\t\t * is not ready.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* Before calling the data-level operations, we have to prepare\n\t * the polling flags to ensure we properly detect changes.\n\t */\n\tconn_refresh_polling_flags(conn);\n\t__conn_data_want_send(conn);\n\n\tif (!(conn->flags & (CO_FL_HANDSHAKE|CO_FL_WAIT_L4_CONN|CO_FL_WAIT_L6_CONN))) {\n\t\tsi_conn_send(conn);\n\t\tif (conn->flags & CO_FL_ERROR) {\n\t\t\t/* Write error on the file descriptor */\n\t\t\t__conn_data_stop_both(conn);\n\t\t\tsi->flags |= SI_FL_ERR;\n\t\t\tgoto out_wakeup;\n\t\t}\n\t}\n\n\t/* OK, so now we know that some data might have been sent, and that we may\n\t * have to poll first. We have to do that too if the buffer is not empty.\n\t */\n\tif (channel_is_empty(ob)) {\n\t\t/* the connection is established but we can't write. Either the\n\t\t * buffer is empty, or we just refrain from sending because the\n\t\t * ->o limit was reached. Maybe we just wrote the last\n\t\t * chunk and need to close.\n\t\t */\n\t\t__conn_data_stop_send(conn);\n\t\tif (((ob->flags & (CF_SHUTW|CF_AUTO_CLOSE|CF_SHUTW_NOW)) ==\n\t\t     (CF_AUTO_CLOSE|CF_SHUTW_NOW)) &&\n\t\t    (si->state == SI_ST_EST)) {\n\t\t\tsi_shutw(si);\n\t\t\tgoto out_wakeup;\n\t\t}\n\n\t\tif ((ob->flags & (CF_SHUTW|CF_SHUTW_NOW)) == 0)\n\t\t\tsi->flags |= SI_FL_WAIT_DATA;\n\t\tob->wex = TICK_ETERNITY;\n\t}\n\telse {\n\t\t/* Otherwise there are remaining data to be sent in the buffer,\n\t\t * which means we have to poll before doing so.\n\t\t */\n\t\t__conn_data_want_send(conn);\n\t\tsi->flags &= ~SI_FL_WAIT_DATA;\n\t\tif (!tick_isset(ob->wex))\n\t\t\tob->wex = tick_add_ifset(now_ms, ob->wto);\n\t}\n\n\tif (likely(ob->flags & CF_WRITE_ACTIVITY)) {\n\t\t/* update timeout if we have written something */\n\t\tif ((ob->flags & (CF_SHUTW|CF_WRITE_PARTIAL)) == CF_WRITE_PARTIAL &&\n\t\t    !channel_is_empty(ob))\n\t\t\tob->wex = tick_add_ifset(now_ms, ob->wto);\n\n\t\tif (tick_isset(si->ib->rex) && !(si->flags & SI_FL_INDEP_STR)) {\n\t\t\t/* Note: to prevent the client from expiring read timeouts\n\t\t\t * during writes, we refresh it. We only do this if the\n\t\t\t * interface is not configured for \"independent streams\",\n\t\t\t * because for some applications it's better not to do this,\n\t\t\t * for instance when continuously exchanging small amounts\n\t\t\t * of data which can full the socket buffers long before a\n\t\t\t * write timeout is detected.\n\t\t\t */\n\t\t\tsi->ib->rex = tick_add_ifset(now_ms, si->ib->rto);\n\t\t}\n\t}\n\n\t/* in case of special condition (error, shutdown, end of write...), we\n\t * have to notify the task.\n\t */\n\tif (likely((ob->flags & (CF_WRITE_NULL|CF_WRITE_ERROR|CF_SHUTW)) ||\n\t          ((ob->flags & CF_WAKE_WRITE) &&\n\t           ((channel_is_empty(si->ob) && !ob->to_forward) ||\n\t            si->state != SI_ST_EST)))) {\n\tout_wakeup:\n\t\tif (!(si->flags & SI_FL_DONT_WAKE) && si->owner)\n\t\t\ttask_wakeup(si->owner, TASK_WOKEN_IO);\n\t}\n\n\t/* commit possible polling changes */\n\tconn_cond_update_polling(conn);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n \t\treturn -EPROTONOSUPPORT;\n \n \thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \n \terr = hci_uart_register_dev(hu);\n \tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n \t\treturn err;\n \t}\n \n \treturn 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {\n Mutex::Autolock autoLock(mLock);\n\n if (getGraphicBufferSource() != NULL) {\n        android_errorWriteLog(0x534e4554, \"29422020\");\n return INVALID_OPERATION;\n }\n\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, kPortIndexInput);\n if (header == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n\n     }\n     BufferMeta *buffer_meta =\n         static_cast<BufferMeta *>(header->pAppPrivate);\n    sp<ABuffer> backup = buffer_meta->getBuffer(header, true /* backup */, false /* limit */);\n    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* backup */, false /* limit */);\n \n    if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource\n            && backup->capacity() >= sizeof(VideoNativeMetadata)\n            && codec->capacity() >= sizeof(VideoGrallocMetadata)\n            && ((VideoNativeMetadata *)backup->base())->eType\n                    == kMetadataBufferTypeANWBuffer) {\n        VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();\n        VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();\n        CLOG_BUFFER(emptyBuffer, \"converting ANWB %p to handle %p\",\n                backupMeta.pBuffer, backupMeta.pBuffer->handle);\n        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;\n        codecMeta.eType = kMetadataBufferTypeGrallocSource;\n        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;\n         header->nOffset = 0;\n     } else {\n if (rangeOffset > header->nAllocLen\n || rangeLength > header->nAllocLen - rangeOffset) {\n            CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));\n if (fenceFd >= 0) {\n ::close(fenceFd);\n }\n return BAD_VALUE;\n }\n        header->nFilledLen = rangeLength;\n        header->nOffset = rangeOffset;\n\n        buffer_meta->CopyToOMX(header);\n }\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n {\n \tstatic u32 ip6_idents_hashrnd __read_mostly;\n \tu32 hash, id;\n \n \tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n \n \thash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd);\n \thash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash);\n \n \tid = ip_idents_reserve(hash, 1);\n \tfhdr->identification = htonl(id);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CapturerMac::CaptureInvalidRects(CaptureCompletedCallback* callback) {\n  scoped_refptr<CaptureData> data;\n  if (capturing_) {\n    InvalidRects rects;\n    helper_.SwapInvalidRects(rects);\n    VideoFrameBuffer& current_buffer = buffers_[current_buffer_];\n    current_buffer.Update();\n\n    bool flip = true;  // GL capturers need flipping.\n    if (cgl_context_) {\n       if (pixel_buffer_object_.get() != 0) {\n         GlBlitFast(current_buffer);\n       } else {\n         GlBlitSlow(current_buffer);\n       }\n     } else {\n      CgBlit(current_buffer, rects);\n      flip = false;\n    }\n\n    DataPlanes planes;\n    planes.data[0] = current_buffer.ptr();\n    planes.strides[0] = current_buffer.bytes_per_row();\n    if (flip) {\n      planes.strides[0] = -planes.strides[0];\n      planes.data[0] +=\n          (current_buffer.size().height() - 1) * current_buffer.bytes_per_row();\n    }\n\n    data = new CaptureData(planes, gfx::Size(current_buffer.size()),\n                           pixel_format());\n    data->mutable_dirty_rects() = rects;\n\n    current_buffer_ = (current_buffer_ + 1) % kNumBuffers;\n    helper_.set_size_most_recent(data->size());\n  }\n\n  callback->Run(data);\n  delete callback;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "gre_print_0(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\tu_int len = length;\n\tuint16_t flags, prot;\n\n\t/* 16 bits ND_TCHECKed in gre_print() */\n\tflags = EXTRACT_16BITS(bp);\n        if (ndo->ndo_vflag)\n            ND_PRINT((ndo, \", Flags [%s]\",\n                   bittok2str(gre_flag_values,\"none\",flags)));\n\n\tlen -= 2;\n\tbp += 2;\n\n\tND_TCHECK2(*bp, 2);\n\tif (len < 2)\n\t\tgoto trunc;\n\tprot = EXTRACT_16BITS(bp);\n\tlen -= 2;\n\tbp += 2;\n\n\tif ((flags & GRE_CP) | (flags & GRE_RP)) {\n\t\tND_TCHECK2(*bp, 2);\n\t\tif (len < 2)\n\t\t\tgoto trunc;\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo, \", sum 0x%x\", EXTRACT_16BITS(bp)));\n\t\tbp += 2;\n\t\tlen -= 2;\n\n\t\tND_TCHECK2(*bp, 2);\n\t\tif (len < 2)\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo, \", off 0x%x\", EXTRACT_16BITS(bp)));\n\t\tbp += 2;\n\t\tlen -= 2;\n\t}\n\n\tif (flags & GRE_KP) {\n\t\tND_TCHECK2(*bp, 4);\n\t\tif (len < 4)\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo, \", key=0x%x\", EXTRACT_32BITS(bp)));\n\t\tbp += 4;\n\t\tlen -= 4;\n\t}\n\n\tif (flags & GRE_SP) {\n\t\tND_TCHECK2(*bp, 4);\n\t\tif (len < 4)\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo, \", seq %u\", EXTRACT_32BITS(bp)));\n\t\tbp += 4;\n\t\tlen -= 4;\n\t}\n\n\tif (flags & GRE_RP) {\n\t\tfor (;;) {\n\t\t\tuint16_t af;\n\t\t\tuint8_t sreoff;\n\t\t\tuint8_t srelen;\n\n\t\t\tND_TCHECK2(*bp, 4);\n\t\t\tif (len < 4)\n\t\t\t\tgoto trunc;\n\t\t\taf = EXTRACT_16BITS(bp);\n\t\t\tsreoff = *(bp + 2);\n\t\t\tsrelen = *(bp + 3);\n\t\t\tbp += 4;\n\t\t\tlen -= 4;\n\n\t\t\tif (af == 0 && srelen == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (!gre_sre_print(ndo, af, sreoff, srelen, bp, len))\n\t\t\t\tgoto trunc;\n\n\t\t\tif (len < srelen)\n\t\t\t\tgoto trunc;\n\t\t\tbp += srelen;\n\t\t\tlen -= srelen;\n\t\t}\n\t}\n\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \", proto %s (0x%04x)\",\n                   tok2str(ethertype_values,\"unknown\",prot),\n                   prot));\n\n        ND_PRINT((ndo, \", length %u\",length));\n\n        if (ndo->ndo_vflag < 1)\n            ND_PRINT((ndo, \": \")); /* put in a colon as protocol demarc */\n        else\n            ND_PRINT((ndo, \"\\n\\t\")); /* if verbose go multiline */\n\n\tswitch (prot) {\n\tcase ETHERTYPE_IP:\n\t        ip_print(ndo, bp, len);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, bp, len);\n\t\tbreak;\n\tcase ETHERTYPE_MPLS:\n\t\tmpls_print(ndo, bp, len);\n\t\tbreak;\n\tcase ETHERTYPE_IPX:\n\t\tipx_print(ndo, bp, len);\n\t\tbreak;\n\tcase ETHERTYPE_ATALK:\n \t\tatalk_print(ndo, bp, len);\n \t\tbreak;\n \tcase ETHERTYPE_GRE_ISO:\n\t\tisoclns_print(ndo, bp, len, ndo->ndo_snapend - bp);\n \t\tbreak;\n \tcase ETHERTYPE_TEB:\n \t\tether_print(ndo, bp, len, ndo->ndo_snapend - bp, NULL, NULL);\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"gre-proto-0x%x\", prot));\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void PluginObserver::OnBlockedOutdatedPlugin(const string16& name,\n                                             const GURL& update_url) {\n  tab_contents_->AddInfoBar(update_url.is_empty() ?\n      static_cast<InfoBarDelegate*>(new BlockedPluginInfoBarDelegate(\n          tab_contents(), name)) :\n      new OutdatedPluginInfoBarDelegate(tab_contents(), name, update_url));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int __netlink_remove_tap(struct netlink_tap *nt)\n{\n\tbool found = false;\n\tstruct netlink_tap *tmp;\n\n\tspin_lock(&netlink_tap_lock);\n\n\tlist_for_each_entry(tmp, &netlink_tap_all, list) {\n\t\tif (nt == tmp) {\n\t\t\tlist_del_rcu(&nt->list);\n\t\t\tfound = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpr_warn(\"__netlink_remove_tap: %p not found\\n\", nt);\nout:\n\tspin_unlock(&netlink_tap_lock);\n\n\tif (found && nt->module)\n\t\tmodule_put(nt->module);\n\n\treturn found ? 0 : -ENODEV;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool nfsd4_spo_must_allow(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct nfs4_op_map *allow = &cstate->clp->cl_spo_must_allow;\n\tu32 opiter;\n\n\tif (!cstate->minorversion)\n\t\treturn false;\n\n\tif (cstate->spo_must_allowed == true)\n\t\treturn true;\n\n\topiter = resp->opcnt;\n\twhile (opiter < argp->opcnt) {\n\t\tthis = &argp->ops[opiter++];\n\t\tif (test_bit(this->opnum, allow->u.longs) &&\n\t\t\tcstate->clp->cl_mach_cred &&\n\t\t\tnfsd4_mach_creds_match(cstate->clp, rqstp)) {\n\t\t\tcstate->spo_must_allowed = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\tcstate->spo_must_allowed = false;\n\treturn false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-404"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = update_begin_paint;\n\tupdate->EndPaint = update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap =\n\t    update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void drop_links(struct nameidata *nd)\n{\n\tint i = nd->depth;\n\twhile (i--) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tstruct inode *inode = last->inode;\n\t\tif (last->cookie && inode->i_op->put_link) {\n\t\t\tinode->i_op->put_link(inode, last->cookie);\n\t\t\tlast->cookie = NULL;\n\t\t}\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "produce_output()\n{\n\tchar\t*str;\n\tFILE\t*mailer;\n\tMyString subject,szTmp;\n\tsubject.sprintf(\"condor_preen results %s: %d old file%s found\", \n\t\tmy_full_hostname(), BadFiles->number(), \n\t\t(BadFiles->number() > 1)?\"s\":\"\");\n\n\tif( MailFlag ) {\n\t\tif( (mailer=email_open(PreenAdmin, subject.Value())) == NULL ) {\n\t\t\tEXCEPT( \"Can't do email_open(\\\"%s\\\", \\\"%s\\\")\\n\",PreenAdmin,subject.Value());\n\t\t}\n\t} else {\n\t\tmailer = stdout;\n        }\n \n        szTmp.sprintf(\"The condor_preen process has found the following stale condor files on <%s>:\\n\\n\",  get_local_hostname().Value());\n       dprintf(D_ALWAYS, szTmp.Value()); \n                \n        if( MailFlag ) {\n                fprintf( mailer, \"\\n\" );\n               fprintf( mailer, szTmp.Value());\n        }\n \n        for( BadFiles->rewind(); (str = BadFiles->next()); ) {\n                szTmp.sprintf(\"  %s\\n\", str);\n               dprintf(D_ALWAYS, szTmp.Value() );\n               fprintf( mailer, szTmp.Value() );\n        }\n \n        if( MailFlag ) {\n\t\tconst char *explanation = \"\\n\\nWhat is condor_preen?\\n\\n\"\n\"The condor_preen tool examines the directories belonging to Condor, and\\n\"\n\"removes extraneous files and directories which may be left over from Condor\\n\"\n\"processes which terminated abnormally either due to internal errors or a\\n\"\n\"system crash.  The directories checked are the LOG, EXECUTE, and SPOOL\\n\"\n\"directories as defined in the Condor configuration files.  The condor_preen\\n\"\n\"tool is intended to be run as user root (or user condor) periodically as a\\n\"\n\"backup method to ensure reasonable file system cleanliness in the face of\\n\"\n\"errors. This is done automatically by default by the condor_master daemon.\\n\"\n\"It may also be explicitly invoked on an as needed basis.\\n\\n\"\n\"See the Condor manual section on condor_preen for more details.\\n\";\n\n\t\tfprintf( mailer, \"%s\\n\", explanation );\n\t\temail_close( mailer );\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-134"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void prl_list_destroy_rcu(struct rcu_head *head)\n{\n\tstruct ip_tunnel_prl_entry *p, *n;\n\n\tp = container_of(head, struct ip_tunnel_prl_entry, rcu_head);\n\tdo {\n\t\tn = p->next;\n\t\tkfree(p);\n\t\tp = n;\n\t} while (p);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; ++i) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) {\n     if (buffer == 0) {\n         return NULL;\n     }\n Mutex::Autolock autoLock(mBufferIDLock);\n ssize_t index = mBufferIDToBufferHeader.indexOfKey(buffer);\n if (index < 0) {\n\n         CLOGW(\"findBufferHeader: buffer %u not found\", buffer);\n         return NULL;\n     }\n    return mBufferIDToBufferHeader.valueAt(index);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "dhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n \n     i = 0;\n     while (i < length) {\n         tlv = cp + i;\n         type = EXTRACT_16BITS(tlv);\n         optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n \n         ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n         ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n \n         switch (type) {\n             case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n\n        i += 4 + optlen;\n    }\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void toggle_os_keylockstates(int fd, int changedlockstates)\n{\n    BTIF_TRACE_EVENT(\"%s: fd = %d, changedlockstates = 0x%x\",\n        __FUNCTION__, fd, changedlockstates);\n    UINT8 hidreport[9];\n int reportIndex;\n    memset(hidreport,0,9);\n    hidreport[0]=1;\n    reportIndex=4;\n\n if (changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK) {\n        BTIF_TRACE_DEBUG(\"%s Setting CAPSLOCK\", __FUNCTION__);\n        hidreport[reportIndex++] = (UINT8)HID_REPORT_CAPSLOCK;\n }\n\n if (changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK) {\n        BTIF_TRACE_DEBUG(\"%s Setting NUMLOCK\", __FUNCTION__);\n        hidreport[reportIndex++] = (UINT8)HID_REPORT_NUMLOCK;\n }\n\n if (changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK) {\n        BTIF_TRACE_DEBUG(\"%s Setting SCROLLLOCK\", __FUNCTION__);\n        hidreport[reportIndex++] = (UINT8) HID_REPORT_SCROLLLOCK;\n }\n\n     BTIF_TRACE_DEBUG(\"Writing hidreport #1 to os: \"\\\n \"%s:  %x %x %x\", __FUNCTION__,\n         hidreport[0], hidreport[1], hidreport[2]);\n    BTIF_TRACE_DEBUG(\"%s:  %x %x %x\", __FUNCTION__,\n         hidreport[3], hidreport[4], hidreport[5]);\n\n     BTIF_TRACE_DEBUG(\"%s:  %x %x %x\", __FUNCTION__,\n          hidreport[6], hidreport[7], hidreport[8]);\n     bta_hh_co_write(fd , hidreport, sizeof(hidreport));\n    usleep(200000);\n     memset(hidreport,0,9);\n     hidreport[0]=1;\n     BTIF_TRACE_DEBUG(\"Writing hidreport #2 to os: \"\\\n \"%s:  %x %x %x\", __FUNCTION__,\n         hidreport[0], hidreport[1], hidreport[2]);\n    BTIF_TRACE_DEBUG(\"%s:  %x %x %x\", __FUNCTION__,\n         hidreport[3], hidreport[4], hidreport[5]);\n    BTIF_TRACE_DEBUG(\"%s:  %x %x %x \", __FUNCTION__,\n         hidreport[6], hidreport[7], hidreport[8]);\n    bta_hh_co_write(fd , hidreport, sizeof(hidreport));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n \n \tfor (i = 0; i < bin->nsects; i++) {\n \t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n \t\t\t\t\tsym = j;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n \t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n \t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "pimv1_join_prune_print(netdissect_options *ndo,\n                       register const u_char *bp, register u_int len)\n{\n\tint ngroups, njoin, nprune;\n\tint njp;\n\n\t/* If it's a single group and a single source, use 1-line output. */\n\tif (ND_TTEST2(bp[0], 30) && bp[11] == 1 &&\n\t    ((njoin = EXTRACT_16BITS(&bp[20])) + EXTRACT_16BITS(&bp[22])) == 1) {\n\t\tint hold;\n\n\t\tND_PRINT((ndo, \" RPF %s \", ipaddr_string(ndo, bp)));\n\t\thold = EXTRACT_16BITS(&bp[6]);\n\t\tif (hold != 180) {\n\t\t\tND_PRINT((ndo, \"Hold \"));\n\t\t\tunsigned_relts_print(ndo, hold);\n\t\t}\n\t\tND_PRINT((ndo, \"%s (%s/%d, %s\", njoin ? \"Join\" : \"Prune\",\n\t\tipaddr_string(ndo, &bp[26]), bp[25] & 0x3f,\n\t\tipaddr_string(ndo, &bp[12])));\n\t\tif (EXTRACT_32BITS(&bp[16]) != 0xffffffff)\n\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[16])));\n\t\tND_PRINT((ndo, \") %s%s %s\",\n\t\t    (bp[24] & 0x01) ? \"Sparse\" : \"Dense\",\n\t\t    (bp[25] & 0x80) ? \" WC\" : \"\",\n\t\t    (bp[25] & 0x40) ? \"RP\" : \"SPT\"));\n \t\treturn;\n \t}\n \n \tND_TCHECK2(bp[0], sizeof(struct in_addr));\n \tif (ndo->ndo_vflag > 1)\n \t\tND_PRINT((ndo, \"\\n\"));\n \tND_PRINT((ndo, \" Upstream Nbr: %s\", ipaddr_string(ndo, bp)));\n\tND_TCHECK2(bp[6], 2);\n \tif (ndo->ndo_vflag > 1)\n \t\tND_PRINT((ndo, \"\\n\"));\n \tND_PRINT((ndo, \" Hold time: \"));\n\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[6]));\n \tif (ndo->ndo_vflag < 2)\n \t\treturn;\n\tbp += 8;\n\tlen -= 8;\n \n \tND_TCHECK2(bp[0], 4);\n \tngroups = bp[3];\n \tbp += 4;\n\tlen -= 4;\n\twhile (ngroups--) {\n\t\t/*\n \t\t * XXX - does the address have length \"addrlen\" and the\n \t\t * mask length \"maddrlen\"?\n \t\t */\n \t\tND_TCHECK2(bp[0], sizeof(struct in_addr));\n \t\tND_PRINT((ndo, \"\\n\\tGroup: %s\", ipaddr_string(ndo, bp)));\n\t\tND_TCHECK2(bp[4], sizeof(struct in_addr));\n\t\tif (EXTRACT_32BITS(&bp[4]) != 0xffffffff)\n\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[4])));\n\t\tND_TCHECK2(bp[8], 4);\n\t\tnjoin = EXTRACT_16BITS(&bp[8]);\n\t\tnprune = EXTRACT_16BITS(&bp[10]);\n \t\tND_PRINT((ndo, \" joined: %d pruned: %d\", njoin, nprune));\n\t\tbp += 12;\n\t\tlen -= 12;\n \t\tfor (njp = 0; njp < (njoin + nprune); njp++) {\n \t\t\tconst char *type;\n \n \t\t\tif (njp < njoin)\n \t\t\t\ttype = \"Join \";\n \t\t\telse\n \t\t\t\ttype = \"Prune\";\n \t\t\tND_TCHECK2(bp[0], 6);\n \t\t\tND_PRINT((ndo, \"\\n\\t%s %s%s%s%s/%d\", type,\n \t\t\t    (bp[0] & 0x01) ? \"Sparse \" : \"Dense \",\n \t\t\t    (bp[1] & 0x80) ? \"WC \" : \"\",\n \t\t\t    (bp[1] & 0x40) ? \"RP \" : \"SPT \",\n\t\t\tipaddr_string(ndo, &bp[2]), bp[1] & 0x3f));\n \t\t\tbp += 6;\n \t\t\tlen -= 6;\n \t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n\treturn;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void show_error_as_msgbox(const char *msg)\n{\n    GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(g_wnd_assistant),\n                GTK_DIALOG_DESTROY_WITH_PARENT,\n                GTK_MESSAGE_WARNING,\n                GTK_BUTTONS_CLOSE,\n                \"%s\", msg\n    );\n    gtk_dialog_run(GTK_DIALOG(dialog));\n    gtk_widget_destroy(dialog);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CreatePersistentHistogramAllocator() {\n    allocator_memory_.reset(new char[kAllocatorMemorySize]);\n \n     GlobalHistogramAllocator::ReleaseForTesting();\n     memset(allocator_memory_.get(), 0, kAllocatorMemorySize);\n    GlobalHistogramAllocator::GetCreateHistogramResultHistogram();\n     GlobalHistogramAllocator::CreateWithPersistentMemory(\n         allocator_memory_.get(), kAllocatorMemorySize, 0, 0,\n         \"PersistentHistogramAllocatorTest\");\n    allocator_ = GlobalHistogramAllocator::Get()->memory_allocator();\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static const char *set_override(cmd_parms *cmd, void *d_, const char *l)\n{\n    core_dir_config *d = d_;\n    char *w;\n    char *k, *v;\n    const char *err;\n\n    /* Throw a warning if we're in <Location> or <Files> */\n    if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00114)\n                     \"Useless use of AllowOverride in line %d of %s.\",\n                     cmd->directive->line_num, cmd->directive->filename);\n    }\n    if ((err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS)) != NULL)\n        return err;\n\n    d->override = OR_NONE;\n    while (l[0]) {\n        w = ap_getword_conf(cmd->temp_pool, &l);\n\n        k = w;\n        v = strchr(k, '=');\n        if (v) {\n                *v++ = '\\0';\n        }\n\n        if (!ap_cstr_casecmp(w, \"Limit\")) {\n            d->override |= OR_LIMIT;\n        }\n        else if (!ap_cstr_casecmp(k, \"Options\")) {\n            d->override |= OR_OPTIONS;\n            if (v)\n                set_allow_opts(cmd, &(d->override_opts), v);\n            else\n                d->override_opts = OPT_ALL;\n        }\n        else if (!ap_cstr_casecmp(w, \"FileInfo\")) {\n            d->override |= OR_FILEINFO;\n        }\n        else if (!ap_cstr_casecmp(w, \"AuthConfig\")) {\n            d->override |= OR_AUTHCFG;\n        }\n        else if (!ap_cstr_casecmp(w, \"Indexes\")) {\n            d->override |= OR_INDEXES;\n        }\n        else if (!ap_cstr_casecmp(w, \"Nonfatal\")) {\n            if (!ap_cstr_casecmp(v, \"Override\")) {\n                d->override |= NONFATAL_OVERRIDE;\n            }\n            else if (!ap_cstr_casecmp(v, \"Unknown\")) {\n                d->override |= NONFATAL_UNKNOWN;\n            }\n            else if (!ap_cstr_casecmp(v, \"All\")) {\n                d->override |= NONFATAL_ALL;\n            }\n        }\n        else if (!ap_cstr_casecmp(w, \"None\")) {\n            d->override = OR_NONE;\n        }\n        else if (!ap_cstr_casecmp(w, \"All\")) {\n            d->override = OR_ALL;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal override option \", w, NULL);\n        }\n\n        d->override &= ~OR_UNSET;\n    }\n\n    return NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,\n                const mbedtls_mpi *d, const unsigned char *buf, size_t blen,\n                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    ECDSA_VALIDATE_RET( grp   != NULL );\n    ECDSA_VALIDATE_RET( r     != NULL );\n    ECDSA_VALIDATE_RET( s     != NULL );\n    ECDSA_VALIDATE_RET( d     != NULL );\n     ECDSA_VALIDATE_RET( f_rng != NULL );\n     ECDSA_VALIDATE_RET( buf   != NULL || blen == 0 );\n \n     return( ecdsa_sign_restartable( grp, r, s, d, buf, blen,\n                                    f_rng, p_rng, NULL ) );\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void AutomationProvider::Copy(int tab_handle) {\n  RenderViewHost* view = GetViewForTab(tab_handle);\n  if (!view) {\n    NOTREACHED();\n    return;\n  }\n\n  view->Copy();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void windowAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(DOMWindow*, cppValue, toDOMWindow(jsValue, info.GetIsolate()));\n    imp->setWindowAttribute(WTF::getPtr(cppValue));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint32_t *ptr = (const uint32_t *)dat;\n \n \tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n \t\tND_PRINT((ndo, \"A\"));\n \t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n \t\tgoto out;\n \n \tdown_write(&mm->mmap_sem);\n \tvma = find_vma_prev(mm, start, &prev);\n \tif (!vma)\n \t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "std::unique_ptr<HistogramBase> PersistentHistogramAllocator::CreateHistogram(\n     PersistentHistogramData* histogram_data_ptr) {\n   if (!histogram_data_ptr) {\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_INVALID_METADATA_POINTER);\n     NOTREACHED();\n     return nullptr;\n   }\n\n  if (histogram_data_ptr->histogram_type == SPARSE_HISTOGRAM) {\n    std::unique_ptr<HistogramBase> histogram =\n        SparseHistogram::PersistentCreate(this, histogram_data_ptr->name,\n                                          &histogram_data_ptr->samples_metadata,\n                                           &histogram_data_ptr->logged_metadata);\n     DCHECK(histogram);\n     histogram->SetFlags(histogram_data_ptr->flags);\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_SUCCESS);\n     return histogram;\n   }\n \n  int32_t histogram_type = histogram_data_ptr->histogram_type;\n  int32_t histogram_flags = histogram_data_ptr->flags;\n  int32_t histogram_minimum = histogram_data_ptr->minimum;\n  int32_t histogram_maximum = histogram_data_ptr->maximum;\n  uint32_t histogram_bucket_count = histogram_data_ptr->bucket_count;\n  uint32_t histogram_ranges_ref = histogram_data_ptr->ranges_ref;\n  uint32_t histogram_ranges_checksum = histogram_data_ptr->ranges_checksum;\n\n  HistogramBase::Sample* ranges_data =\n      memory_allocator_->GetAsArray<HistogramBase::Sample>(\n          histogram_ranges_ref, kTypeIdRangesArray,\n          PersistentMemoryAllocator::kSizeAny);\n\n  const uint32_t max_buckets =\n      std::numeric_limits<uint32_t>::max() / sizeof(HistogramBase::Sample);\n  size_t required_bytes =\n      (histogram_bucket_count + 1) * sizeof(HistogramBase::Sample);\n  size_t allocated_bytes =\n      memory_allocator_->GetAllocSize(histogram_ranges_ref);\n   if (!ranges_data || histogram_bucket_count < 2 ||\n       histogram_bucket_count >= max_buckets ||\n       allocated_bytes < required_bytes) {\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_INVALID_RANGES_ARRAY);\n     NOTREACHED();\n     return nullptr;\n   }\n \n   std::unique_ptr<const BucketRanges> created_ranges = CreateRangesFromData(\n       ranges_data, histogram_ranges_checksum, histogram_bucket_count + 1);\n   if (!created_ranges) {\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_INVALID_RANGES_ARRAY);\n     NOTREACHED();\n     return nullptr;\n   }\n  const BucketRanges* ranges =\n      StatisticsRecorder::RegisterOrDeleteDuplicateRanges(\n          created_ranges.release());\n\n  size_t counts_bytes = CalculateRequiredCountsBytes(histogram_bucket_count);\n  PersistentMemoryAllocator::Reference counts_ref =\n      subtle::Acquire_Load(&histogram_data_ptr->counts_ref);\n   if (counts_bytes == 0 ||\n       (counts_ref != 0 &&\n        memory_allocator_->GetAllocSize(counts_ref) < counts_bytes)) {\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_INVALID_COUNTS_ARRAY);\n     NOTREACHED();\n     return nullptr;\n   }\n\n  DelayedPersistentAllocation counts_data(memory_allocator_.get(),\n                                          &histogram_data_ptr->counts_ref,\n                                          kTypeIdCountsArray, counts_bytes, 0);\n\n  DelayedPersistentAllocation logged_data(\n      memory_allocator_.get(), &histogram_data_ptr->counts_ref,\n      kTypeIdCountsArray, counts_bytes, counts_bytes / 2,\n      /*make_iterable=*/false);\n\n  const char* name = histogram_data_ptr->name;\n  std::unique_ptr<HistogramBase> histogram;\n  switch (histogram_type) {\n    case HISTOGRAM:\n      histogram = Histogram::PersistentCreate(\n          name, histogram_minimum, histogram_maximum, ranges, counts_data,\n          logged_data, &histogram_data_ptr->samples_metadata,\n          &histogram_data_ptr->logged_metadata);\n      DCHECK(histogram);\n      break;\n    case LINEAR_HISTOGRAM:\n      histogram = LinearHistogram::PersistentCreate(\n          name, histogram_minimum, histogram_maximum, ranges, counts_data,\n          logged_data, &histogram_data_ptr->samples_metadata,\n          &histogram_data_ptr->logged_metadata);\n      DCHECK(histogram);\n      break;\n    case BOOLEAN_HISTOGRAM:\n      histogram = BooleanHistogram::PersistentCreate(\n          name, ranges, counts_data, logged_data,\n          &histogram_data_ptr->samples_metadata,\n          &histogram_data_ptr->logged_metadata);\n      DCHECK(histogram);\n      break;\n    case CUSTOM_HISTOGRAM:\n      histogram = CustomHistogram::PersistentCreate(\n          name, ranges, counts_data, logged_data,\n          &histogram_data_ptr->samples_metadata,\n          &histogram_data_ptr->logged_metadata);\n      DCHECK(histogram);\n      break;\n    default:\n      NOTREACHED();\n  }\n\n   if (histogram) {\n     DCHECK_EQ(histogram_type, histogram->GetHistogramType());\n     histogram->SetFlags(histogram_flags);\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_SUCCESS);\n  } else {\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_UNKNOWN_TYPE);\n   }\n \n   return histogram;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "u32 gf_sys_clock()\n{\n\tstruct timeval now;\n\tgettimeofday(&now, NULL);\n\treturn (u32) ( ( (now.tv_sec)*1000 + (now.tv_usec) / 1000) - sys_start_time );\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "png_write_destroy(png_structp png_ptr)\n{\n#ifdef PNG_SETJMP_SUPPORTED\n   jmp_buf tmp_jmp; /* Save jump buffer */\n#endif\n   png_error_ptr error_fn;\n   png_error_ptr warning_fn;\n   png_voidp error_ptr;\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_free_ptr free_fn;\n#endif\n\n   png_debug(1, \"in png_write_destroy\");\n\n   /* Free any memory zlib uses */\n   deflateEnd(&png_ptr->zstream);\n\n   /* Free our memory.  png_free checks NULL for us. */\n   png_free(png_ptr, png_ptr->zbuf);\n   png_free(png_ptr, png_ptr->row_buf);\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n   png_free(png_ptr, png_ptr->prev_row);\n   png_free(png_ptr, png_ptr->sub_row);\n   png_free(png_ptr, png_ptr->up_row);\n   png_free(png_ptr, png_ptr->avg_row);\n   png_free(png_ptr, png_ptr->paeth_row);\n#endif\n\n#ifdef PNG_TIME_RFC1123_SUPPORTED\n    png_free(png_ptr, png_ptr->time_buffer);\n #endif\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n   png_free(png_ptr, png_ptr->prev_filters);\n   png_free(png_ptr, png_ptr->filter_weights);\n   png_free(png_ptr, png_ptr->inv_filter_weights);\n   png_free(png_ptr, png_ptr->filter_costs);\n   png_free(png_ptr, png_ptr->inv_filter_costs);\n#endif\n #ifdef PNG_SETJMP_SUPPORTED\n    /* Reset structure */\n    png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));\n#endif\n\n   error_fn = png_ptr->error_fn;\n   warning_fn = png_ptr->warning_fn;\n   error_ptr = png_ptr->error_ptr;\n#ifdef PNG_USER_MEM_SUPPORTED\n   free_fn = png_ptr->free_fn;\n#endif\n\n   png_memset(png_ptr, 0, png_sizeof(png_struct));\n\n   png_ptr->error_fn = error_fn;\n   png_ptr->warning_fn = warning_fn;\n   png_ptr->error_ptr = error_ptr;\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_ptr->free_fn = free_fn;\n#endif\n\n#ifdef PNG_SETJMP_SUPPORTED\n   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "std::string RetrievalMethodToString(\n    const WebElementDescriptor::RetrievalMethod& method) {\n  switch (method) {\n    case WebElementDescriptor::CSS_SELECTOR:\n      return \"CSS_SELECTOR\";\n    case WebElementDescriptor::ID:\n      return \"ID\";\n    case WebElementDescriptor::NONE:\n      return \"NONE\";\n  }\n  NOTREACHED();\n  return \"UNKNOWN\";\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "JBIG2Bitmap::JBIG2Bitmap(Guint segNumA, JBIG2Bitmap *bitmap):\n  JBIG2Segment(segNumA)\n{\n  w = bitmap->w;\n  h = bitmap->h;\n  line = bitmap->line;\n\n  if (w <= 0 || h <= 0 || line <= 0 || h >= (INT_MAX - 1) / line) {\n    error(-1, \"invalid width/height\");\n    data = NULL;\n     return;\n   }\n  data = (Guchar *)gmalloc(h * line + 1);\n   memcpy(data, bitmap->data, h * line);\n   data[h * line] = 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "hstore_from_array(PG_FUNCTION_ARGS)\n{\n\tArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);\n\tint\t\t\tndims = ARR_NDIM(in_array);\n\tint\t\t\tcount;\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tDatum\t   *in_datums;\n\tbool\t   *in_nulls;\n\tint\t\t\tin_count;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(in_array) == TEXTOID);\n\n\tswitch (ndims)\n\t{\n\t\tcase 0:\n\t\t\tout = hstorePairs(NULL, 0, 0);\n\t\t\tPG_RETURN_POINTER(out);\n\n\t\tcase 1:\n\t\t\tif ((ARR_DIMS(in_array)[0]) % 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\")));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif ((ARR_DIMS(in_array)[1]) != 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\t}\n\n\tdeconstruct_array(in_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &in_datums, &in_nulls, &in_count);\n \n \tcount = in_count / 2;\n \n \tpairs = palloc(count * sizeof(Pairs));\n \n \tfor (i = 0; i < count; ++i)\n\t{\n\t\tif (in_nulls[i * 2])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tif (in_nulls[i * 2 + 1])\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(in_datums[i * 2]);\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));\n\t\t\tpairs[i].vallen = 4;\n\t\t\tpairs[i].isnull = true;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(in_datums[i * 2]);\n\t\t\tpairs[i].val = VARDATA_ANY(in_datums[i * 2 + 1]);\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));\n\t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(in_datums[i * 2 + 1]));\n\t\t\tpairs[i].isnull = false;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t}\n\n\tcount = hstoreUniquePairs(pairs, count, &buflen);\n\n\tout = hstorePairs(pairs, count, buflen);\n\n\tPG_RETURN_POINTER(out);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "FloatSize LocalFrame::ResizePageRectsKeepingRatio(\n    const FloatSize& original_size,\n    const FloatSize& expected_size) const {\n  auto* layout_object = ContentLayoutObject();\n  if (!layout_object)\n    return FloatSize();\n\n  bool is_horizontal = layout_object->StyleRef().IsHorizontalWritingMode();\n  float width = original_size.Width();\n  float height = original_size.Height();\n  if (!is_horizontal)\n    std::swap(width, height);\n  DCHECK_GT(fabs(width), std::numeric_limits<float>::epsilon());\n  float ratio = height / width;\n\n  float result_width =\n      floorf(is_horizontal ? expected_size.Width() : expected_size.Height());\n  float result_height = floorf(result_width * ratio);\n  if (!is_horizontal)\n    std::swap(result_width, result_height);\n  return FloatSize(result_width, result_height);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-285"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "float AudioParam::finalValue()\n {\n    float value;\n     calculateFinalValues(&value, 1, false);\n     return value;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "DOMFileSystemSync* WorkerGlobalScopeFileSystem::webkitRequestFileSystemSync(WorkerGlobalScope& worker, int type, long long size, ExceptionState& exceptionState)\n{\n    ExecutionContext* secureContext = worker.executionContext();\n    if (!secureContext->securityOrigin()->canAccessFileSystem()) {\n        exceptionState.throwSecurityError(FileError::securityErrorMessage);\n        return 0;\n    }\n\n    FileSystemType fileSystemType = static_cast<FileSystemType>(type);\n    if (!DOMFileSystemBase::isValidType(fileSystemType)) {\n        exceptionState.throwDOMException(InvalidModificationError, \"the type must be TEMPORARY or PERSISTENT.\");\n         return 0;\n     }\n \n    RefPtr<FileSystemSyncCallbackHelper> helper = FileSystemSyncCallbackHelper::create();\n     OwnPtr<AsyncFileSystemCallbacks> callbacks = FileSystemCallbacks::create(helper->successCallback(), helper->errorCallback(), &worker, fileSystemType);\n     callbacks->setShouldBlockUntilCompletion(true);\n \n    LocalFileSystem::from(worker)->requestFileSystem(&worker, fileSystemType, size, callbacks.release());\n    return helper->getResult(exceptionState);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void gx_ttfExport__SetWidth(ttfExport *self, FloatPoint *p)\n{\n    gx_ttfExport *e = (gx_ttfExport *)self;\n\n    e->w.x = float2fixed(p->x);\n    e->w.y = float2fixed(p->y);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long VideoTrack::Seek(long long time_ns, const BlockEntry*& pResult) const {\n const long status = GetFirst(pResult);\n\n if (status < 0) // buffer underflow, etc\n return status;\n\n  assert(pResult);\n\n if (pResult->EOS())\n return 0;\n\n const Cluster* pCluster = pResult->GetCluster();\n  assert(pCluster);\n  assert(pCluster->GetIndex() >= 0);\n\n if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n return 0;\n\n Cluster** const clusters = m_pSegment->m_clusters;\n  assert(clusters);\n\n const long count = m_pSegment->GetCount(); // loaded only, not pre-loaded\n  assert(count > 0);\n\n Cluster** const i = clusters + pCluster->GetIndex();\n  assert(i);\n  assert(*i == pCluster);\n  assert(pCluster->GetTime() <= time_ns);\n\n Cluster** const j = clusters + count;\n\n Cluster** lo = i;\n Cluster** hi = j;\n\n while (lo < hi) {\n\n Cluster** const mid = lo + (hi - lo) / 2;\n    assert(mid < hi);\n\n    pCluster = *mid;\n    assert(pCluster);\n    assert(pCluster->GetIndex() >= 0);\n    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n\n const long long t = pCluster->GetTime();\n\n if (t <= time_ns)\n      lo = mid + 1;\n else\n      hi = mid;\n\n    assert(lo <= hi);\n }\n\n  assert(lo == hi);\n  assert(lo > i);\n  assert(lo <= j);\n\n  pCluster = *--lo;\n  assert(pCluster);\n  assert(pCluster->GetTime() <= time_ns);\n\n  pResult = pCluster->GetEntry(this, time_ns);\n\n if ((pResult != 0) && !pResult->EOS()) // found a keyframe\n return 0;\n\n while (lo != i) {\n    pCluster = *--lo;\n\n     assert(pCluster);\n     assert(pCluster->GetTime() <= time_ns);\n \n#if 0\n        pResult = pCluster->GetMaxKey(this);\n#else\n     pResult = pCluster->GetEntry(this, time_ns);\n#endif\n \n     if ((pResult != 0) && !pResult->EOS())\n       return 0;\n }\n\n\n  pResult = GetEOS();\n return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "nfssvc_encode_entry(void *ccdv, const char *name,\n\t\t    int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd_readdirres *cd = container_of(ccd, struct nfsd_readdirres, common);\n\t__be32\t*p = cd->buffer;\n\tint\tbuflen, slen;\n\n\t/*\n\tdprintk(\"nfsd: entry(%.*s off %ld ino %ld)\\n\",\n\t\t\tnamlen, name, offset, ino);\n\t */\n\n\tif (offset > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\tif (cd->offset)\n\t\t*cd->offset = htonl(offset);\n\n\t/* truncate filename */\n\tnamlen = min(namlen, NFS2_MAXNAMLEN);\n\tslen = XDR_QUADLEN(namlen);\n\n\tif ((buflen = cd->buflen - slen - 4) < 0) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\tif (ino > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\t*p++ = xdr_one;\t\t\t\t/* mark entry present */\n\t*p++ = htonl((u32) ino);\t\t/* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\tcd->offset = p;\t\t\t/* remember pointer */\n\t*p++ = htonl(~0U);\t\t/* offset of next entry */\n\n\tcd->buflen = buflen;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-404"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int jpc_pi_nextpcrl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tint xstep;\n\tint ystep;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->xstep = 0;\n\t\tpi->ystep = 0;\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n \t\t  ++compno, ++picomp) {\n \t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n \t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\t\txstep = picomp->hsamp * (1 <<\n\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls -\n\t\t\t\t  rlvlno - 1));\n\t\t\t\tystep = picomp->vsamp * (1 <<\n\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls -\n\t\t\t\t  rlvlno - 1));\n\t\t\t\tpi->xstep = (!pi->xstep) ? xstep :\n\t\t\t\t  JAS_MIN(pi->xstep, xstep);\n\t\t\t\tpi->ystep = (!pi->ystep) ? ystep :\n\t\t\t\t  JAS_MIN(pi->ystep, ystep);\n \t\t\t}\n \t\t}\n \t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y += pi->ystep -\n\t  (pi->y % pi->ystep)) {\n\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x += pi->xstep -\n\t\t  (pi->x % pi->xstep)) {\n\t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps\n\t\t\t  && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,\n\t\t\t  ++pi->picomp) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls &&\n\t\t\t\t  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno,\n\t\t\t\t  ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n \t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n \t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n \t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n \t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n \t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n \t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RenderFrameImpl::PrepareFrameForCommit(\n    const GURL& url,\n    const RequestNavigationParams& request_params) {\n  browser_side_navigation_pending_ = false;\n  browser_side_navigation_pending_url_ = GURL();\n  sync_navigation_callback_.Cancel();\n\n  GetContentClient()->SetActiveURL(\n      url, frame_->Top()->GetSecurityOrigin().ToString().Utf8());\n\n  RenderFrameImpl::PrepareRenderViewForNavigation(url, request_params);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadCMYKImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *canvas_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  SetImageColorspace(image,CMYKColorspace);\n  if (image_info->interlace != PartitionInterlace)\n    {\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Create virtual canvas to support cropping (i.e. image.cmyk[100x100+10+20]).\n  */\n  canvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,\n    exception);\n  (void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod);\n  quantum_info=AcquireQuantumInfo(image_info,canvas_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels=GetQuantumPixels(quantum_info);\n  quantum_type=CMYKQuantum;\n  if (LocaleCompare(image_info->magick,\"CMYKA\") == 0)\n    {\n      quantum_type=CMYKAQuantum;\n      image->matte=MagickTrue;\n    }\n  if (image_info->number_scenes != 0)\n    while (image->scene < image_info->scene)\n    {\n      /*\n        Skip to next image.\n      */\n      image->scene++;\n      length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          break;\n      }\n    }\n  count=0;\n  length=0;\n  scene=0;\n  do\n  {\n    /*\n      Read pixels to virtual canvas image then push to image.\n    */\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     SetImageColorspace(image,CMYKColorspace);\n     switch (image_info->interlace)\n     {\n      case NoInterlace:\n      default:\n      {\n        /*\n          No interlacing:  CMYKCMYKCMYKCMYKCMYKCMYK...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n            count=ReadBlob(image,length,pixels);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const IndexPacket\n            *restrict canvas_indexes;\n\n          register const PixelPacket\n            *restrict p;\n\n          register IndexPacket\n            *restrict indexes;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=QueueAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              canvas_indexes=GetVirtualIndexQueue(canvas_image);\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,GetPixelRed(p));\n                SetPixelGreen(q,GetPixelGreen(p));\n                SetPixelBlue(q,GetPixelBlue(p));\n                SetPixelBlack(indexes+x,GetPixelBlack(\n                  canvas_indexes+image->extract_info.x+x));\n                SetPixelOpacity(q,OpaqueOpacity);\n                if (image->matte != MagickFalse)\n                  SetPixelOpacity(q,GetPixelOpacity(p));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          count=ReadBlob(image,length,pixels);\n        }\n        break;\n      }\n      case LineInterlace:\n      {\n        static QuantumType\n          quantum_types[5] =\n          {\n            CyanQuantum,\n            MagentaQuantum,\n            YellowQuantum,\n            BlackQuantum,\n            OpacityQuantum\n          };\n\n        /*\n          Line interlacing:  CCC...MMM...YYY...KKK...CCC...MMM...YYY...KKK...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\n            count=ReadBlob(image,length,pixels);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const IndexPacket\n            *restrict canvas_indexes;\n\n          register const PixelPacket\n            *restrict p;\n\n          register IndexPacket\n            *restrict indexes;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          for (i=0; i < (image->matte != MagickFalse ? 5 : 4); i++)\n          {\n            quantum_type=quantum_types[i];\n            q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n              exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n              quantum_info,quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n              break;\n            if (((y-image->extract_info.y) >= 0) &&\n                ((y-image->extract_info.y) < (ssize_t) image->rows))\n              {\n                p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,\n                  0,canvas_image->columns,1,exception);\n                q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                  image->columns,1,exception);\n                if ((p == (const PixelPacket *) NULL) ||\n                    (q == (PixelPacket *) NULL))\n                  break;\n                canvas_indexes=GetVirtualIndexQueue(canvas_image);\n                indexes=GetAuthenticIndexQueue(image);\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  switch (quantum_type)\n                  {\n                    case CyanQuantum:\n                    {\n                      SetPixelCyan(q,GetPixelCyan(p));\n                      break;\n                    }\n                    case MagentaQuantum:\n                    {\n                      SetPixelMagenta(q,GetPixelMagenta(p));\n                      break;\n                    }\n                    case YellowQuantum:\n                    {\n                      SetPixelYellow(q,GetPixelYellow(p));\n                      break;\n                    }\n                    case BlackQuantum:\n                    {\n                      SetPixelIndex(indexes+x,GetPixelIndex(\n                        canvas_indexes+image->extract_info.x+x));\n                      break;\n                    }\n                    case OpacityQuantum:\n                    {\n                      SetPixelOpacity(q,GetPixelOpacity(p));\n                      break;\n                    }\n                    default:\n                      break;\n                  }\n                  p++;\n                  q++;\n                }\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            count=ReadBlob(image,length,pixels);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PlaneInterlace:\n      {\n        /*\n          Plane interlacing:  CCCCCC...MMMMMM...YYYYYY...KKKKKK...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\n            count=ReadBlob(image,length,pixels);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const PixelPacket\n            *restrict p;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,CyanQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,GetPixelRed(p));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          count=ReadBlob(image,length,pixels);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,1,6);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const PixelPacket\n            *restrict p;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,MagentaQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelGreen(q,GetPixelGreen(p));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          count=ReadBlob(image,length,pixels);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,2,6);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const PixelPacket\n            *restrict p;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,YellowQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(q,GetPixelBlue(p));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          count=ReadBlob(image,length,pixels);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,3,6);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const IndexPacket\n            *restrict canvas_indexes;\n\n          register const PixelPacket\n            *restrict p;\n\n          register IndexPacket\n            *restrict indexes;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,BlackQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              canvas_indexes=GetVirtualIndexQueue(canvas_image);\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(indexes+x,GetPixelIndex(\n                  canvas_indexes+image->extract_info.x+x));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          count=ReadBlob(image,length,pixels);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,4,6);\n            if (status == MagickFalse)\n              break;\n          }\n        if (image->matte != MagickFalse)\n          {\n            for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            {\n              register const PixelPacket\n                *restrict p;\n\n              register PixelPacket\n                *restrict q;\n\n              register ssize_t\n                x;\n\n              if (count != (ssize_t) length)\n                {\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n              q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n                exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n                quantum_info,AlphaQuantum,pixels,exception);\n              if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n                break;\n              if (((y-image->extract_info.y) >= 0) &&\n                  ((y-image->extract_info.y) < (ssize_t) image->rows))\n                {\n                  p=GetVirtualPixels(canvas_image,\n                    canvas_image->extract_info.x,0,canvas_image->columns,1,\n                    exception);\n                  q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                    image->columns,1,exception);\n                  if ((p == (const PixelPacket *) NULL) ||\n                      (q == (PixelPacket *) NULL))\n                    break;\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    SetPixelOpacity(q,GetPixelOpacity(p));\n                    p++;\n                    q++;\n                  }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n              count=ReadBlob(image,length,pixels);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,5,6);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,6,6);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PartitionInterlace:\n      {\n        /*\n          Partition interlacing:  CCCCCC..., MMMMMM..., YYYYYY..., KKKKKK...\n        */\n        AppendImageFormat(\"C\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n        length=GetQuantumExtent(canvas_image,quantum_info,CyanQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            if (ReadBlob(image,length,pixels) != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n        count=ReadBlob(image,length,pixels);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const PixelPacket\n            *restrict p;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,CyanQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,GetPixelRed(p));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          count=ReadBlob(image,length,pixels);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"M\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=GetQuantumExtent(canvas_image,quantum_info,MagentaQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            if (ReadBlob(image,length,pixels) != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n        count=ReadBlob(image,length,pixels);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const PixelPacket\n            *restrict p;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,MagentaQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelGreen(q,GetPixelGreen(p));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          count=ReadBlob(image,length,pixels);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=GetQuantumExtent(canvas_image,quantum_info,YellowQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            if (ReadBlob(image,length,pixels) != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n        count=ReadBlob(image,length,pixels);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const PixelPacket\n            *restrict p;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,YellowQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(q,GetPixelBlue(p));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          count=ReadBlob(image,length,pixels);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"K\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=GetQuantumExtent(canvas_image,quantum_info,BlackQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            if (ReadBlob(image,length,pixels) != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n        count=ReadBlob(image,length,pixels);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          register const IndexPacket\n            *restrict canvas_indexes;\n\n          register const PixelPacket\n            *restrict p;\n\n          register IndexPacket\n            *restrict indexes;\n\n          register PixelPacket\n            *restrict q;\n\n          register ssize_t\n            x;\n\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,BlackQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) &&\n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const PixelPacket *) NULL) ||\n                  (q == (PixelPacket *) NULL))\n                break;\n              canvas_indexes=GetVirtualIndexQueue(canvas_image);\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(indexes+x,GetPixelIndex(\n                  canvas_indexes+image->extract_info.x+x));\n                p++;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          count=ReadBlob(image,length,pixels);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (image->matte != MagickFalse)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"A\",image->filename);\n            status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              {\n                canvas_image=DestroyImageList(canvas_image);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            length=GetQuantumExtent(canvas_image,quantum_info,AlphaQuantum);\n            for (i=0; i < (ssize_t) scene; i++)\n              for (y=0; y < (ssize_t) image->extract_info.height; y++)\n                if (ReadBlob(image,length,pixels) != (ssize_t) length)\n                  {\n                    ThrowFileException(exception,CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                    break;\n                  }\n            count=ReadBlob(image,length,pixels);\n            for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            {\n              register const PixelPacket\n                *restrict p;\n\n              register PixelPacket\n                *restrict q;\n\n              register ssize_t\n                x;\n\n              if (count != (ssize_t) length)\n                {\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n              q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n                exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n                quantum_info,YellowQuantum,pixels,exception);\n              if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n                break;\n              if (((y-image->extract_info.y) >= 0) &&\n                  ((y-image->extract_info.y) < (ssize_t) image->rows))\n                {\n                  p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,\n                    0,canvas_image->columns,1,exception);\n                  q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                    image->columns,1,exception);\n                  if ((p == (const PixelPacket *) NULL) ||\n                      (q == (PixelPacket *) NULL))\n                    break;\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    SetPixelOpacity(q,GetPixelOpacity(p));\n                    p++;\n                    q++;\n                  }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n               }\n              count=ReadBlob(image,length,pixels);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,4,5);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (count == (ssize_t) length)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (count == (ssize_t) length);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  InheritException(&image->exception,&canvas_image->exception);\n  canvas_image=DestroyImage(canvas_image);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long mkvparser::ParseElementHeader(\n    IMkvReader* pReader,\n    long long& pos,\n    long long stop,\n    long long& id,\n    long long& size)\n{\n    if ((stop >= 0) && (pos >= stop))\n        return E_FILE_FORMAT_INVALID;\n \n    long len;\n \n    id = ReadUInt(pReader, pos, len);\n \n    if (id < 0)\n        return E_FILE_FORMAT_INVALID;\n \n    pos += len;  //consume id\n \n    if ((stop >= 0) && (pos >= stop))\n        return E_FILE_FORMAT_INVALID;\n \n    size = ReadUInt(pReader, pos, len);\n \n    if (size < 0)\n        return E_FILE_FORMAT_INVALID;\n \n    pos += len;  //consume length of size\n \n \n    if ((stop >= 0) && ((pos + size) > stop))\n        return E_FILE_FORMAT_INVALID;\n    return 0;  //success\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool SVGElement::InstanceUpdatesBlocked() const {\n  return HasSVGRareData() && SvgRareData()->InstanceUpdatesBlocked();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-704"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ServiceWorkerDevToolsAgentHost::WorkerReadyForInspection(\n    blink::mojom::DevToolsAgentAssociatedPtrInfo devtools_agent_ptr_info) {\n  DCHECK_EQ(WORKER_NOT_READY, state_);\n  state_ = WORKER_READY;\n  agent_ptr_.Bind(std::move(devtools_agent_ptr_info));\n  if (!sessions().empty()) {\n    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                            base::BindOnce(&SetDevToolsAttachedOnIO,\n                                            context_weak_, version_id_, true));\n   }\n \n  RenderProcessHost* host = RenderProcessHost::FromID(worker_process_id_);\n   for (DevToolsSession* session : sessions()) {\n    session->SetRenderer(host, nullptr);\n     session->AttachToAgent(agent_ptr_);\n   }\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "new_device (u2fh_devs * devs)\n{\n  struct u2fdevice *new = malloc (sizeof (struct u2fdevice));\n  if (new == NULL)\n    {\n      return NULL;\n    }\n  memset (new, 0, sizeof (struct u2fdevice));\n  new->id = devs->max_id++;\n  if (devs->first == NULL)\n    {\n      devs->first = new;\n    }\n  else\n    {\n      struct u2fdevice *dev;\n      for (dev = devs->first; dev != NULL; dev = dev->next)\n\t{\n\t  if (dev->next == NULL)\n\t    {\n\t      break;\n\t    }\n\t}\n      dev->next = new;\n    }\n  return new;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void SupervisedUserService::InitSync(const std::string& refresh_token) {\n   ProfileOAuth2TokenService* token_service =\n       ProfileOAuth2TokenServiceFactory::GetForProfile(profile_);\n  token_service->UpdateCredentials(supervised_users::kSupervisedUserPseudoEmail,\n                                   refresh_token);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "JSValue jsTestObjUnsignedLongLongSequenceAttr(ExecState* exec, JSValue slotBase, const Identifier&)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));\n    UNUSED_PARAM(exec);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    JSValue result = jsArray(exec, castedThis->globalObject(), impl->unsignedLongLongSequenceAttr());\n    return result;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static BROTLI_INLINE void ProcessSingleCodeLength(uint32_t code_len,\n    uint32_t* symbol, uint32_t* repeat, uint32_t* space,\n    uint32_t* prev_code_len, uint16_t* symbol_lists,\n    uint16_t* code_length_histo, int* next_symbol) {\n  *repeat = 0;\n  if (code_len != 0) { /* code_len == 1..15 */\n    symbol_lists[next_symbol[code_len]] = (uint16_t)(*symbol);\n    next_symbol[code_len] = (int)(*symbol);\n    *prev_code_len = code_len;\n    *space -= 32768U >> code_len;\n    code_length_histo[code_len]++;\n  }\n  (*symbol)++;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void xhci_mfwrap_timer(void *opaque)\n{\n    XHCIState *xhci = opaque;\n    XHCIEvent wrap = { ER_MFINDEX_WRAP, CC_SUCCESS };\n\n    xhci_event(xhci, &wrap, 0);\n    xhci_mfwrap_update(xhci);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-835"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int http_connect(URLContext *h, const char *path, const char *local_path,\n                        const char *hoststr, const char *auth,\n                        const char *proxyauth, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n     int post, err;\n     char headers[HTTP_HEADERS_SIZE] = \"\";\n     char *authstr = NULL, *proxyauthstr = NULL;\n    int64_t off = s->off;\n     int len = 0;\n     const char *method;\n     int send_expect_100 = 0;\n\n    /* send http header */\n    post = h->flags & AVIO_FLAG_WRITE;\n\n    if (s->post_data) {\n        /* force POST method and disable chunked encoding when\n         * custom HTTP post data is set */\n        post            = 1;\n        s->chunked_post = 0;\n    }\n\n    if (s->method)\n        method = s->method;\n    else\n        method = post ? \"POST\" : \"GET\";\n\n    authstr      = ff_http_auth_create_response(&s->auth_state, auth,\n                                                local_path, method);\n    proxyauthstr = ff_http_auth_create_response(&s->proxy_auth_state, proxyauth,\n                                                local_path, method);\n    if (post && !s->post_data) {\n        send_expect_100 = s->send_expect_100;\n        /* The user has supplied authentication but we don't know the auth type,\n         * send Expect: 100-continue to get the 401 response including the\n         * WWW-Authenticate header, or an 100 continue if no auth actually\n         * is needed. */\n        if (auth && *auth &&\n            s->auth_state.auth_type == HTTP_AUTH_NONE &&\n            s->http_code != 401)\n            send_expect_100 = 1;\n    }\n\n#if FF_API_HTTP_USER_AGENT\n    if (strcmp(s->user_agent_deprecated, DEFAULT_USER_AGENT)) {\n        av_log(s, AV_LOG_WARNING, \"the user-agent option is deprecated, please use user_agent option\\n\");\n        s->user_agent = av_strdup(s->user_agent_deprecated);\n    }\n#endif\n    /* set default headers if needed */\n    if (!has_header(s->headers, \"\\r\\nUser-Agent: \"))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"User-Agent: %s\\r\\n\", s->user_agent);\n    if (!has_header(s->headers, \"\\r\\nAccept: \"))\n        len += av_strlcpy(headers + len, \"Accept: */*\\r\\n\",\n                          sizeof(headers) - len);\n     if (!has_header(s->headers, \"\\r\\nRange: \") && !post && (s->off > 0 || s->end_off || s->seekable == -1)) {\n         len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Range: bytes=%\"PRId64\"-\", s->off);\n         if (s->end_off)\n             len += av_strlcatf(headers + len, sizeof(headers) - len,\n                                \"%\"PRId64, s->end_off - 1);\n        len += av_strlcpy(headers + len, \"\\r\\n\",\n                          sizeof(headers) - len);\n    }\n    if (send_expect_100 && !has_header(s->headers, \"\\r\\nExpect: \"))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Expect: 100-continue\\r\\n\");\n\n    if (!has_header(s->headers, \"\\r\\nConnection: \")) {\n        if (s->multiple_requests)\n            len += av_strlcpy(headers + len, \"Connection: keep-alive\\r\\n\",\n                              sizeof(headers) - len);\n        else\n            len += av_strlcpy(headers + len, \"Connection: close\\r\\n\",\n                              sizeof(headers) - len);\n    }\n\n    if (!has_header(s->headers, \"\\r\\nHost: \"))\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Host: %s\\r\\n\", hoststr);\n    if (!has_header(s->headers, \"\\r\\nContent-Length: \") && s->post_data)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Content-Length: %d\\r\\n\", s->post_datalen);\n\n    if (!has_header(s->headers, \"\\r\\nContent-Type: \") && s->content_type)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Content-Type: %s\\r\\n\", s->content_type);\n    if (!has_header(s->headers, \"\\r\\nCookie: \") && s->cookies) {\n        char *cookies = NULL;\n        if (!get_cookies(s, &cookies, path, hoststr) && cookies) {\n            len += av_strlcatf(headers + len, sizeof(headers) - len,\n                               \"Cookie: %s\\r\\n\", cookies);\n            av_free(cookies);\n        }\n    }\n    if (!has_header(s->headers, \"\\r\\nIcy-MetaData: \") && s->icy)\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n                           \"Icy-MetaData: %d\\r\\n\", 1);\n\n    /* now add in custom headers */\n    if (s->headers)\n        av_strlcpy(headers + len, s->headers, sizeof(headers) - len);\n\n    snprintf(s->buffer, sizeof(s->buffer),\n             \"%s %s HTTP/1.1\\r\\n\"\n             \"%s\"\n             \"%s\"\n             \"%s\"\n             \"%s%s\"\n             \"\\r\\n\",\n             method,\n             path,\n             post && s->chunked_post ? \"Transfer-Encoding: chunked\\r\\n\" : \"\",\n             headers,\n             authstr ? authstr : \"\",\n             proxyauthstr ? \"Proxy-\" : \"\", proxyauthstr ? proxyauthstr : \"\");\n\n    av_log(h, AV_LOG_DEBUG, \"request: %s\\n\", s->buffer);\n\n    if ((err = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)\n        goto done;\n\n    if (s->post_data)\n        if ((err = ffurl_write(s->hd, s->post_data, s->post_datalen)) < 0)\n            goto done;\n\n    /* init input buffer */\n    s->buf_ptr          = s->buffer;\n    s->buf_end          = s->buffer;\n     s->line_count       = 0;\n     s->off              = 0;\n     s->icy_data_read    = 0;\n    s->filesize         = -1;\n     s->willclose        = 0;\n     s->end_chunked_post = 0;\n     s->end_header       = 0;\n    if (post && !s->post_data && !send_expect_100) {\n        /* Pretend that it did work. We didn't read any header yet, since\n         * we've still to send the POST data, but the code calling this\n         * function will check http_code after we return. */\n        s->http_code = 200;\n        err = 0;\n        goto done;\n    }\n\n    /* wait for header */\n    err = http_read_header(h, new_location);\n    if (err < 0)\n        goto done;\n\n    if (*new_location)\n        s->off = off;\n\n    err = (off == s->off) ? 0 : -1;\ndone:\n    av_freep(&authstr);\n    av_freep(&proxyauthstr);\n    return err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool PDFiumEngine::SelectFindResult(bool forward) {\n  if (find_results_.empty()) {\n    NOTREACHED();\n    return false;\n  }\n\n  SelectionChangeInvalidator selection_invalidator(this);\n\n  size_t new_index;\n  const size_t last_index = find_results_.size() - 1;\n  if (current_find_index_.valid()) {\n    size_t current_index = current_find_index_.GetIndex();\n    if (forward) {\n      new_index = (current_index >= last_index) ?  0 : current_index + 1;\n    } else {\n      new_index = (current_find_index_.GetIndex() == 0) ?\n          last_index : current_index - 1;\n    }\n  } else {\n    new_index = forward ? 0 : last_index;\n  }\n  current_find_index_.SetIndex(new_index);\n\n  selection_.clear();\n  selection_.push_back(find_results_[current_find_index_.GetIndex()]);\n\n  pp::Rect bounding_rect;\n  pp::Rect visible_rect = GetVisibleRect();\n  std::vector<pp::Rect> rects;\n  rects = find_results_[current_find_index_.GetIndex()].GetScreenRects(\n      pp::Point(), 1.0, current_rotation_);\n  for (const auto& rect : rects)\n    bounding_rect = bounding_rect.Union(rect);\n  if (!visible_rect.Contains(bounding_rect)) {\n    pp::Point center = bounding_rect.CenterPoint();\n    int new_y = static_cast<int>(center.y() * current_zoom_) -\n        static_cast<int>(visible_rect.height() * current_zoom_ / 2);\n    if (new_y < 0)\n      new_y = 0;\n    client_->ScrollToY(new_y);\n\n    if (center.x() < visible_rect.x() || center.x() > visible_rect.right()) {\n      int new_x = static_cast<int>(center.x()  * current_zoom_) -\n          static_cast<int>(visible_rect.width() * current_zoom_ / 2);\n      if (new_x < 0)\n        new_x = 0;\n      client_->ScrollToX(new_x);\n    }\n  }\n\n  client_->NotifySelectedFindResultChanged(current_find_index_.GetIndex());\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)\n\t{\n\tint i, idx;\n\tconst EVP_MD *md;\n\tCERT *c = s->cert;\n\t/* Extension ignored for TLS versions below 1.2 */\n\tif (TLS1_get_version(s) < TLS1_2_VERSION)\n\t\treturn 1;\n\t/* Should never happen */\n\tif (!c)\n\t\treturn 0;\n\n\tc->pkeys[SSL_PKEY_DSA_SIGN].digest = NULL;\n\tc->pkeys[SSL_PKEY_RSA_SIGN].digest = NULL;\n\tc->pkeys[SSL_PKEY_RSA_ENC].digest = NULL;\n\tc->pkeys[SSL_PKEY_ECC].digest = NULL;\n\n\tfor (i = 0; i < dsize; i += 2)\n\t\t{\n\t\tunsigned char hash_alg = data[i], sig_alg = data[i+1];\n\n\t\tswitch(sig_alg)\n\t\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\t\tcase TLSEXT_signature_rsa:\n\t\t\tidx = SSL_PKEY_RSA_SIGN;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\t\tcase TLSEXT_signature_dsa:\n\t\t\tidx = SSL_PKEY_DSA_SIGN;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\t\tcase TLSEXT_signature_ecdsa:\n\t\t\tidx = SSL_PKEY_ECC;\n\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\tcontinue;\n\t\t\t}\n\n\t\tif (c->pkeys[idx].digest == NULL)\n\t\t\t{\n\t\t\tmd = tls12_get_hash(hash_alg);\n\t\t\tif (md)\n\t\t\t\t{\n\t\t\t\tc->pkeys[idx].digest = md;\n\t\t\t\tif (idx == SSL_PKEY_RSA_SIGN)\n\t\t\t\t\tc->pkeys[SSL_PKEY_RSA_ENC].digest = md;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t/* Set any remaining keys to default values. NOTE: if alg is not\n\t * supported it stays as NULL.\n\t */\n#ifndef OPENSSL_NO_DSA\n\tif (!c->pkeys[SSL_PKEY_DSA_SIGN].digest)\n\t\tc->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_sha1();\n#endif\n#ifndef OPENSSL_NO_RSA\n\tif (!c->pkeys[SSL_PKEY_RSA_SIGN].digest)\n\t\t{\n\t\tc->pkeys[SSL_PKEY_RSA_SIGN].digest = EVP_sha1();\n\t\tc->pkeys[SSL_PKEY_RSA_ENC].digest = EVP_sha1();\n\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\tif (!c->pkeys[SSL_PKEY_ECC].digest)\n\t\tc->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();\n#endif\n\treturn 1;\n\t}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GranularityStrategyTest::SetInnerHTML(const char* html_content) {\n  GetDocument().documentElement()->setInnerHTML(String::FromUTF8(html_content));\n  GetDocument().View()->UpdateAllLifecyclePhases();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static u64 core_reg_offset_from_id(u64 id)\n{\n\treturn id & ~(KVM_REG_ARCH_MASK | KVM_REG_SIZE_MASK | KVM_REG_ARM_CORE);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual void SetUp() {\n    const tuple<int, int, VarianceFunctionType>& params = this->GetParam();\n     log2width_  = get<0>(params);\n     width_ = 1 << log2width_;\n     log2height_ = get<1>(params);\n     height_ = 1 << log2height_;\n     variance_ = get<2>(params);\n \n    rnd(ACMRandom::DeterministicSeed());\n     block_size_ = width_ * height_;\n    src_ = new uint8_t[block_size_];\n    ref_ = new uint8_t[block_size_];\n     ASSERT_TRUE(src_ != NULL);\n     ASSERT_TRUE(ref_ != NULL);\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "append_quoted (struct stringbuf *sb, const unsigned char *value, size_t length,\n               int skip)\n{\n  unsigned char tmp[4];\n  const unsigned char *s = value;\n  size_t n = 0;\n\n  for (;;)\n    {\n      for (value = s; n+skip < length; n++, s++)\n        {\n          s += skip;\n          n += skip;\n          if (*s < ' ' || *s > 126 || strchr (\",+\\\"\\\\<>;\", *s) )\n            break;\n        }\n\n      if (s != value)\n        put_stringbuf_mem_skip (sb, value, s-value, skip);\n      if (n+skip >= length)\n        return; /* ready */\n      s += skip;\n       n += skip;\n       if ( *s < ' ' || *s > 126 )\n         {\n          sprintf (tmp, \"\\\\%02X\", *s);\n           put_stringbuf_mem (sb, tmp, 3);\n         }\n       else\n        {\n          tmp[0] = '\\\\';\n          tmp[1] = *s;\n          put_stringbuf_mem (sb, tmp, 2);\n        }\n      n++; s++;\n    }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "jboolean WebContentsAndroid::IsRenderWidgetHostViewReady(\n    JNIEnv* env,\n    jobject obj) {\n  RenderWidgetHostViewAndroid* view = GetRenderWidgetHostViewAndroid();\n  return view && view->HasValidFrame();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ssl_parse_supported_point_formats( mbedtls_ssl_context *ssl,\n                                              const unsigned char *buf,\n                                              size_t len )\n{\n    size_t list_size;\n    const unsigned char *p;\n\n    list_size = buf[0];\n    if( list_size + 1 != len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    p = buf + 1;\n    while( list_size > 0 )\n    {\n        if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n            p[0] == MBEDTLS_ECP_PF_COMPRESSED )\n        {\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)\n            ssl->handshake->ecdh_ctx.point_format = p[0];\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            ssl->handshake->ecjpake_ctx.point_format = p[0];\n#endif\n            MBEDTLS_SSL_DEBUG_MSG( 4, ( \"point format selected: %d\", p[0] ) );\n            return( 0 );\n        }\n\n        list_size--;\n        p++;\n    }\n\n    return( 0 );\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "AXTableCell::~AXTableCell() {}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ux500_cryp_remove(struct platform_device *pdev)\n{\n\tstruct resource *res = NULL;\n\tstruct resource *res_irq = NULL;\n\tstruct cryp_device_data *device_data;\n\n\tdev_dbg(&pdev->dev, \"[%s]\", __func__);\n\tdevice_data = platform_get_drvdata(pdev);\n\tif (!device_data) {\n\t\tdev_err(&pdev->dev, \"[%s]: platform_get_drvdata() failed!\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Try to decrease the number of available devices. */\n\tif (down_trylock(&driver_data.device_allocation))\n\t\treturn -EBUSY;\n\n\t/* Check that the device is free */\n\tspin_lock(&device_data->ctx_lock);\n\t/* current_ctx allocates a device, NULL = unallocated */\n\tif (device_data->current_ctx) {\n\t\t/* The device is busy */\n\t\tspin_unlock(&device_data->ctx_lock);\n\t\t/* Return the device to the pool. */\n\t\tup(&driver_data.device_allocation);\n\t\treturn -EBUSY;\n\t}\n\n\tspin_unlock(&device_data->ctx_lock);\n\n\t/* Remove the device from the list */\n\tif (klist_node_attached(&device_data->list_node))\n\t\tklist_remove(&device_data->list_node);\n\n\t/* If this was the last device, remove the services */\n\tif (list_empty(&driver_data.device_list.k_list))\n\t\tcryp_algs_unregister_all();\n\n\tres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!res_irq)\n\t\tdev_err(&pdev->dev, \"[%s]: IORESOURCE_IRQ, unavailable\",\n\t\t\t__func__);\n\telse {\n\t\tdisable_irq(res_irq->start);\n\t\tfree_irq(res_irq->start, device_data);\n\t}\n\n\tif (cryp_disable_power(&pdev->dev, device_data, false))\n\t\tdev_err(&pdev->dev, \"[%s]: cryp_disable_power() failed\",\n\t\t\t__func__);\n\n\tclk_unprepare(device_data->clk);\n\tclk_put(device_data->clk);\n\tregulator_put(device_data->pwr_regulator);\n\n\tiounmap(device_data->base);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res)\n\t\trelease_mem_region(res->start, resource_size(res));\n\n\tkfree(device_data);\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void WebMediaPlayerMS::OnFrameClosed() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n#if defined(OS_ANDROID)\n  if (!paused_) {\n    Pause();\n    should_play_upon_shown_ = true;\n  }\n\n  delegate_->PlayerGone(delegate_id_);\n#endif  // defined(OS_ANDROID)\n\n  if (frame_deliverer_) {\n    io_task_runner_->PostTask(\n        FROM_HERE,\n        base::BindOnce(&FrameDeliverer::SetRenderFrameSuspended,\n                       base::Unretained(frame_deliverer_.get()), true));\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-732"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int __nd_alloc_stack(struct nameidata *nd)\n{\n\tstruct saved *p;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tp= kmalloc(MAXSYMLINKS * sizeof(struct saved),\n\t\t\t\t  GFP_ATOMIC);\n\t\tif (unlikely(!p))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tp= kmalloc(MAXSYMLINKS * sizeof(struct saved),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t}\n\tmemcpy(p, nd->internal, sizeof(nd->internal));\n\tnd->stack = p;\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int acquire_reference_state(struct bpf_verifier_env *env, int insn_idx)\n{\n\tstruct bpf_func_state *state = cur_func(env);\n\tint new_ofs = state->acquired_refs;\n\tint id, err;\n\n\terr = realloc_reference_state(state, state->acquired_refs + 1, true);\n\tif (err)\n\t\treturn err;\n\tid = ++env->id_gen;\n\tstate->refs[new_ofs].id = id;\n\tstate->refs[new_ofs].insn_idx = insn_idx;\n\n\treturn id;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SPL_METHOD(GlobIterator, count)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\t/* should not happen */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"GlobIterator lost glob state\");\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n \ti = 0;\n \tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n \t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n \t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n \t\t\t\terr = -EINVAL;\n \t\t\t\tgoto out_free;\n \t\t\t}\n \t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n \t\t\ti++;\n \t\t}\n \t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MediaStreamManagerTest()\n      : thread_bundle_(content::TestBrowserThreadBundle::IO_MAINLOOP) {\n    audio_manager_ = std::make_unique<MockAudioManager>();\n    audio_system_ =\n        std::make_unique<media::AudioSystemImpl>(audio_manager_.get());\n    auto video_capture_provider = std::make_unique<MockVideoCaptureProvider>();\n    video_capture_provider_ = video_capture_provider.get();\n     media_stream_manager_ = std::make_unique<MediaStreamManager>(\n         audio_system_.get(), audio_manager_->GetTaskRunner(),\n         std::move(video_capture_provider));\n     base::RunLoop().RunUntilIdle();\n \n     ON_CALL(*video_capture_provider_, DoGetDeviceInfosAsync(_))\n        .WillByDefault(Invoke(\n            [](VideoCaptureProvider::GetDeviceInfosCallback& result_callback) {\n              std::vector<media::VideoCaptureDeviceInfo> stub_results;\n              base::ResetAndReturn(&result_callback).Run(stub_results);\n            }));\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int btrfs_truncate(struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *rsv;\n\tint ret = 0;\n\tint err = 0;\n\tstruct btrfs_trans_handle *trans;\n\tu64 mask = root->sectorsize - 1;\n\tu64 min_size = btrfs_calc_trunc_metadata_size(root, 1);\n\n\tret = btrfs_wait_ordered_range(inode, inode->i_size & (~mask),\n\t\t\t\t       (u64)-1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Yes ladies and gentelment, this is indeed ugly.  The fact is we have\n\t * 3 things going on here\n\t *\n\t * 1) We need to reserve space for our orphan item and the space to\n\t * delete our orphan item.  Lord knows we don't want to have a dangling\n\t * orphan item because we didn't reserve space to remove it.\n\t *\n\t * 2) We need to reserve space to update our inode.\n\t *\n\t * 3) We need to have something to cache all the space that is going to\n\t * be free'd up by the truncate operation, but also have some slack\n\t * space reserved in case it uses space during the truncate (thank you\n\t * very much snapshotting).\n\t *\n\t * And we need these to all be seperate.  The fact is we can use alot of\n\t * space doing the truncate, and we have no earthly idea how much space\n\t * we will use, so we need the truncate reservation to be seperate so it\n\t * doesn't end up using space reserved for updating the inode or\n\t * removing the orphan item.  We also need to be able to stop the\n\t * transaction and start a new one, which means we need to be able to\n\t * update the inode several times, and we have no idea of knowing how\n\t * many times that will be, so we can't just reserve 1 item for the\n\t * entirety of the opration, so that has to be done seperately as well.\n\t * Then there is the orphan item, which does indeed need to be held on\n\t * to for the whole operation, and we need nobody to touch this reserved\n\t * space except the orphan code.\n\t *\n\t * So that leaves us with\n\t *\n\t * 1) root->orphan_block_rsv - for the orphan deletion.\n\t * 2) rsv - for the truncate reservation, which we will steal from the\n\t * transaction reservation.\n\t * 3) fs_info->trans_block_rsv - this will have 1 items worth left for\n\t * updating the inode.\n\t */\n\trsv = btrfs_alloc_block_rsv(root, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv)\n\t\treturn -ENOMEM;\n\trsv->size = min_size;\n\trsv->failfast = 1;\n\n\t/*\n\t * 1 for the truncate slack space\n\t * 1 for updating the inode.\n\t */\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* Migrate the slack space for the truncate to our reserve */\n\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv, rsv,\n\t\t\t\t      min_size);\n\tBUG_ON(ret);\n\n\t/*\n\t * So if we truncate and then write and fsync we normally would just\n\t * write the extents that changed, which is a problem if we need to\n\t * first truncate that entire inode.  So set this flag so we write out\n\t * all of the extents in the inode to the sync log so we're completely\n\t * safe.\n\t */\n\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC, &BTRFS_I(inode)->runtime_flags);\n\ttrans->block_rsv = rsv;\n\n\twhile (1) {\n\t\tret = btrfs_truncate_inode_items(trans, root, inode,\n\t\t\t\t\t\t inode->i_size,\n\t\t\t\t\t\t BTRFS_EXTENT_DATA_KEY);\n\t\tif (ret != -ENOSPC && ret != -EAGAIN) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = err = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv,\n\t\t\t\t\t      rsv, min_size);\n\t\tBUG_ON(ret);\t/* shouldn't happen */\n\t\ttrans->block_rsv = rsv;\n\t}\n\n\tif (ret == 0 && inode->i_nlink > 0) {\n\t\ttrans->block_rsv = root->orphan_block_rsv;\n\t\tret = btrfs_orphan_del(trans, inode);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\n\tif (trans) {\n\t\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t\tif (ret && !err)\n\t\t\terr = ret;\n\n\t\tret = btrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(root);\n\t}\n\nout:\n\tbtrfs_free_block_rsv(root, rsv);\n\n\tif (ret && !err)\n\t\terr = ret;\n\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline bool containsKanaLetters(const String& pattern)\n{\n    const UChar* characters = pattern.characters();\n    unsigned length = pattern.length();\n    for (unsigned i = 0; i < length; ++i) {\n        if (isKanaLetter(characters[i]))\n            return true;\n    }\n    return false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n \tpos = full_path + unc_len;\n \n \tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n \t\tpos += pplen;\n \t}\n \n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void handle_stdfmna(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr)\n{\n\tunsigned long pc = regs->tpc;\n\tunsigned long tstate = regs->tstate;\n\tu32 insn;\n\tu64 value;\n\tu8 freg;\n\tint flag;\n\tstruct fpustate *f = FPUSTATE;\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\"stdfmna from kernel\", regs);\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, sfar);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\n\t\tint asi = decode_asi(insn, regs);\n\t\tfreg = ((insn >> 25) & 0x1e) | ((insn >> 20) & 0x20);\n\t\tvalue = 0;\n\t\tflag = (freg < 32) ? FPRS_DL : FPRS_DU;\n\t\tif ((asi > ASI_SNFL) ||\n\t\t    (asi < ASI_P))\n\t\t\tgoto daex;\n\t\tsave_and_clear_fpu();\n\t\tif (current_thread_info()->fpsaved[0] & flag)\n\t\t\tvalue = *(u64 *)&f->regs[freg];\n\t\tswitch (asi) {\n\t\tcase ASI_P:\n\t\tcase ASI_S: break;\n\t\tcase ASI_PL:\n\t\tcase ASI_SL: \n\t\t\tvalue = __swab64p(&value); break;\n\t\tdefault: goto daex;\n\t\t}\n\t\tif (put_user (value >> 32, (u32 __user *) sfar) ||\n\t\t    __put_user ((u32)value, (u32 __user *)(sfar + 4)))\n\t\t\tgoto daex;\n\t} else {\ndaex:\n\t\tif (tlb_type == hypervisor)\n\t\t\tsun4v_data_access_exception(regs, sfar, sfsr);\n\t\telse\n\t\t\tspitfire_data_access_exception(regs, sfsr, sfar);\n\t\treturn;\n\t}\n\tadvance(regs);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n {\n \tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n \tslots = kvm_memslots(kvm);\n \n \tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_put_pages(kvm, memslot->base_gfn, memslot->npages);\n \n \tsrcu_read_unlock(&kvm->srcu, idx);\n \n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int findClosestEntry(UCHAR goalSb, UCHAR *v_k_master, UCHAR numMaster, UCHAR direction)\n{\n int index;\n\n if( goalSb <= v_k_master[0] )\n return v_k_master[0];\n\n if( goalSb >= v_k_master[numMaster] )\n return v_k_master[numMaster];\n\n if(direction) {\n    index = 0;\n while( v_k_master[index] < goalSb ) {\n      index++;\n }\n } else {\n    index = numMaster;\n while( v_k_master[index] > goalSb ) {\n      index--;\n }\n }\n\n return v_k_master[index];\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\t/*\n\t * Single threaded tasks need not iterate the entire\n\t * list of process. We can avoid the flushing as well\n\t * since the mm's seqnum was increased and don't have\n\t * to worry about other threads' seqnum. Current's\n\t * flush will occur upon the next lookup.\n\t */\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\t/*\n\t\t * Only flush the vmacache pointers as the\n\t\t * mm seqnum is already set and curr's will\n\t\t * be set upon invalidation when the next\n\t\t * lookup is done.\n\t\t */\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "rend_service_check_private_dir(const or_options_t *options,\n                               const rend_service_t *s,\n                               int create)\n{\n  /* Passing a NULL service is a bug */\n  if (BUG(!s)) {\n    return -1;\n  }\n\n  /* Check/create directory */\n  if (rend_service_check_private_dir_impl(options, s, create) < 0) {\n    return -1;\n  }\n\n  /* Check if the hidden service key exists, and was created in a different\n   * single onion service mode, and refuse to launch if it has.\n   * This is safe to call even when create is false, as it ignores missing\n   * keys and directories: they are always valid.\n   */\n  if (rend_service_verify_single_onion_poison(s, options) < 0) {\n    /* We can't use s->service_id here, as the key may not have been loaded */\n    log_warn(LD_GENERAL, \"We are configured with \"\n             \"HiddenServiceNonAnonymousMode %d, but the hidden \"\n             \"service key in directory %s was created in %s mode. \"\n             \"This is not allowed.\",\n             rend_service_non_anonymous_mode_enabled(options) ? 1 : 0,\n             rend_service_escaped_dir(s),\n             rend_service_non_anonymous_mode_enabled(options) ?\n             \"an anonymous\" : \"a non-anonymous\"\n             );\n    return -1;\n  }\n\n  /* Poison new single onion directories immediately after they are created,\n   * so that we never accidentally launch non-anonymous hidden services\n   * thinking they are anonymous. Any keys created later will end up with the\n   * correct poisoning state.\n   */\n  if (create && rend_service_non_anonymous_mode_enabled(options)) {\n    static int logged_warning = 0;\n\n    if (rend_service_poison_new_single_onion_dir(s, options) < 0) {\n      log_warn(LD_GENERAL,\"Failed to mark new hidden services as non-anonymous\"\n               \".\");\n      return -1;\n    }\n\n    if (!logged_warning) {\n      /* The keys for these services are linked to the server IP address */\n      log_notice(LD_REND, \"The configured onion service directories have been \"\n                 \"used in single onion mode. They can not be used for \"\n                 \"anonymous hidden services.\");\n      logged_warning = 1;\n    }\n  }\n\n  return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-532"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Instance::OnControlTimerFired(int32_t,\n                                   const uint32& control_id,\n                                   const uint32& timer_id) {\n  if (control_id == toolbar_->id()) {\n    toolbar_->OnTimerFired(timer_id);\n  } else if (control_id == progress_bar_.id()) {\n    if (timer_id == delayed_progress_timer_id_) {\n      if (document_load_state_ == LOAD_STATE_LOADING &&\n          !progress_bar_.visible()) {\n        progress_bar_.Fade(true, kProgressFadeTimeoutMs);\n      }\n      delayed_progress_timer_id_ = 0;\n    } else {\n      progress_bar_.OnTimerFired(timer_id);\n    }\n  } else if (control_id == kAutoScrollId) {\n    if (is_autoscroll_) {\n      if (autoscroll_x_ != 0 && h_scrollbar_.get()) {\n        h_scrollbar_->ScrollBy(PP_SCROLLBY_PIXEL, autoscroll_x_);\n      }\n      if (autoscroll_y_ != 0 && v_scrollbar_.get()) {\n        v_scrollbar_->ScrollBy(PP_SCROLLBY_PIXEL, autoscroll_y_);\n      }\n\n      ScheduleTimer(kAutoScrollId, kAutoScrollTimeoutMs);\n    }\n  } else if (control_id == kPageIndicatorId) {\n    page_indicator_.OnTimerFired(timer_id);\n  }\n#ifdef ENABLE_THUMBNAILS\n  else if (control_id == thumbnails_.id()) {\n    thumbnails_.OnTimerFired(timer_id);\n  }\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void setPositiveMargin(LayoutUnit p) { ASSERT(!m_discardMargin); m_positiveMargin = p; }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "u32 GifIndexToTrueColor(struct ngiflib_rgb * palette, u8 v) {\n\treturn palette[v].b | (palette[v].g << 8) | (palette[v].r << 16);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Node* DOMPatchSupport::patchNode(Node* node, const String& markup, ExceptionCode& ec)\n{\n    if (node->isDocumentNode() || (node->parentNode() && node->parentNode()->isDocumentNode())) {\n        patchDocument(markup);\n        return 0;\n     }\n \n     Node* previousSibling = node->previousSibling();\n     RefPtr<DocumentFragment> fragment = DocumentFragment::create(m_document);\n     fragment->parseHTML(markup, node->parentElement() ? node->parentElement() : m_document->documentElement());\n \n    ContainerNode* parentNode = node->parentNode();\n    Vector<OwnPtr<Digest> > oldList;\n    for (Node* child = parentNode->firstChild(); child; child = child->nextSibling())\n        oldList.append(createDigest(child, 0));\n\n    String markupCopy = markup;\n    markupCopy.makeLower();\n    Vector<OwnPtr<Digest> > newList;\n    for (Node* child = parentNode->firstChild(); child != node; child = child->nextSibling())\n        newList.append(createDigest(child, 0));\n    for (Node* child = fragment->firstChild(); child; child = child->nextSibling()) {\n        if (child->hasTagName(headTag) && !child->firstChild() && markupCopy.find(\"</head>\") == notFound)\n            continue; // HTML5 parser inserts empty <head> tag whenever it parses <body>\n        if (child->hasTagName(bodyTag) && !child->firstChild() && markupCopy.find(\"</body>\") == notFound)\n            continue; // HTML5 parser inserts empty <body> tag whenever it parses </head>\n        newList.append(createDigest(child, &m_unusedNodesMap));\n    }\n    for (Node* child = node->nextSibling(); child; child = child->nextSibling())\n        newList.append(createDigest(child, 0));\n\n    if (!innerPatchChildren(parentNode, oldList, newList, ec)) {\n        ec = 0;\n        if (!m_domEditor->replaceChild(parentNode, fragment.release(), node, ec))\n            return 0;\n    }\n    return previousSibling ? previousSibling->nextSibling() : parentNode->firstChild();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n {\n     USHORT Res;\n     auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n     if (ppr.ipStatus != ppresNotIP)\n     {\n         Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "process_remove_identity(SocketEntry *e, int version)\n{\n\tsize_t blen;\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tu_char *blob;\n#ifdef WITH_SSH1\n\tu_int bits;\n#endif /* WITH_SSH1 */\n\n\tswitch (version) {\n#ifdef WITH_SSH1\n\tcase 1:\n\t\tif ((key = sshkey_new(KEY_RSA1)) == NULL) {\n\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(e->request, &bits)) != 0 ||\n\t\t    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tif (bits != sshkey_size(key))\n\t\t\tlogit(\"Warning: identity keysize mismatch: \"\n\t\t\t    \"actual %u, announced %u\",\n\t\t\t    sshkey_size(key), bits);\n\t\tbreak;\n#endif /* WITH_SSH1 */\n\tcase 2:\n\t\tif ((r = sshbuf_get_string(e->request, &blob, &blen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0)\n\t\t\terror(\"%s: sshkey_from_blob failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tfree(blob);\n\t\tbreak;\n\t}\n\tif (key != NULL) {\n\t\tIdentity *id = lookup_identity(key, version);\n\t\tif (id != NULL) {\n\t\t\t/*\n\t\t\t * We have this key.  Free the old key.  Since we\n\t\t\t * don't want to leave empty slots in the middle of\n\t\t\t * the array, we actually free the key there and move\n\t\t\t * all the entries between the empty slot and the end\n\t\t\t * of the array.\n\t\t\t */\n\t\t\tIdtab *tab = idtab_lookup(version);\n\t\t\tif (tab->nentries < 1)\n\t\t\t\tfatal(\"process_remove_identity: \"\n\t\t\t\t    \"internal error: tab->nentries %d\",\n\t\t\t\t    tab->nentries);\n\t\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\ttab->nentries--;\n\t\t\tsuccess = 1;\n\t\t}\n\t\tsshkey_free(key);\n\t}\n\tsend_status(e, success);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-426"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n {\n \tREGION16_DATA* newItems;\n \tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n \tRECTANGLE_16* dstPtr;\n\tUINT32 nbRects, usedRects;\n\tRECTANGLE_16 common, newExtents;\n\tassert(src);\n\tassert(src->data);\n\tsrcPtr = region16_rects(src, &nbRects);\n\n\tif (!nbRects)\n\t{\n\t\tregion16_clear(dst);\n\t\treturn TRUE;\n\t}\n\n\tsrcExtents = region16_extents(src);\n\n\tif (nbRects == 1)\n\t{\n\t\tBOOL intersects = rectangles_intersection(srcExtents, rect, &common);\n\t\tregion16_clear(dst);\n\n\t\tif (intersects)\n\t\t\treturn region16_union_rect(dst, dst, &common);\n\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion(nbRects);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstPtr = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\tZeroMemory(&newExtents, sizeof(newExtents));\n\n\t/* accumulate intersecting rectangles, the final region16_simplify_bands() will\n\t * do all the bad job to recreate correct rectangles\n\t */\n\tfor (endPtr = srcPtr + nbRects; (srcPtr < endPtr) && (rect->bottom > srcPtr->top); srcPtr++)\n\t{\n\t\tif (rectangles_intersection(srcPtr, rect, &common))\n\t\t{\n\t\t\t*dstPtr = common;\n\t\t\tusedRects++;\n\t\t\tdstPtr++;\n\n\t\t\tif (rectangle_is_empty(&newExtents))\n\t\t\t{\n\t\t\t\t/* Check if the existing newExtents is empty. If it is empty, use\n\t\t\t\t * new common directly. We do not need to check common rectangle\n\t\t\t\t * because the rectangles_intersection() ensures that it is not empty.\n\t\t\t\t */\n\t\t\t\tnewExtents = common;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewExtents.top = MIN(common.top, newExtents.top);\n\t\t\t\tnewExtents.left = MIN(common.left, newExtents.left);\n\t\t\t\tnewExtents.bottom = MAX(common.bottom, newExtents.bottom);\n\t\t\t\tnewExtents.right = MAX(common.right, newExtents.right);\n\t\t\t}\n\t\t}\n\t}\n\n\tnewItems->nbRects = usedRects;\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\n \tif ((dst->data->size > 0) && (dst->data != &empty_region))\n \t\tfree(dst->data);\n \n\tdst->data = realloc(newItems, newItems->size);\n \n \tif (!dst->data)\n \t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->extents = newExtents;\n\treturn region16_simplify_bands(dst);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-772"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BrowserWindowGtk::UpdateWindowShape(int width, int height) {\n  GdkRegion* mask = GetWindowShape(width, height);\n  gdk_window_shape_combine_region(\n      gtk_widget_get_window(GTK_WIDGET(window_)), mask, 0, 0);\n  if (mask)\n    gdk_region_destroy(mask);\n\n  if (UseCustomFrame() && !IsFullscreen() && !IsMaximized()) {\n    gtk_alignment_set_padding(GTK_ALIGNMENT(window_container_), 1,\n        kFrameBorderThickness, kFrameBorderThickness, kFrameBorderThickness);\n  } else {\n    gtk_alignment_set_padding(GTK_ALIGNMENT(window_container_), 0, 0, 0, 0);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t OMXNodeInstance::updateGraphicBufferInMeta(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n return updateGraphicBufferInMeta_l(\n            portIndex, graphicBuffer, buffer, header,\n true /* updateCodecBuffer */);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static SQLITE_NOINLINE void backupUpdate(\n  sqlite3_backup *p,\n  Pgno iPage,\n  const u8 *aData\n){\n  assert( p!=0 );\n  do{\n    assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );\n    if( !isFatalError(p->rc) && iPage<p->iNext ){\n      /* The backup process p has already copied page iPage. But now it\n      ** has been modified by a transaction on the source pager. Copy\n      ** the new data into the backup.\n      */\n      int rc;\n      assert( p->pDestDb );\n      sqlite3_mutex_enter(p->pDestDb->mutex);\n      rc = backupOnePage(p, iPage, aData, 1);\n      sqlite3_mutex_leave(p->pDestDb->mutex);\n      assert( rc!=SQLITE_BUSY && rc!=SQLITE_LOCKED );\n      if( rc!=SQLITE_OK ){\n        p->rc = rc;\n      }\n    }\n  }while( (p = p->pNext)!=0 );\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,\n                                 UWORD8 u1_nal_ref_idc,\n dec_struct_t *ps_dec /* Decoder parameters */\n )\n{\n dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;\n dec_pic_params_t *ps_pps;\n dec_seq_params_t *ps_seq;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n pocstruct_t s_tmp_poc;\n    WORD32 i_delta_poc[2];\n    WORD32 i4_poc = 0;\n    UWORD16 u2_first_mb_in_slice, u2_frame_num;\n    UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;\n    UWORD32 u4_idr_pic_id = 0;\n    UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;\n\n    UWORD8 u1_nal_unit_type;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    WORD8 i1_is_end_of_poc;\n\n    WORD32 ret, end_of_frame;\n    WORD32 prev_slice_err, num_mb_skipped;\n    UWORD8 u1_mbaff;\n pocstruct_t *ps_cur_poc;\n\n    UWORD32 u4_temp;\n    WORD32 i_temp;\n    UWORD32 u4_call_end_of_pic = 0;\n\n /* read FirstMbInSlice  and slice type*/\n    ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;\n    u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n if(u2_first_mb_in_slice\n > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))\n {\n\n return ERROR_CORRUPTED_SLICE;\n }\n\n /*we currently don not support ASO*/\n if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)\n <= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n    COPYTHECONTEXT(\"SH: first_mb_in_slice\",u2_first_mb_in_slice);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > 9)\n return ERROR_INV_SLC_TYPE_T;\n\n    u1_slice_type = u4_temp;\n    COPYTHECONTEXT(\"SH: slice_type\",(u1_slice_type));\n /* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */\n /* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/\n /* will be of same type of current                            */\n if(u1_slice_type > 4)\n {\n        u1_slice_type -= 5;\n }\n\n {\n        UWORD32 skip;\n\n if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)\n || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))\n {\n            UWORD32 u4_bit_stream_offset = 0;\n\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else if((I_SLICE == u1_slice_type)\n && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else\n {\n                skip = 1;\n }\n\n /* If one frame worth of data is already skipped, do not skip the next one */\n if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))\n {\n                skip = 0;\n }\n\n if(skip)\n {\n                ps_dec->u4_prev_nal_skipped = 1;\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;\n return 0;\n }\n else\n {\n /* If the previous NAL was skipped, then\n                 do not process that buffer in this call.\n                 Return to app and process it in the next call.\n                 This is necessary to handle cases where I/IDR is not complete in\n                 the current buffer and application intends to fill the remaining part of the bitstream\n                 later. This ensures we process only frame worth of data in every call */\n if(1 == ps_dec->u4_prev_nal_skipped)\n {\n                    ps_dec->u4_return_to_app = 1;\n return 0;\n }\n }\n }\n\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_PIC_SET_ID)\n return ERROR_INV_SLICE_HDR_T;\n /* discard slice if pic param is invalid */\n    COPYTHECONTEXT(\"SH: pic_parameter_set_id\", u4_temp);\n    ps_pps = &ps_dec->ps_pps[u4_temp];\n if(FALSE == ps_pps->u1_is_valid)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n    ps_seq = ps_pps->ps_sps;\n if(!ps_seq)\n return ERROR_INV_SLICE_HDR_T;\n if(FALSE == ps_seq->u1_is_valid)\n return ERROR_INV_SLICE_HDR_T;\n\n /* Get the frame num */\n    u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,\n                                         ps_seq->u1_bits_in_frm_num);\n\n    COPYTHECONTEXT(\"SH: frame_num\", u2_frame_num);\n if(!ps_dec->u1_first_slice_in_stream && ps_dec->u4_first_slice_in_pic)\n {\n pocstruct_t *ps_prev_poc = &ps_dec->s_prev_pic_poc;\n pocstruct_t *ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n        ps_dec->u2_mbx = 0xffff;\n        ps_dec->u2_mby = 0;\n\n if((0 == u1_is_idr_slice) && ps_cur_slice->u1_nal_ref_idc)\n            ps_dec->u2_prev_ref_frame_num = ps_cur_slice->u2_frame_num;\n\n if(u1_is_idr_slice || ps_cur_slice->u1_mmco_equalto5)\n            ps_dec->u2_prev_ref_frame_num = 0;\n\n if(ps_dec->ps_cur_sps->u1_gaps_in_frame_num_value_allowed_flag)\n {\n            ih264d_decode_gaps_in_frame_num(ps_dec, u2_frame_num);\n }\n\n        ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n        ps_prev_poc->u2_frame_num = ps_cur_poc->u2_frame_num;\n        ps_prev_poc->u1_mmco_equalto5 = ps_cur_slice->u1_mmco_equalto5;\n if(ps_cur_slice->u1_nal_ref_idc)\n {\n            ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n            ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n            ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                            ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n            ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                            ps_cur_poc->i4_delta_pic_order_cnt[0];\n            ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                            ps_cur_poc->i4_delta_pic_order_cnt[1];\n            ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field;\n }\n\n        ps_dec->u2_total_mbs_coded = 0;\n }\n /* Get the field related flags  */\n if(!ps_seq->u1_frame_mbs_only_flag)\n {\n\n        u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);\n        COPYTHECONTEXT(\"SH: field_pic_flag\", u1_field_pic_flag);\n        u1_bottom_field_flag = 0;\n\n if(u1_field_pic_flag)\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;\n            u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: bottom_field_flag\", u1_bottom_field_flag);\n\n }\n else\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n }\n else\n {\n        u1_field_pic_flag = 0;\n        u1_bottom_field_flag = 0;\n\n        ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n\n    u1_nal_unit_type = SLICE_NAL;\n if(u1_is_idr_slice)\n {\n        u1_nal_unit_type = IDR_SLICE_NAL;\n        u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,\n                                   pu4_bitstrm_buf);\n if(u4_idr_pic_id > 65535)\n return ERROR_INV_SLICE_HDR_T;\n        COPYTHECONTEXT(\"SH:  \", u4_idr_pic_id);\n }\n\n /* read delta pic order count information*/\n    i_delta_poc[0] = i_delta_poc[1] = 0;\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;\n if(u1_pic_order_cnt_type == 0)\n {\n        i_temp = ih264d_get_bits_h264(\n                        ps_bitstrm,\n                        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);\n if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)\n return ERROR_INV_SLICE_HDR_T;\n        s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;\n        COPYTHECONTEXT(\"SH: pic_order_cnt_lsb\", s_tmp_poc.i4_pic_order_cnt_lsb);\n\n if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))\n {\n            s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt_bottom\",\n                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);\n }\n }\n\n    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;\n if(u1_pic_order_cnt_type == 1\n && (!ps_seq->u1_delta_pic_order_always_zero_flag))\n {\n        s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: delta_pic_order_cnt[0]\",\n                        s_tmp_poc.i4_delta_pic_order_cnt[0]);\n\n if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)\n {\n            s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt[1]\",\n                            s_tmp_poc.i4_delta_pic_order_cnt[1]);\n }\n }\n\n if(ps_pps->u1_redundant_pic_cnt_present_flag)\n {\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_REDUNDANT_PIC_CNT)\n return ERROR_INV_SLICE_HDR_T;\n        u1_redundant_pic_cnt = u4_temp;\n        COPYTHECONTEXT(\"SH: redundant_pic_cnt\", u1_redundant_pic_cnt);\n }\n\n /*--------------------------------------------------------------------*/\n /* Check if the slice is part of new picture                          */\n /*--------------------------------------------------------------------*/\n /* First slice of a picture is always considered as part of new picture */\n    i1_is_end_of_poc = 1;\n    ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;\n\n if(ps_dec->u4_first_slice_in_pic == 0)\n {\n        i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,\n &s_tmp_poc, &ps_dec->s_cur_pic_poc,\n                                            ps_cur_slice, u1_pic_order_cnt_type,\n                                            u1_nal_unit_type, u4_idr_pic_id,\n                                            u1_field_pic_flag,\n                                            u1_bottom_field_flag);\n if(i1_is_end_of_poc)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n }\n\n /*--------------------------------------------------------------------*/\n /* Check for error in slice and parse the missing/corrupted MB's      */\n /* as skip-MB's in an inserted P-slice                                */\n /*--------------------------------------------------------------------*/\n    u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);\n    prev_slice_err = 0;\n\n if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)\n {\n if(u2_frame_num != ps_dec->u2_prv_frame_num\n && ps_dec->u1_top_bottom_decoded != 0\n && ps_dec->u1_top_bottom_decoded\n != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))\n {\n            ps_dec->u1_dangling_field = 1;\n if(ps_dec->u4_first_slice_in_pic)\n {\n                prev_slice_err = 1;\n }\n else\n {\n                prev_slice_err = 2;\n }\n\n if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)\n                ps_cur_slice->u1_bottom_field_flag = 1;\n else\n                ps_cur_slice->u1_bottom_field_flag = 0;\n\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n            u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;\n }\n else if(ps_dec->u4_first_slice_in_pic)\n {\n if(u2_first_mb_in_slice > 0)\n {\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n                ps_cur_poc = &s_tmp_poc;\n\n                ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n                ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n                ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n                ps_cur_slice->i4_pic_order_cnt_lsb =\n                        s_tmp_poc.i4_pic_order_cnt_lsb;\n                ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n                ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n                ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n                ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n                ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n }\n }\n else\n {\n /* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame\n             * completely */\n            prev_slice_err = 2;\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs\n * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n }\n else\n {\n if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)\n {\n            prev_slice_err = 2;\n            num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)\n {\n return ERROR_CORRUPTED_SLICE;\n }\n }\n\n if(prev_slice_err)\n {\n        ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);\n\n if(ps_dec->u1_dangling_field == 1)\n {\n            ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;\n            ps_dec->u1_first_slice_in_stream = 0;\n            ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n return ERROR_DANGLING_FIELD_IN_PIC;\n }\n\n if(prev_slice_err == 2)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n /* return if all MBs in frame are parsed*/\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_IN_LAST_SLICE_OF_PIC;\n }\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n            ih264d_err_pic_dispbuf_mgr(ps_dec);\n return ERROR_NEW_FRAME_EXPECTED;\n }\n\n if(ret != OK)\n return ret;\n\n        i1_is_end_of_poc = 0;\n }\n\n if (ps_dec->u4_first_slice_in_pic == 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n        ps_dec->ps_decode_cur_slice++;\n }\n    ps_dec->u1_slice_header_done = 0;\n\n\n if(u1_field_pic_flag)\n {\n        ps_dec->u2_prv_frame_num = u2_frame_num;\n }\n\n if(ps_cur_slice->u1_mmco_equalto5)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n\n if(!ps_cur_slice->u1_field_pic_flag) // or a complementary field pair\n {\n            i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n            i4_bot_field_order_poc =\n                            ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n            i4_temp_poc = MIN(i4_top_field_order_poc,\n                                     i4_bot_field_order_poc);\n }\n else if(!ps_cur_slice->u1_bottom_field_flag)\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n else\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n\n        ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n if(ps_dec->u4_first_slice_in_pic)\n {\n        ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,\n &ps_dec->s_prev_pic_poc,\n &s_tmp_poc, ps_cur_slice, ps_pps,\n                                          u1_nal_ref_idc,\n                                          u1_bottom_field_flag,\n                                          u1_field_pic_flag, &i4_poc);\n if(ret != OK)\n return ret;\n /* Display seq no calculations */\n if(i4_poc >= ps_dec->i4_max_poc)\n            ps_dec->i4_max_poc = i4_poc;\n /* IDR Picture or POC wrap around */\n if(i4_poc == 0)\n {\n            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq\n + ps_dec->i4_max_poc\n + ps_dec->u1_max_dec_frame_buffering + 1;\n            ps_dec->i4_max_poc = 0;\n }\n }\n\n /*--------------------------------------------------------------------*/\n /* Copy the values read from the bitstream to the slice header and then*/\n /* If the slice is first slice in picture, then do Start of Picture   */\n /* processing.                                                        */\n /*--------------------------------------------------------------------*/\n    ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];\n    ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];\n    ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n    ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;\n    ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n    ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n    ps_cur_slice->u1_slice_type = u1_slice_type;\n    ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;\n\n    ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n    ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n    ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n    ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n\n if(ps_seq->u1_frame_mbs_only_flag)\n        ps_cur_slice->u1_direct_8x8_inference_flag =\n                        ps_seq->u1_direct_8x8_inference_flag;\n else\n        ps_cur_slice->u1_direct_8x8_inference_flag = 1;\n\n if(u1_slice_type == B_SLICE)\n {\n        ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SH: direct_spatial_mv_pred_flag\",\n                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);\n\n if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;\n else\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;\n }\n else\n {\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n }\n\n if(ps_dec->u4_first_slice_in_pic)\n {\n if(u2_first_mb_in_slice == 0)\n {\n            ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);\n if(ret != OK)\n return ret;\n }\n\n        ps_dec->u4_output_present = 0;\n\n {\n            ih264d_get_next_display_field(ps_dec,\n                                          ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n             hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                ps_dec->u4_output_present = 1;\n }\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                ps_dec->u4_start_recon_deblk = 0;\n                ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n\n }\n\n /* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */\n {\n        UWORD8 uc_nofield_nombaff;\n\n\n\n        uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)\n && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)\n && (u1_slice_type != B_SLICE)\n && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));\n\n /* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */\n\n if(uc_nofield_nombaff)\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n }\n else\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;\n }\n\n\n }\n\n /*\n     * Decide whether to decode the current picture or not\n     */\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_err->u4_frm_sei_sync == u2_frame_num)\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n            ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n }\n        ps_err->u4_cur_frm = u2_frame_num;\n }\n\n /* Decision for decoding if the picture is to be skipped */\n {\n        WORD32 i4_skip_b_pic, i4_skip_p_pic;\n\n        i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)\n && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n        i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)\n && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n /**************************************************************/\n /* Skip the B picture if skip mask is set for B picture and   */\n /* Current B picture is a non reference B picture or there is */\n /* no user for reference B picture                            */\n /**************************************************************/\n if(i4_skip_b_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n /* Don't decode the picture in SKIP-B mode if that picture is B */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n /**************************************************************/\n /* Skip the P picture if skip mask is set for P picture and   */\n /* Current P picture is a non reference P picture or there is */\n /* no user for reference P picture                            */\n /**************************************************************/\n if(i4_skip_p_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n /* Don't decode the picture in SKIP-P mode if that picture is P */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n }\n\n {\n        UWORD16 u2_mb_x, u2_mb_y;\n\n        ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice\n << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)\n - SUB_BLK_SIZE;\n if(u2_first_mb_in_slice)\n {\n            UWORD8 u1_mb_aff;\n            UWORD8 u1_field_pic;\n            UWORD16 u2_frm_wd_in_mbs;\n            u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n            u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;\n            u1_field_pic = ps_cur_slice->u1_field_pic_flag;\n\n {\n                UWORD32 x_offset;\n                UWORD32 y_offset;\n                UWORD32 u4_frame_stride;\n tfr_ctxt_t *ps_trns_addr; // = &ps_dec->s_tran_addrecon_parse;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n                u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n                u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n\n                u2_mb_y <<= u1_mb_aff;\n\n if((u2_mb_x > u2_frm_wd_in_mbs - 1)\n || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n                u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;\n                x_offset = u2_mb_x << 4;\n                y_offset = (u2_mb_y * u4_frame_stride) << 4;\n\n                ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset\n + y_offset;\n\n                u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;\n                x_offset >>= 1;\n                y_offset = (u2_mb_y * u4_frame_stride) << 3;\n\n                x_offset *= YUV420SP_FACTOR;\n\n                ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset\n + y_offset;\n                ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset\n + y_offset;\n\n                ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n                ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n                ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n\n if(ps_dec->u1_separate_parse == 1)\n {\n                    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n else\n {\n                        ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n\n                ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);\n\n                ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv\n + ((u2_first_mb_in_slice << u1_mb_aff) << 4);\n }\n }\n else\n {\n tfr_ctxt_t *ps_trns_addr;\n\n if(ps_dec->u1_separate_parse)\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n\n            u2_mb_x = 0xffff;\n            u2_mb_y = 0;\n            ps_dec->u2_cur_mb_addr = 0;\n            ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n            ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n            ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n            ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n            ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n            ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n            ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n            ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n }\n\n        ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n        ps_dec->u2_mbx =\n (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby =\n (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;\n        ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n        ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n }\n\n /* RBSP stop bit is used for CABAC decoding*/\n    ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;\n\n    ps_dec->u1_B = (u1_slice_type == B_SLICE);\n    ps_dec->u4_next_mb_skip = 0;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =\n                    ps_dec->ps_cur_slice->u2_first_mb_in_slice;\n    ps_dec->ps_parse_cur_slice->slice_type =\n                    ps_dec->ps_cur_slice->u1_slice_type;\n\n\n    ps_dec->u4_start_recon_deblk = 1;\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n (0 == ps_dec->i4_display_delay))\n {\n            num_entries = 1;\n }\n        num_entries = ((2 * num_entries) + 1);\n        num_entries *= 2;\n\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;\n }\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n if(u1_slice_type == I_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;\n\n        ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);\n\n if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)\n            ps_dec->i4_pic_type = I_SLICE;\n\n }\n else if(u1_slice_type == P_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n        ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n if(ps_dec->i4_pic_type != B_SLICE)\n            ps_dec->i4_pic_type = P_SLICE;\n }\n else if(u1_slice_type == B_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n        ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n        ps_dec->i4_pic_type = B_SLICE;\n }\n else\n return ERROR_INV_SLC_TYPE_T;\n\n if(ps_dec->u1_slice_header_done)\n {\n /* set to zero to indicate a valid slice has been decoded */\n        ps_dec->u1_first_slice_in_stream = 0;\n }\n\n\n     if(ret != OK)\n         return ret;\n \n     /* storing last Mb X and MbY of the slice */\n     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n /* End of Picture detection */\n\n if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))\n {\n        ps_dec->u1_pic_decode_done = 1;\n\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if((ps_err->u1_err_flag & REJECT_PB_PICS)\n && (ps_err->u1_cur_pic_type == PIC_TYPE_I))\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n    PRINT_BIN_BIT_RATIO(ps_dec)\n\n return ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ff_amf_write_null(uint8_t **dst)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_NULL);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Performance::PassesTimingAllowCheck(\n    const ResourceResponse& response,\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n   scoped_refptr<const SecurityOrigin> resource_origin =\n      SecurityOrigin::Create(response.Url());\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n \n  const AtomicString& timing_allow_origin_string =\n      original_timing_allow_origin.IsEmpty()\n          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\n          : original_timing_allow_origin;\n  if (timing_allow_origin_string.IsEmpty() ||\n      EqualIgnoringASCIICase(timing_allow_origin_string, \"null\"))\n    return false;\n\n  if (timing_allow_origin_string == \"*\") {\n    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);\n    return true;\n  }\n\n  const String& security_origin = initiator_security_origin.ToString();\n  Vector<String> timing_allow_origins;\n  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);\n  if (timing_allow_origins.size() > 1) {\n    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);\n  } else if (timing_allow_origins.size() == 1 &&\n             timing_allow_origin_string != \"*\") {\n    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);\n  }\n  for (const String& allow_origin : timing_allow_origins) {\n    const String allow_origin_stripped = allow_origin.StripWhiteSpace();\n    if (allow_origin_stripped == security_origin ||\n        allow_origin_stripped == \"*\") {\n      return true;\n    }\n  }\n\n  return false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PHP_FUNCTION(snmp2_set)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_SET, SNMP_VERSION_2c);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void __net_exit ip6mr_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ip6_mr_cache\", net->proc_net);\n\tremove_proc_entry(\"ip6_mr_vif\", net->proc_net);\n#endif\n\tip6mr_rules_exit(net);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void LocalFileSystem::deleteFileSystemInternal(\n     PassRefPtrWillBeRawPtr<ExecutionContext> context,\n     FileSystemType type,\n    PassRefPtr<CallbackWrapper> callbacks)\n {\n     if (!fileSystem()) {\n         fileSystemNotAvailable(context, callbacks);\n        return;\n    }\n    KURL storagePartition = KURL(KURL(), context->securityOrigin()->toString());\n    fileSystem()->deleteFileSystem(storagePartition, static_cast<WebFileSystemType>(type), callbacks->release());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ScriptResource::OnMemoryDump(WebMemoryDumpLevelOfDetail level_of_detail,\n                                  WebProcessMemoryDump* memory_dump) const {\n  Resource::OnMemoryDump(level_of_detail, memory_dump);\n  const String name = GetMemoryDumpName() + \"/decoded_script\";\n  auto* dump = memory_dump->CreateMemoryAllocatorDump(name);\n  dump->AddScalar(\"size\", \"bytes\", source_text_.CharactersSizeInBytes());\n  memory_dump->AddSuballocation(\n      dump->Guid(), String(WTF::Partitions::kAllocatedObjectPoolName));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n \t\t\tbreak;\n \t\t}\n \n \t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n \t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n \n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ScreenPositionController::ConvertHostPointToRelativeToRootWindow(\n    aura::Window* root_window,\n    const aura::Window::Windows& root_windows,\n    gfx::Point* point,\n    aura::Window** target_root) {\n  DCHECK(!root_window->parent());\n   gfx::Point point_in_root(*point);\n   root_window->GetHost()->ConvertPointFromHost(&point_in_root);\n \n  *target_root = root_window;\n  *point = point_in_root;\n #if defined(USE_X11) || defined(USE_OZONE)\n  if (!root_window->GetHost()->GetBounds().Contains(*point)) {\n\n    gfx::Point location_in_native(point_in_root);\n\n    root_window->GetHost()->ConvertPointToNativeScreen(&location_in_native);\n\n    for (size_t i = 0; i < root_windows.size(); ++i) {\n      aura::WindowTreeHost* host = root_windows[i]->GetHost();\n      const gfx::Rect native_bounds = host->GetBounds();\n      if (native_bounds.Contains(location_in_native)) {\n         *target_root = root_windows[i];\n         *point = location_in_native;\n         host->ConvertPointFromNativeScreen(point);\n        break;\n       }\n     }\n   }\n#else\n  NOTIMPLEMENTED();\n #endif\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t MPEG4Extractor::parse3GPPMetaData(off64_t offset, size_t size, int depth) {\n if (size < 4 || size == SIZE_MAX) {\n return ERROR_MALFORMED;\n }\n\n uint8_t *buffer = new (std::nothrow) uint8_t[size + 1];\n if (buffer == NULL) {\n return ERROR_MALFORMED;\n }\n if (mDataSource->readAt(\n                offset, buffer, size) != (ssize_t)size) {\n delete[] buffer;\n        buffer = NULL;\n\n return ERROR_IO;\n }\n\n uint32_t metadataKey = 0;\n switch (mPath[depth]) {\n case FOURCC('t', 'i', 't', 'l'):\n {\n            metadataKey = kKeyTitle;\n break;\n }\n case FOURCC('p', 'e', 'r', 'f'):\n {\n            metadataKey = kKeyArtist;\n break;\n }\n case FOURCC('a', 'u', 't', 'h'):\n {\n            metadataKey = kKeyWriter;\n break;\n }\n case FOURCC('g', 'n', 'r', 'e'):\n {\n            metadataKey = kKeyGenre;\n break;\n }\n case FOURCC('a', 'l', 'b', 'm'):\n {\n if (buffer[size - 1] != '\\0') {\n char tmp[4];\n              sprintf(tmp, \"%u\", buffer[size - 1]);\n\n              mFileMetaData->setCString(kKeyCDTrackNumber, tmp);\n }\n\n            metadataKey = kKeyAlbum;\n break;\n }\n case FOURCC('y', 'r', 'r', 'c'):\n {\n char tmp[5];\n uint16_t year = U16_AT(&buffer[4]);\n\n if (year < 10000) {\n                sprintf(tmp, \"%u\", year);\n\n                mFileMetaData->setCString(kKeyYear, tmp);\n }\n break;\n }\n\n default:\n break;\n }\n\n if (metadataKey > 0) {\n bool isUTF8 = true; // Common case\n char16_t *framedata = NULL;\n\n         int len16 = 0; // Number of UTF-16 characters\n \n         if (size - 6 >= 4) {\n             len16 = ((size - 6) / 2) - 1; // don't include 0x0000 terminator\n             framedata = (char16_t *)(buffer + 6);\n if (0xfffe == *framedata) {\n for (int i = 0; i < len16; i++) {\n                    framedata[i] = bswap_16(framedata[i]);\n }\n }\n\n if (0xfeff == *framedata) {\n                framedata++;\n                len16--;\n                isUTF8 = false;\n }\n }\n\n if (isUTF8) {\n            buffer[size] = 0;\n            mFileMetaData->setCString(metadataKey, (const char *)buffer + 6);\n } else {\n String8 tmpUTF8str(framedata, len16);\n            mFileMetaData->setCString(metadataKey, tmpUTF8str.string());\n }\n }\n\n delete[] buffer;\n    buffer = NULL;\n\n return OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int vivid_fb_blank(int blank_mode, struct fb_info *info)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\n\tdprintk(dev, 1, \"Set blanking mode : %d\\n\", blank_mode);\n\tswitch (blank_mode) {\n\tcase FB_BLANK_UNBLANK:\n\t\tbreak;\n\tcase FB_BLANK_NORMAL:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_POWERDOWN:\n\t\tbreak;\n\t}\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\tint ret;\n\n#ifdef CONFIG_STACK_GROWSUP\n\tif (write) {\n\t\tret = expand_downwards(bprm->vma, pos);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n#endif\n\tret = get_user_pages(current, bprm->mm, pos,\n\t\t\t1, write, 1, &page, NULL);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (write) {\n\t\tunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\n\t\tstruct rlimit *rlim;\n\n\t\tacct_arg_size(bprm, size / PAGE_SIZE);\n\n\t\t/*\n\t\t * We've historically supported up to 32 pages (ARG_MAX)\n\t\t * of argument strings even with small stacks\n\t\t */\n\t\tif (size <= ARG_MAX)\n\t\t\treturn page;\n\n\t\t/*\n\t\t * Limit to 1/4-th the stack size for the argv+env strings.\n\t\t * This ensures that:\n\t\t *  - the remaining binfmt code will not run out of stack space,\n\t\t *  - the program will have a reasonable amount of stack left\n\t\t *    to work from.\n\t\t */\n\t\trlim = current->signal->rlim;\n\t\tif (size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur) / 4) {\n\t\t\tput_page(page);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn page;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BrowserTabStripController::TabPinnedStateChanged(WebContents* contents,\n                                                      int model_index) {\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "main (int argc _GL_UNUSED, char **argv)\n{\n  struct timespec result;\n  struct timespec result2;\n  struct timespec expected;\n  struct timespec now;\n  const char *p;\n  int i;\n  long gmtoff;\n  time_t ref_time = 1304250918;\n\n  /* Set the time zone to US Eastern time with the 2012 rules.  This\n     should disable any leap second support.  Otherwise, there will be\n     a problem with glibc on sites that default to leap seconds; see\n     <http://bugs.gnu.org/12206>.  */\n  setenv (\"TZ\", \"EST5EDT,M3.2.0,M11.1.0\", 1);\n\n  gmtoff = gmt_offset (ref_time);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, local time zone */\n  p = \"2011-05-01T11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, local time zone */\n  p = \"2011-05-01 11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601, extended date and time of day representation,\n     'T' separator, UTC */\n  p = \"2011-05-01T11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601, extended date and time of day representation,\n     ' ' separator, UTC */\n  p = \"2011-05-01 11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/UTC offset */\n  p = \"2011-05-01T11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/UTC offset */\n  p = \"2011-05-01 11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/hour only UTC offset */\n  p = \"2011-05-01T11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/hour only UTC offset */\n  p = \"2011-05-01 11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec == result.tv_sec && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec - 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"4 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 4 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  /* test if timezone is not being ignored for day offset */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 +24 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* test if several time zones formats are handled same way */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC-1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+0:15\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+0015\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-1:30\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-130\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n\n  /* TZ out of range should cause parse_datetime failure */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+25:00\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n        /* Check for several invalid countable dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+4:00 +40 yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 next yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow hence\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 40 now ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 last tomorrow\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 -4 today\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n  /* And check correct usage of dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+400 1 day hence\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 1 day ago\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +0 minutes\"; /* silly, but simple \"UTC+400\" is different*/\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* Check that some \"next Monday\", \"last Wednesday\", etc. are correct.  */\n  setenv (\"TZ\", \"UTC0\", 1);\n  for (i = 0; day_table[i]; i++)\n    {\n      unsigned int thur2 = 7 * 24 * 3600; /* 2nd thursday */\n      char tmp[32];\n      sprintf (tmp, \"NEXT %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + (i == 4 ? 7 : (i + 3) % 7) * 24 * 3600);\n\n      sprintf (tmp, \"LAST %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + ((i + 3) % 7 - 7) * 24 * 3600);\n    }\n\n  p = \"THURSDAY UTC+00\";  /* The epoch was on Thursday.  */\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == now.tv_sec\n          && result.tv_nsec == now.tv_nsec);\n\n  p = \"FRIDAY UTC+00\";\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == 24 * 3600\n          && result.tv_nsec == now.tv_nsec);\n\n  /* Exercise a sign-extension bug.  Before July 2012, an input\n     starting with a high-bit-set byte would be treated like \"0\".  */\n  ASSERT ( ! parse_datetime (&result, \"\\xb0\", &now));\n\n  /* Exercise TZ=\"\" parsing code.  */\n  /* These two would infloop or segfault before Feb 2014.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\"\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\" \\\"\", &now));\n  /* Exercise invalid patterns.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\\\"\", &now));\n  /* Exercise valid patterns.  */\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\" \", &now));\n  ASSERT (   parse_datetime (&result, \" TZ=\\\"\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\\\\\"\", &now));\n   ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\"\\\"\", &now));\n \n   return 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "madvise_behavior_valid(int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_DOFORK:\n\tcase MADV_DONTFORK:\n\tcase MADV_NORMAL:\n\tcase MADV_SEQUENTIAL:\n\tcase MADV_RANDOM:\n\tcase MADV_REMOVE:\n\tcase MADV_WILLNEED:\n\tcase MADV_DONTNEED:\n#ifdef CONFIG_KSM\n\tcase MADV_MERGEABLE:\n\tcase MADV_UNMERGEABLE:\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tcase MADV_HUGEPAGE:\n\tcase MADV_NOHUGEPAGE:\n#endif\n\tcase MADV_DONTDUMP:\n\tcase MADV_DODUMP:\n\t\treturn 1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void sctp_cmd_hb_timers_stop(sctp_cmd_seq_t *cmds,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\t/* Stop all heartbeat timers. */\n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\tif (del_timer(&t->hb_timer))\n\t\t\tsctp_transport_put(t);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "uint32_t ide_data_readl(void *opaque, uint32_t addr)\n{\n    IDEBus *bus = opaque;\n    IDEState *s = idebus_active_if(bus);\n    uint8_t *p;\n    int ret;\n\n    /* PIO data access allowed only when DRQ bit is set. The result of a read\n     * during PIO in is indeterminate, return 0 and don't move forward. */\n    if (!(s->status & DRQ_STAT) || !ide_is_pio_out(s)) {\n        return 0;\n    }\n\n    p = s->data_ptr;\n    ret = cpu_to_le32(*(uint32_t *)p);\n    p += 4;\n    s->data_ptr = p;\n    if (p >= s->data_end)\n        s->end_transfer_func(s);\n    return ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void opj_get_all_encoding_parameters(   const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res,\n                                        OPJ_UINT32 ** p_resolutions )\n{\n\t/* loop*/\n\tOPJ_UINT32 compno, resno;\n\n\t/* pointers*/\n\tconst opj_tcp_t *tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* to store l_dx, l_dy, w and h for each resolution and component.*/\n\tOPJ_UINT32 * lResolutionPtr;\n\n\t/* position in x and y of tile*/\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n \tq = tileno / p_cp->tw;\n \n \t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n \n \t/* max precision and resolution is 0 (can only grow)*/\n \t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* aritmetic variables to calculate*/\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\t\tOPJ_UINT32 l_pdx, l_pdy , l_pw , l_ph;\n\n\t\tlResolutionPtr = p_resolutions[compno];\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts*/\n\t\tl_level_no = l_tccp->numresolutions - 1;\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height*/\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t*lResolutionPtr++ = l_pdx;\n\t\t\t*lResolutionPtr++ = l_pdy;\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n\t\t\t/* take the minimum size for l_dx for each comp and resolution*/\n\t\t\t*p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dx_min, (OPJ_INT32)l_dx);\n\t\t\t*p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dy_min, (OPJ_INT32)l_dy);\n\n\t\t\t/* various calculations of extents*/\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\t\t\t*lResolutionPtr++ = l_pw;\n\t\t\t*lResolutionPtr++ = l_ph;\n\t\t\tl_product = l_pw * l_ph;\n\t\t\t\n            /* update precision*/\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\n\t\t\t--l_level_no;\n\t\t}\n\t\t++l_tccp;\n\t\t++l_img_comp;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n  unsigned char *chroma1,unsigned char *chroma2,ExceptionInfo *exception)\n{\n#define IsSync(sum)  ((sum & 0xffffff00UL) == 0xfffffe00UL)\n#define PCDGetBits(n) \\\n{  \\\n  sum=(sum << n) & 0xffffffff; \\\n  bits-=n; \\\n  while (bits <= 24) \\\n  { \\\n    if (p >= (buffer+0x800)) \\\n      { \\\n        count=ReadBlob(image,0x800,buffer); \\\n        p=buffer; \\\n      } \\\n    sum|=((unsigned int) (*p) << (24-bits)); \\\n    bits+=8; \\\n    p++; \\\n  } \\\n}\n\n  typedef struct PCDTable\n  {\n    unsigned int\n      length,\n      sequence;\n\n    MagickStatusType\n      mask;\n\n    unsigned char\n      key;\n  } PCDTable;\n\n  PCDTable\n    *pcd_table[3];\n\n  register ssize_t\n    i,\n    j;\n\n  register PCDTable\n    *r;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bits,\n    length,\n    plane,\n    pcd_length[3],\n    row,\n    sum;\n\n  ssize_t\n    count,\n    quantum;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Initialize Huffman tables.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(luma != (unsigned char *) NULL);\n  assert(chroma1 != (unsigned char *) NULL);\n  assert(chroma2 != (unsigned char *) NULL);\n  buffer=(unsigned char *) AcquireQuantumMemory(0x800,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  sum=0;\n  bits=32;\n  p=buffer+0x800;\n  for (i=0; i < 3; i++)\n  {\n    pcd_table[i]=(PCDTable *) NULL;\n    pcd_length[i]=0;\n  }\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n  {\n    PCDGetBits(8);\n    length=(sum & 0xff)+1;\n    pcd_table[i]=(PCDTable *) AcquireQuantumMemory(length,\n      sizeof(*pcd_table[i]));\n     if (pcd_table[i] == (PCDTable *) NULL)\n       {\n         buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n         ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n           image->filename);\n       }\n    r=pcd_table[i];\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      PCDGetBits(8);\n      r->length=(unsigned int) (sum & 0xff)+1;\n       if (r->length > 16)\n         {\n           buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n           return(MagickFalse);\n         }\n       PCDGetBits(16);\n      r->sequence=(unsigned int) (sum & 0xffff) << 16;\n      PCDGetBits(8);\n      r->key=(unsigned char) (sum & 0xff);\n      r->mask=(~((1U << (32-r->length))-1));\n      r++;\n    }\n    pcd_length[i]=(size_t) length;\n  }\n  /*\n    Search for Sync byte.\n  */\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  while ((sum & 0x00fff000UL) != 0x00fff000UL)\n    PCDGetBits(8);\n  while (IsSync(sum) == 0)\n    PCDGetBits(1);\n  /*\n    Recover the Huffman encoded luminance and chrominance deltas.\n  */\n  count=0;\n  length=0;\n  plane=0;\n  row=0;\n  q=luma;\n  for ( ; ; )\n  {\n    if (IsSync(sum) != 0)\n      {\n        /*\n          Determine plane and row number.\n        */\n        PCDGetBits(16);\n        row=((sum >> 9) & 0x1fff);\n        if (row == image->rows)\n          break;\n        PCDGetBits(8);\n        plane=sum >> 30;\n        PCDGetBits(16);\n        switch (plane)\n        {\n          case 0:\n          {\n            q=luma+row*image->columns;\n            count=(ssize_t) image->columns;\n            break;\n          }\n          case 2:\n          {\n            q=chroma1+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          case 3:\n          {\n            q=chroma2+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          default:\n          {\n            for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n              pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n            ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n              image->filename);\n          }\n        }\n        length=pcd_length[plane];\n        continue;\n      }\n    /*\n      Decode luminance or chrominance deltas.\n    */\n    r=pcd_table[plane];\n    for (i=0; ((i < (ssize_t) length) && ((sum & r->mask) != r->sequence)); i++)\n      r++;\n    if ((row > image->rows) || (r == (PCDTable *) NULL))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        while ((sum & 0x00fff000) != 0x00fff000)\n          PCDGetBits(8);\n        while (IsSync(sum) == 0)\n          PCDGetBits(1);\n        continue;\n      }\n    if (r->key < 128)\n      quantum=(ssize_t) (*q)+r->key;\n    else\n      quantum=(ssize_t) (*q)+r->key-256;\n    *q=(unsigned char) ((quantum < 0) ? 0 : (quantum > 255) ? 255 : quantum);\n    q++;\n    PCDGetBits(r->length);\n    count--;\n  }\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n    pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(MagickTrue);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BluetoothOptionsHandler::DisplayPasskey(\n     chromeos::BluetoothDevice* device,\n     int passkey,\n     int entered) {\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n \t\trefs++;\n \t} while (addr += PAGE_SIZE, addr != end);\n \n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n \t\t*nr -= refs;\n \t\treturn 0;\n \t}\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int sco_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tsco_sock_clear_timer(sk);\n\t\t__sco_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t\t sk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Sampler* GetSampler(GLuint client_id) {\n    return sampler_manager()->GetSampler(client_id);\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void overloadedMethodAMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::overloadedMethodAMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int misaligned_fpu_load(struct pt_regs *regs,\n\t\t\t   __u32 opcode,\n\t\t\t   int displacement_not_indexed,\n\t\t\t   int width_shift,\n\t\t\t   int do_paired_load)\n{\n\t/* Return -1 for a fault, 0 for OK */\n\tint error;\n\tint destreg;\n\t__u64 address;\n\n\terror = generate_and_check_address(regs, opcode,\n\t\t\tdisplacement_not_indexed, width_shift, &address);\n\tif (error < 0) {\n \t\treturn error;\n \t}\n \n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, address);\n \n \tdestreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n\t\t__u64 buffer;\n\t\t__u32 buflo, bufhi;\n\n\t\tif (!access_ok(VERIFY_READ, (unsigned long) address, 1UL<<width_shift)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (__copy_user(&buffer, (const void *)(int)address, (1 << width_shift)) > 0) {\n\t\t\treturn -1; /* fault */\n\t\t}\n\t\t/* 'current' may be the current owner of the FPU state, so\n\t\t   context switch the registers into memory so they can be\n\t\t   indexed by register number. */\n\t\tif (last_task_used_math == current) {\n\t\t\tenable_fpu();\n\t\t\tsave_fpu(current);\n\t\t\tdisable_fpu();\n\t\t\tlast_task_used_math = NULL;\n\t\t\tregs->sr |= SR_FD;\n\t\t}\n\n\t\tbuflo = *(__u32*) &buffer;\n\t\tbufhi = *(1 + (__u32*) &buffer);\n\n\t\tswitch (width_shift) {\n\t\tcase 2:\n\t\t\tcurrent->thread.xstate->hardfpu.fp_regs[destreg] = buflo;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (do_paired_load) {\n\t\t\t\tcurrent->thread.xstate->hardfpu.fp_regs[destreg] = buflo;\n\t\t\t\tcurrent->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi;\n\t\t\t} else {\n#if defined(CONFIG_CPU_LITTLE_ENDIAN)\n\t\t\t\tcurrent->thread.xstate->hardfpu.fp_regs[destreg] = bufhi;\n\t\t\t\tcurrent->thread.xstate->hardfpu.fp_regs[destreg+1] = buflo;\n#else\n\t\t\t\tcurrent->thread.xstate->hardfpu.fp_regs[destreg] = buflo;\n\t\t\t\tcurrent->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_fpu_load, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tdie (\"Misaligned FPU load inside kernel\", regs, 0);\n\t\treturn -1;\n\t}\n\n\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int airspy_querycap(struct file *file, void *fh,\n\t\tstruct v4l2_capability *cap)\n{\n\tstruct airspy *s = video_drvdata(file);\n\n\tstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrlcpy(cap->card, s->vdev.name, sizeof(cap->card));\n\tusb_make_path(s->udev, cap->bus_info, sizeof(cap->bus_info));\n\tcap->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\n\t\t\tV4L2_CAP_READWRITE | V4L2_CAP_TUNER;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CL_InitRenderer( void ) {\n\tre.BeginRegistration( &cls.glconfig );\n\n\tcls.charSetShader = re.RegisterShader( \"gfx/2d/bigchars\" );\n\tcls.whiteShader = re.RegisterShader( \"white\" );\n\tcls.consoleShader = re.RegisterShader( \"console\" );\n\tg_console_field_width = cls.glconfig.vidWidth / SMALLCHAR_WIDTH - 2;\n\tg_consoleField.widthInChars = g_console_field_width;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-269"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "e1000e_intrmgr_resume(E1000ECore *core)\n{\n    int i;\n\n    e1000e_intmgr_timer_resume(&core->radv);\n    e1000e_intmgr_timer_resume(&core->rdtr);\n    e1000e_intmgr_timer_resume(&core->raid);\n    e1000e_intmgr_timer_resume(&core->tidv);\n    e1000e_intmgr_timer_resume(&core->tadv);\n\n    e1000e_intmgr_timer_resume(&core->itr);\n\n    for (i = 0; i < E1000E_MSIX_VEC_NUM; i++) {\n        e1000e_intmgr_timer_resume(&core->eitr[i]);\n    }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-835"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "openvpn_decrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  static const char error_prefix[] = \"Authenticate/Decrypt packet error\";\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;\n      struct packet_id_net pin;\n      bool have_pin = false;\n\n      /* Verify the HMAC */\n      if (ctx->hmac)\n\t{\n\t  int hmac_len;\n\t  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */\n\n\t  hmac_ctx_reset(ctx->hmac);\n\n\t  /* Assume the length of the input HMAC */\n\t  hmac_len = hmac_ctx_size (ctx->hmac);\n\n\t  /* Authentication fails if insufficient data in packet for HMAC */\n\t  if (buf->len < hmac_len)\n\t    CRYPT_ERROR (\"missing authentication info\");\n\n\t  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);\n \t  hmac_ctx_final (ctx->hmac, local_hmac);\n \n \t  /* Compare locally computed HMAC with packet HMAC */\n\t  if (memcmp (local_hmac, BPTR (buf), hmac_len))\n \t    CRYPT_ERROR (\"packet HMAC authentication failed\");\n \n \t  ASSERT (buf_advance (buf, hmac_len));\n\t}\n\n      /* Decrypt packet ID + payload */\n\n      if (ctx->cipher)\n\t{\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  int outlen;\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));\n\n\t  /* use IV if user requested it */\n\t  CLEAR (iv_buf);\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      if (buf->len < iv_size)\n\t\tCRYPT_ERROR (\"missing IV info\");\n\t      memcpy (iv_buf, BPTR (buf), iv_size);\n\t      ASSERT (buf_advance (buf, iv_size));\n\t    }\n\n\t  /* show the IV's initial state */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"DECRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  if (buf->len < 1)\n\t    CRYPT_ERROR (\"missing payload\");\n\n\t  /* ctx->cipher was already initialized with key & keylen */\n\t  if (!cipher_ctx_reset (ctx->cipher, iv_buf))\n\t    CRYPT_ERROR (\"cipher init failed\");\n\n\t  /* Buffer overflow check (should never happen) */\n\t  if (!buf_safe (&work, buf->len))\n\t    CRYPT_ERROR (\"buffer overflow\");\n\n\t  /* Decrypt packet ID, payload */\n\t  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))\n\t    CRYPT_ERROR (\"cipher update failed\");\n\t  work.len += outlen;\n\n\t  /* Flush the decryption buffer */\n\t  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))\n\t    CRYPT_ERROR (\"cipher final failed\");\n\t  work.len += outlen;\n\n\t  dmsg (D_PACKET_CONTENT, \"DECRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\n\t  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */\n\t  {\n\t    if (mode == OPENVPN_MODE_CBC)\n\t      {\n\t\tif (opt->packet_id)\n\t\t  {\n\t\t    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\t      CRYPT_ERROR (\"error reading CBC packet-id\");\n\t\t    have_pin = true;\n\t\t  }\n\t      }\n\t    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t      {\n\t\tstruct buffer b;\n\n\t\tASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t\tASSERT (opt->packet_id); /*  for this mode. */\n\n\t\tbuf_set_read (&b, iv_buf, iv_size);\n\t\tif (!packet_id_read (&pin, &b, true))\n\t\t  CRYPT_ERROR (\"error reading CFB/OFB packet-id\");\n\t\thave_pin = true;\n\t      }\n\t    else /* We only support CBC, CFB, or OFB modes right now */\n\t      {\n\t\tASSERT (0);\n\t      }\n\t  }\n\t}\n      else\n\t{\n\t  work = *buf;\n\t  if (opt->packet_id)\n\t    {\n\t      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\tCRYPT_ERROR (\"error reading packet-id\");\n\t      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);\n\t    }\n\t}\n      \n      if (have_pin)\n\t{\n\t  packet_id_reap_test (&opt->packet_id->rec);\n\t  if (packet_id_test (&opt->packet_id->rec, &pin))\n\t    {\n\t      packet_id_add (&opt->packet_id->rec, &pin);\n\t      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))\n\t\tpacket_id_persist_save_obj (opt->pid_persist, opt->packet_id);\n\t    }\n\t  else\n\t    {\n\t      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))\n\t      msg (D_REPLAY_ERRORS, \"%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings\",\n\t\t   error_prefix, packet_id_net_print (&pin, true, &gc));\n\t      goto error_exit;\n\t    }\n\t}\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return true;\n\n error_exit:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "_our_safe_malloc(size_t len, const char *funcname, const int line, const char *file)\n{\n    u_char *ptr;\n\n    if ((ptr = malloc(len)) == NULL) {\n        fprintf(stderr, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes/n\",\n                file, funcname, line, len);\n        exit(-1);\n    }\n\n    /* zero memory */\n    memset(ptr, 0, len);\n\n    /* wrapped inside an #ifdef for better performance */\n    dbgx(5, \"Malloc'd %zu bytes in %s:%s() line %d\", len, file, funcname, line);\n\n    return (void *)ptr;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MagickExport BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)\n{\n  BlobInfo\n    *clone_info;\n\n  SemaphoreInfo\n    *semaphore;\n\n  clone_info=(BlobInfo *) AcquireMagickMemory(sizeof(*clone_info));\n  GetBlobInfo(clone_info);\n  if (blob_info == (BlobInfo *) NULL)\n    return(clone_info);\n  semaphore=clone_info->semaphore;\n  (void) memcpy(clone_info,blob_info,sizeof(*clone_info));\n  if (blob_info->mapped != MagickFalse)\n    (void) AcquireMagickResource(MapResource,blob_info->length);\n  clone_info->semaphore=semaphore;\n  LockSemaphoreInfo(clone_info->semaphore);\n  clone_info->reference_count=1;\n  UnlockSemaphoreInfo(clone_info->semaphore);\n  return(clone_info);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "poppler_color_new (void)\n{\n  return (PopplerColor *) g_new0 (PopplerColor, 1);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t OMXNodeInstance::useGraphicBuffer(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id *buffer) {\n Mutex::Autolock autoLock(mLock);\n\n    OMX_INDEXTYPE index;\n if (OMX_GetExtensionIndex(\n            mHandle,\n const_cast<OMX_STRING>(\"OMX.google.android.index.useAndroidNativeBuffer2\"),\n &index) == OMX_ErrorNone) {\n return useGraphicBuffer2_l(portIndex, graphicBuffer, buffer);\n }\n\n    OMX_STRING name = const_cast<OMX_STRING>(\n \"OMX.google.android.index.useAndroidNativeBuffer\");\n    OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, name, &index);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(getExtensionIndex, err, \"%s\", name);\n\n         return StatusFromOMXError(err);\n     }\n \n    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n    OMX_VERSIONTYPE ver;\n    ver.s.nVersionMajor = 1;\n    ver.s.nVersionMinor = 0;\n    ver.s.nRevision = 0;\n    ver.s.nStep = 0;\n UseAndroidNativeBufferParams params = {\n sizeof(UseAndroidNativeBufferParams), ver, portIndex, bufferMeta,\n &header, graphicBuffer,\n };\n\n    err = OMX_SetParameter(mHandle, index, &params);\n\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(setParameter, err, \"%s(%#x): %s:%u meta=%p GB=%p\", name, index,\n                portString(portIndex), portIndex, bufferMeta, graphicBuffer->handle);\n\n delete bufferMeta;\n        bufferMeta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, bufferMeta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n    CLOG_BUFFER(useGraphicBuffer, NEW_BUFFER_FMT(\n *buffer, portIndex, \"GB=%p\", graphicBuffer->handle));\n return OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n {\n \tstruct n_tty_data *ldata = tty->disc_data;\n \n\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\n \t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n \t\tldata->line_start = ldata->read_tail;\n \t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n\t\t\tldata->canon_head = ldata->read_tail;\n\t\t\tldata->push = 0;\n\t\t} else {\n\t\t\tset_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),\n\t\t\t\tldata->read_flags);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tldata->push = 1;\n\t\t}\n\t\tldata->commit_head = ldata->read_head;\n\t\tldata->erasing = 0;\n\t\tldata->lnext = 0;\n\t}\n\n\tldata->icanon = (L_ICANON(tty) != 0);\n\n\tif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\n\t    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\n\t    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\n\t    I_PARMRK(tty)) {\n\t\tbitmap_zero(ldata->char_map, 256);\n\n\t\tif (I_IGNCR(tty) || I_ICRNL(tty))\n\t\t\tset_bit('\\r', ldata->char_map);\n\t\tif (I_INLCR(tty))\n\t\t\tset_bit('\\n', ldata->char_map);\n\n\t\tif (L_ICANON(tty)) {\n\t\t\tset_bit(ERASE_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(KILL_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(EOF_CHAR(tty), ldata->char_map);\n\t\t\tset_bit('\\n', ldata->char_map);\n\t\t\tset_bit(EOL_CHAR(tty), ldata->char_map);\n\t\t\tif (L_IEXTEN(tty)) {\n\t\t\t\tset_bit(WERASE_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(LNEXT_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(EOL2_CHAR(tty), ldata->char_map);\n\t\t\t\tif (L_ECHO(tty))\n\t\t\t\t\tset_bit(REPRINT_CHAR(tty),\n\t\t\t\t\t\tldata->char_map);\n\t\t\t}\n\t\t}\n\t\tif (I_IXON(tty)) {\n\t\t\tset_bit(START_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(STOP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tset_bit(INTR_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(QUIT_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(SUSP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tclear_bit(__DISABLED_CHAR, ldata->char_map);\n\t\tldata->raw = 0;\n\t\tldata->real_raw = 0;\n\t} else {\n\t\tldata->raw = 1;\n\t\tif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\n\t\t    (I_IGNPAR(tty) || !I_INPCK(tty)) &&\n\t\t    (tty->driver->flags & TTY_DRIVER_REAL_RAW))\n\t\t\tldata->real_raw = 1;\n\t\telse\n\t\t\tldata->real_raw = 0;\n\t}\n\t/*\n\t * Fix tty hang when I_IXON(tty) is cleared, but the tty\n\t * been stopped by STOP_CHAR(tty) before it.\n\t */\n\tif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\t/* The termios change make the tty ready for I/O */\n\twake_up_interruptible(&tty->write_wait);\n\twake_up_interruptible(&tty->read_wait);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-704"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OMX::buffer_id OMXNodeInstance::makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {\n return (OMX::buffer_id)bufferHeader;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool PrintWebViewHelper::CheckForCancel() {\n   bool cancel = false;\n  Send(new PrintHostMsg_CheckForCancel(\n      routing_id(),\n      print_pages_params_->params.preview_ui_addr,\n      print_pages_params_->params.preview_request_id,\n      &cancel));\n   if (cancel)\n     notify_browser_of_print_failure_ = false;\n   return cancel;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    int end_in_lf = 0;\n    int remain = 0;\n\n    if (ctxt == NULL)\n         return(XML_ERR_INTERNAL_ERROR);\n     if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n         return(ctxt->errNo);\n     if (ctxt->instate == XML_PARSER_START)\n         xmlDetectSAX2(ctxt);\n     if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\nxmldecl_done:\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {\n\tint base = ctxt->input->base - ctxt->input->buf->buffer->content;\n\tint cur = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n        /*\n         * Specific handling if we autodetected an encoding, we should not\n         * push more than the first line ... which depend on the encoding\n         * And only push the rest once the final encoding was detected\n         */\n        if ((ctxt->instate == XML_PARSER_START) && (ctxt->input != NULL) &&\n            (ctxt->input->buf != NULL) && (ctxt->input->buf->encoder != NULL)) {\n            unsigned int len = 45;\n\n            if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n                               BAD_CAST \"UTF-16\")) ||\n                (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n                               BAD_CAST \"UTF16\")))\n                len = 90;\n            else if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n                                    BAD_CAST \"UCS-4\")) ||\n                     (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n                                    BAD_CAST \"UCS4\")))\n                len = 180;\n\n            if (ctxt->input->buf->rawconsumed < len)\n                len -= ctxt->input->buf->rawconsumed;\n\n            /*\n             * Change size for reading the initial declaration only\n             * if size is greater than len. Otherwise, memmove in xmlBufferAdd\n             * will blindly copy extra bytes from memory.\n             */\n            if (size > len) {\n                remain = size - len;\n                size = len;\n            } else {\n                remain = 0;\n            }\n        }\n\tres =xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n\tif (res < 0) {\n\t    ctxt->errNo = XML_PARSER_EOF;\n\t    ctxt->disableSAX = 1;\n\t    return (XML_PARSER_EOF);\n\t}\n\tctxt->input->base = ctxt->input->buf->buffer->content + base;\n\tctxt->input->cur = ctxt->input->base + cur;\n\tctxt->input->end =\n\t    &ctxt->input->buf->buffer->content[ctxt->input->buf->buffer->use];\n#ifdef DEBUG_PUSH\n\txmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n#endif\n\n    } else if (ctxt->instate != XML_PARSER_EOF) {\n\tif ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n\t    xmlParserInputBufferPtr in = ctxt->input->buf;\n\t    if ((in->encoder != NULL) && (in->buffer != NULL) &&\n\t\t    (in->raw != NULL)) {\n\t\tint nbchars;\n\n\t\tnbchars = xmlCharEncInFunc(in->encoder, in->buffer, in->raw);\n\t\tif (nbchars < 0) {\n\t\t    /* TODO 2.6.0 */\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t\t    \"xmlParseChunk: encoder error\\n\");\n\t\t    return(XML_ERR_INVALID_ENCODING);\n\t\t}\n\t    }\n\t}\n    }\n    if (remain != 0)\n         xmlParseTryOrFinish(ctxt, 0);\n     else\n         xmlParseTryOrFinish(ctxt, terminate);\n     if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n         return(ctxt->errNo);\n \n    if (remain != 0) {\n        chunk += size;\n        size = remain;\n        remain = 0;\n        goto xmldecl_done;\n    }\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\txmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n\tint avail = 0;\n\n\tif (ctxt->input != NULL) {\n\t    if (ctxt->input->buf == NULL)\n\t\tavail = ctxt->input->length -\n\t\t\t(ctxt->input->cur - ctxt->input->base);\n\t    else\n\t\tavail = ctxt->input->buf->buffer->use -\n\t\t\t(ctxt->input->cur - ctxt->input->base);\n\t}\n\t\t\t    \n\tif ((ctxt->instate != XML_PARSER_EOF) &&\n\t    (ctxt->instate != XML_PARSER_EPILOG)) {\n\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n\t} \n\tif ((ctxt->instate == XML_PARSER_EPILOG) && (avail > 0)) {\n\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n\t}\n\tif (ctxt->instate != XML_PARSER_EOF) {\n\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\tctxt->sax->endDocument(ctxt->userData);\n\t}\n\tctxt->instate = XML_PARSER_EOF;\n    }\n    return((xmlParserErrors) ctxt->errNo);\t      \n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ResourceHostMsg_Request CreateXHRRequestWithOrigin(const char* origin) {\n   ResourceHostMsg_Request request;\n   request.method = \"GET\";\n  request.url = GURL(\"http://bar.com/simple_page.html\");\n  request.first_party_for_cookies = GURL(origin);\n   request.referrer_policy = blink::WebReferrerPolicyDefault;\n  request.headers = base::StringPrintf(\"Origin: %s\\r\\n\", origin);\n   request.load_flags = 0;\n   request.origin_pid = 0;\n   request.resource_type = RESOURCE_TYPE_XHR;\n  request.request_context = 0;\n  request.appcache_host_id = kAppCacheNoHostId;\n  request.download_to_file = false;\n  request.should_reset_appcache = false;\n  request.is_main_frame = true;\n  request.parent_is_main_frame = false;\n  request.parent_render_frame_id = -1;\n  request.transition_type = ui::PAGE_TRANSITION_LINK;\n  request.allow_download = true;\n   return request;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void SerializerMarkupAccumulator::appendText(StringBuilder& result, Text* text)\n {\n     Element* parent = text->parentElement();\n     if (parent && !shouldIgnoreElement(parent))\n        MarkupAccumulator::appendText(result, text);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n\n \t\t/* listeners have SOCK_RCU_FREE, not the children */\n \t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n \n \t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n \t\tatomic64_set(&newsk->sk_cookie,\n \t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\n\t\t/* Deinitialize accept_queue to trap illegal accesses. */\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-415"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "nfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n \n \tif (sfsname) {\n \t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n \n \t\t/* Make sure string is null-terminated */\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n \t\t/* Remove trailing spaces */\n \t\tspacep = strchr(temp, ' ');\n \t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\t/* Print the undecoded handle */\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void FrameSelection::SelectAll(SetSelectionBy set_selection_by) {\n  if (isHTMLSelectElement(GetDocument().FocusedElement())) {\n    HTMLSelectElement* select_element =\n        toHTMLSelectElement(GetDocument().FocusedElement());\n    if (select_element->CanSelectAll()) {\n      select_element->SelectAll();\n      return;\n    }\n  }\n\n  Node* root = nullptr;\n  Node* select_start_target = nullptr;\n  if (set_selection_by == SetSelectionBy::kUser && IsHidden()) {\n    root = GetDocument().documentElement();\n    select_start_target = GetDocument().body();\n  } else if (ComputeVisibleSelectionInDOMTree().IsContentEditable()) {\n    root = HighestEditableRoot(ComputeVisibleSelectionInDOMTree().Start());\n    if (Node* shadow_root = NonBoundaryShadowTreeRootNode(\n            ComputeVisibleSelectionInDOMTree().Start()))\n      select_start_target = shadow_root->OwnerShadowHost();\n    else\n      select_start_target = root;\n  } else {\n    root = NonBoundaryShadowTreeRootNode(\n        ComputeVisibleSelectionInDOMTree().Start());\n    if (root) {\n      select_start_target = root->OwnerShadowHost();\n    } else {\n      root = GetDocument().documentElement();\n      select_start_target = GetDocument().body();\n    }\n  }\n  if (!root || EditingIgnoresContent(*root))\n    return;\n\n  if (select_start_target) {\n    const Document& expected_document = GetDocument();\n    if (select_start_target->DispatchEvent(Event::CreateCancelableBubble(\n            EventTypeNames::selectstart)) != DispatchEventResult::kNotCanceled)\n      return;\n    if (!IsAvailable()) {\n      return;\n    }\n    if (!root->isConnected() || expected_document != root->GetDocument())\n      return;\n   }\n \n  SetSelection(SelectionInDOMTree::Builder()\n                   .SelectAllChildren(*root)\n                   .SetIsHandleVisible(IsHandleVisible())\n                    .Build());\n   SelectFrameElementInParentIfFullySelected();\n  NotifyTextControlOfSelectionChange(SetSelectionBy::kUser);\n  if (IsHandleVisible()) {\n    ContextMenuAllowedScope scope;\n    frame_->GetEventHandler().ShowNonLocatedContextMenu(nullptr,\n                                                        kMenuSourceTouch);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool AuthenticatorSheetModelBase::IsCancelButtonVisible() const {\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "CreateSaverWindow(ScreenPtr pScreen)\n{\n    SetupScreen(pScreen);\n    ScreenSaverStuffPtr pSaver;\n    ScreenSaverAttrPtr pAttr;\n    WindowPtr pWin;\n    int result;\n    unsigned long mask;\n    Colormap wantMap;\n    ColormapPtr pCmap;\n\n    pSaver = &pScreen->screensaver;\n    if (pSaver->pWindow) {\n        pSaver->pWindow = NullWindow;\n        FreeResource(pSaver->wid, RT_NONE);\n        if (pPriv) {\n            UninstallSaverColormap(pScreen);\n            pPriv->hasWindow = FALSE;\n            CheckScreenPrivate(pScreen);\n        }\n    }\n\n    if (!pPriv || !(pAttr = pPriv->attr))\n        return FALSE;\n\n    pPriv->installedMap = None;\n\n    if (GrabInProgress && GrabInProgress != pAttr->client->index)\n        return FALSE;\n\n    pWin = CreateWindow(pSaver->wid, pScreen->root,\n                        pAttr->x, pAttr->y, pAttr->width, pAttr->height,\n                        pAttr->borderWidth, pAttr->class,\n                        pAttr->mask, (XID *) pAttr->values,\n                        pAttr->depth, serverClient, pAttr->visual, &result);\n    if (!pWin)\n        return FALSE;\n\n    if (!AddResource(pWin->drawable.id, RT_WINDOW, pWin))\n        return FALSE;\n\n    mask = 0;\n    if (pAttr->pBackgroundPixmap) {\n        pWin->backgroundState = BackgroundPixmap;\n        pWin->background.pixmap = pAttr->pBackgroundPixmap;\n        pAttr->pBackgroundPixmap->refcnt++;\n        mask |= CWBackPixmap;\n    }\n    if (pAttr->pBorderPixmap) {\n        pWin->borderIsPixel = FALSE;\n        pWin->border.pixmap = pAttr->pBorderPixmap;\n        pAttr->pBorderPixmap->refcnt++;\n        mask |= CWBorderPixmap;\n    }\n    if (pAttr->pCursor) {\n        CursorPtr cursor;\n        if (!pWin->optional)\n            if (!MakeWindowOptional(pWin)) {\n                FreeResource(pWin->drawable.id, RT_NONE);\n                return FALSE;\n            }\n        cursor = RefCursor(pAttr->pCursor);\n        if (pWin->optional->cursor)\n            FreeCursor(pWin->optional->cursor, (Cursor) 0);\n        pWin->optional->cursor = cursor;\n        pWin->cursorIsNone = FALSE;\n        CheckWindowOptionalNeed(pWin);\n        mask |= CWCursor;\n    }\n    if (mask)\n        (*pScreen->ChangeWindowAttributes) (pWin, mask);\n\n    if (pAttr->colormap != None)\n        (void) ChangeWindowAttributes(pWin, CWColormap, &pAttr->colormap,\n                                      serverClient);\n\n    MapWindow(pWin, serverClient);\n\n    pPriv->hasWindow = TRUE;\n    pSaver->pWindow = pWin;\n\n    /* check and install our own colormap if it isn't installed now */\n    wantMap = wColormap(pWin);\n    if (wantMap == None || IsMapInstalled(wantMap, pWin))\n        return TRUE;\n\n    result = dixLookupResourceByType((void **) &pCmap, wantMap, RT_COLORMAP,\n                                     serverClient, DixInstallAccess);\n    if (result != Success)\n        return TRUE;\n\n    pPriv->installedMap = wantMap;\n\n    (*pCmap->pScreen->InstallColormap) (pCmap);\n\n    return TRUE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool GLES2DecoderImpl::ValidateAsyncTransfer(\n    const char* function_name,\n    TextureRef* texture_ref,\n    GLenum target,\n    GLint level,\n    const void * data) {\n  if (GL_TEXTURE_2D != target) {\n    LOCAL_SET_GL_ERROR_INVALID_ENUM(function_name, target, \"target\");\n    return false;\n  }\n  if (level != 0) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, \"level != 0\");\n    return false;\n  }\n  if (data == NULL) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, function_name, \"buffer == 0\");\n    return false;\n  }\n  if (!texture_ref ||\n      async_pixel_transfer_manager_->AsyncTransferIsInProgress(texture_ref)) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION,\n        function_name, \"transfer already in progress\");\n    return false;\n  }\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int filemap_write_and_wait(struct address_space *mapping)\n{\n\tint err = 0;\n\n\tif (mapping->nrpages) {\n\t\terr = filemap_fdatawrite(mapping);\n\t\t/*\n\t\t * Even if the above returned error, the pages may be\n\t\t * written partially (e.g. -ENOSPC), so we wait for it.\n\t\t * But the -EIO is special case, it may indicate the worst\n\t\t * thing (e.g. bug) happened, so we avoid waiting for it.\n\t\t */\n\t\tif (err != -EIO) {\n\t\t\tint err2 = filemap_fdatawait(mapping);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t}\n\t}\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n \n  uspoof_setRestrictionLevel(checker_, USPOOF_MODERATELY_RESTRICTIVE);\n \n   SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ =\n      icu::UnicodeSet(icu::UnicodeString(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  transliterator_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                         \" \u0142 > l; \u00f8 > o; \u0111 > d; \u04cf > l; [\u043a\u0138\u03ba] > k; \u043f > n;\"),\n      UTRANS_FORWARD, parse_error, status));\n  DCHECK(U_SUCCESS(status))\n      << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void vnc_display_add_client(DisplayState *ds, int csock, bool skipauth)\n{\n    VncDisplay *vs = vnc_display;\n\n    vnc_connect(vs, csock, skipauth, false);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void WaitForInterstitialAttach(content::WebContents* web_contents) {\n  if (web_contents->ShowingInterstitialPage())\n    return;\n  scoped_refptr<content::MessageLoopRunner> loop_runner(\n      new content::MessageLoopRunner);\n  InterstitialObserver observer(web_contents,\n                                loop_runner->QuitClosure(),\n                                base::Closure());\n  loop_runner->Run();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static MagickStatusType ReadPSDMergedImage(Image* image,\n  const PSDInfo* psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *offsets;\n\n  MagickStatusType\n    status;\n\n  PSDCompressionType\n    compression;\n\n  register ssize_t\n    i;\n\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n\n  offsets=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n  {\n    offsets=ReadPSDRLEOffsets(image,psd_info,image->rows*psd_info->channels);\n    if (offsets == (MagickOffsetType *) NULL)\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n  }\n\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,psd_info,i,offsets+(i*image->rows),\n        exception);\n    else\n      status=ReadPSDChannelRaw(image,psd_info->channels,i,exception);\n\n    if (status == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImagesTag,i,psd_info->channels);\n    if (status == MagickFalse)\n      break;\n  }\n\n  if (image->colorspace == CMYKColorspace)\n    (void) NegateImage(image,MagickFalse);\n\n  if (offsets != (MagickOffsetType *) NULL)\n    offsets=(MagickOffsetType *) RelinquishMagickMemory(offsets);\n\n  return(status);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void ssd0323_invalidate_display(void * opaque)\n{\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    s->redraw = 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ihevcd_parse_sei_payload(codec_t *ps_codec,\n                              UWORD32 u4_payload_type,\n                              UWORD32 u4_payload_size,\n                              WORD8 i1_nal_type)\n{\n parse_ctxt_t *ps_parse = &ps_codec->s_parse;\n bitstrm_t *ps_bitstrm = &ps_parse->s_bitstrm;\n    WORD32 payload_bits_remaining = 0;\n sps_t *ps_sps;\n\n    UWORD32 i;\n\n for(i = 0; i < MAX_SPS_CNT; i++)\n {\n        ps_sps = ps_codec->ps_sps_base + i;\n if(ps_sps->i1_sps_valid)\n {\n break;\n }\n }\n if(NULL == ps_sps)\n {\n return;\n }\n\n if(NAL_PREFIX_SEI == i1_nal_type)\n {\n switch(u4_payload_type)\n {\n case SEI_BUFFERING_PERIOD:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_buffering_period_sei(ps_codec, ps_sps);\n break;\n\n case SEI_PICTURE_TIMING:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_pic_timing_sei(ps_codec, ps_sps);\n break;\n\n case SEI_TIME_CODE:\n                ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_time_code_sei(ps_codec);\n break;\n\n case SEI_MASTERING_DISPLAY_COLOUR_VOLUME:\n                ps_parse->s_sei_params.i4_sei_mastering_disp_colour_vol_params_present_flags = 1;\n                ihevcd_parse_mastering_disp_params_sei(ps_codec);\n break;\n\n \n             case SEI_USER_DATA_REGISTERED_ITU_T_T35:\n                 ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_user_data_registered_itu_t_t35(ps_codec,\n                                                            u4_payload_size);\n                 break;\n \n             default:\n for(i = 0; i < u4_payload_size; i++)\n {\n                    ihevcd_bits_flush(ps_bitstrm, 8);\n }\n break;\n }\n }\n else /* NAL_SUFFIX_SEI */\n {\n switch(u4_payload_type)\n\n         {\n             case SEI_USER_DATA_REGISTERED_ITU_T_T35:\n                 ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;\n                ihevcd_parse_user_data_registered_itu_t_t35(ps_codec,\n                                                            u4_payload_size);\n                 break;\n \n             default:\n for(i = 0; i < u4_payload_size; i++)\n {\n                    ihevcd_bits_flush(ps_bitstrm, 8);\n }\n break;\n }\n }\n\n /**\n     * By definition the underlying bitstream terminates in a byte-aligned manner.\n     * 1. Extract all bar the last MIN(bitsremaining,nine) bits as reserved_payload_extension_data\n     * 2. Examine the final 8 bits to determine the payload_bit_equal_to_one marker\n     * 3. Extract the remainingreserved_payload_extension_data bits.\n     *\n     * If there are fewer than 9 bits available, extract them.\n     */\n\n    payload_bits_remaining = ihevcd_bits_num_bits_remaining(ps_bitstrm);\n if(payload_bits_remaining) /* more_data_in_payload() */\n {\n        WORD32 final_bits;\n        WORD32 final_payload_bits = 0;\n        WORD32 mask = 0xFF;\n        UWORD32 u4_dummy;\n        UWORD32 u4_reserved_payload_extension_data;\n        UNUSED(u4_dummy);\n        UNUSED(u4_reserved_payload_extension_data);\n\n while(payload_bits_remaining > 9)\n {\n            BITS_PARSE(\"reserved_payload_extension_data\",\n                       u4_reserved_payload_extension_data, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n\n        final_bits = ihevcd_bits_nxt(ps_bitstrm, payload_bits_remaining);\n\n while(final_bits & (mask >> final_payload_bits))\n {\n            final_payload_bits++;\n continue;\n }\n\n while(payload_bits_remaining > (9 - final_payload_bits))\n {\n            BITS_PARSE(\"reserved_payload_extension_data\",\n                       u4_reserved_payload_extension_data, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n\n        BITS_PARSE(\"payload_bit_equal_to_one\", u4_dummy, ps_bitstrm, 1);\n        payload_bits_remaining--;\n while(payload_bits_remaining)\n {\n            BITS_PARSE(\"payload_bit_equal_to_zero\", u4_dummy, ps_bitstrm, 1);\n            payload_bits_remaining--;\n }\n }\n\n return;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "gs_main_init1(gs_main_instance * minst)\n{\n    if (minst->init_done < 1) {\n        gs_dual_memory_t idmem;\n        int code =\n            ialloc_init(&idmem, minst->heap,\n                        minst->memory_clump_size, gs_have_level2());\n\n        if (code < 0)\n            return code;\n        code = gs_lib_init1((gs_memory_t *)idmem.space_system);\n        if (code < 0)\n            return code;\n        alloc_save_init(&idmem);\n        {\n            gs_memory_t *mem = (gs_memory_t *)idmem.space_system;\n            name_table *nt = names_init(minst->name_table_size,\n                                        idmem.space_system);\n\n            if (nt == 0)\n                return_error(gs_error_VMerror);\n            mem->gs_lib_ctx->gs_name_table = nt;\n            code = gs_register_struct_root(mem, NULL,\n                                           (void **)&mem->gs_lib_ctx->gs_name_table,\n                                           \"the_gs_name_table\");\n                                            \"the_gs_name_table\");\n             if (code < 0)\n                 return code;\n         }\n         code = obj_init(&minst->i_ctx_p, &idmem);  /* requires name_init */\n         if (code < 0)\n        if (code < 0)\n            return code;\n        code = i_iodev_init(minst->i_ctx_p);\n        if (code < 0)\n            return code;\n        minst->init_done = 1;\n    }\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void PrintMsg_Print_Params::Reset() {\n  page_size = gfx::Size();\n  content_size = gfx::Size();\n  printable_area = gfx::Rect();\n  margin_top = 0;\n  margin_left = 0;\n  dpi = 0;\n  min_shrink = 0;\n  max_shrink = 0;\n  desired_dpi = 0;\n   document_cookie = 0;\n   selection_only = false;\n   supports_alpha_blend = false;\n  preview_ui_addr = std::string();\n   preview_request_id = 0;\n   is_first_request = false;\n   print_scaling_option = WebKit::WebPrintScalingOptionSourceSize;\n  print_to_pdf = false;\n  display_header_footer = false;\n  date = string16();\n  title = string16();\n  url = string16();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SPICE_GNUC_VISIBLE int spice_server_set_playback_compression(SpiceServer *s, int enable)\n{\n    spice_assert(reds == s);\n    snd_set_playback_compression(enable);\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "set_hunkmax (void)\n {\n     if (!p_line)\n\tp_line = (char **) malloc (hunkmax * sizeof *p_line);\n     if (!p_len)\n\tp_len = (size_t *) malloc (hunkmax * sizeof *p_len);\n     if (!p_Char)\n\tp_Char = malloc (hunkmax * sizeof *p_Char);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "media::AudioHardwareConfig* RenderThreadImpl::GetAudioHardwareConfig() {\n  if (!audio_hardware_config_) {\n    media::AudioParameters input_params;\n    media::AudioParameters output_params;\n    Send(new ViewHostMsg_GetAudioHardwareConfig(\n        &input_params, &output_params));\n\n    audio_hardware_config_.reset(new media::AudioHardwareConfig(\n        input_params, output_params));\n    audio_message_filter_->SetAudioHardwareConfig(audio_hardware_config_.get());\n  }\n\n  return audio_hardware_config_.get();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\"CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\",\n             mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    result.append(\"  State: \");\n\n    mFrameProcessor->dump(fd, args);\n\n return dumpDevice(fd, args);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "GlobalConfirmInfoBar::GlobalConfirmInfoBar(\n    std::unique_ptr<ConfirmInfoBarDelegate> delegate)\n    : delegate_(std::move(delegate)),\n      browser_tab_strip_tracker_(this, nullptr, nullptr),\n      is_closing_(false),\n      weak_factory_(this) {\n  browser_tab_strip_tracker_.Init();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void OMXNodeInstance::onEvent(\n        OMX_EVENTTYPE event, OMX_U32 arg1, OMX_U32 arg2) {\n const char *arg1String = \"??\";\n const char *arg2String = \"??\";\n ADebug::Level level = ADebug::kDebugInternalState;\n\n switch (event) {\n case OMX_EventCmdComplete:\n            arg1String = asString((OMX_COMMANDTYPE)arg1);\n switch (arg1) {\n case OMX_CommandStateSet:\n                    arg2String = asString((OMX_STATETYPE)arg2);\n                    level = ADebug::kDebugState;\n break;\n case OMX_CommandFlush:\n case OMX_CommandPortEnable:\n {\n Mutex::Autolock _l(mDebugLock);\n                    bumpDebugLevel_l(2 /* numInputBuffers */, 2 /* numOutputBuffers */);\n }\n default:\n                    arg2String = portString(arg2);\n }\n break;\n case OMX_EventError:\n            arg1String = asString((OMX_ERRORTYPE)arg1);\n            level = ADebug::kDebugLifeCycle;\n break;\n case OMX_EventPortSettingsChanged:\n            arg2String = asString((OMX_INDEXEXTTYPE)arg2);\n default:\n            arg1String = portString(arg1);\n }\n\n    CLOGI_(level, onEvent, \"%s(%x), %s(%x), %s(%x)\",\n            asString(event), event, arg1String, arg1, arg2String, arg2);\n const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());\n\n if (bufferSource != NULL\n && event == OMX_EventCmdComplete\n && arg1 == OMX_CommandStateSet\n\n             && arg2 == OMX_StateExecuting) {\n         bufferSource->omxExecuting();\n     }\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n {\n    static uid_t uid_server = 0;\n     static gid_t gid_cluster = 0;\n \n     crm_client_t *client = NULL;\n\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n     }\n \n     if (gid_cluster == 0) {\n        uid_server = getuid();\n         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n             static bool have_error = FALSE;\n             if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n         }\n     }\n \n    if(gid_cluster != 0 && gid_client != 0) {\n        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */\n        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */\n            best_uid = QB_MAX(uid_client, uid_server);\n            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);\n        }\n         crm_trace(\"Giving access to group %u\", gid_cluster);\n        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n     }\n \n     crm_client_init();\n\n    /* TODO: Do our own auth checking, return NULL if unauthorized */\n    client = calloc(1, sizeof(crm_client_t));\n\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n\n    client->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-285"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "size_t ZSTD_freeCCtx(ZSTD_CCtx* cctx)\n{\n    if (cctx==NULL) return 0;   /* support free on NULL */\n    if (cctx->staticSize) return ERROR(memory_allocation);   /* not compatible with static CCtx */\n    ZSTD_freeCCtxContent(cctx);\n    ZSTD_free(cctx, cctx->customMem);\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "render_state_init( RenderState  state,\n                     Display      display )\n  {\n    memset( state, 0, sizeof ( *state ) );\n\n    state->text         = default_text;\n    state->filepath     = state->filepath0;\n    state->filename     = \"<none>\";\n    state->filepath0[0] = 0;\n    state->resolution   = 72;\n    state->char_size    = 16;\n    state->display      = display[0];\n\n    state->columns[0].use_kerning              = 1;\n    state->columns[0].use_deltas               = 1;\n    state->columns[0].use_lcd_filter           = 1;\n    state->columns[0].use_global_advance_width = 1;\n    state->columns[0].lcd_filter               = FT_LCD_FILTER_DEFAULT;\n    state->columns[0].hint_mode                = HINT_MODE_BYTECODE;\n    state->columns[0].use_custom_lcd_filter    = 0;\n    state->columns[0].fw_index                 = 2;\n    /* freetype default filter weights */\n    memcpy( state->columns[0].filter_weights, \"\\x10\\x40\\x70\\x40\\x10\", 5);\n\n    state->columns[1]                       = state->columns[0];\n    state->columns[1].hint_mode             = HINT_MODE_AUTOHINT;\n    state->columns[1].use_custom_lcd_filter = 1;\n\n    state->columns[2]           = state->columns[0];\n    state->columns[2].hint_mode = HINT_MODE_UNHINTED;\n\n    state->col = 1;\n\n    if ( FT_Init_FreeType( &state->library ) != 0 )\n      panic( \"could not initialize FreeType library. Check your code\\n\" );\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SegmentInfo::~SegmentInfo()\n{\n    delete[] m_pMuxingAppAsUTF8;\n    m_pMuxingAppAsUTF8 = NULL;\n    delete[] m_pWritingAppAsUTF8;\n    m_pWritingAppAsUTF8 = NULL;\n    delete[] m_pTitleAsUTF8;\n    m_pTitleAsUTF8 = NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int send_write_chunks(struct svcxprt_rdma *xprt,\n\t\t\t     struct rpcrdma_write_array *wr_ary,\n\t\t\t     struct rpcrdma_msg *rdma_resp,\n\t\t\t     struct svc_rqst *rqstp,\n\t\t\t     struct svc_rdma_req_map *vec)\n {\n\tu32 xfer_len = rqstp->rq_res.page_len;\n\tint write_len;\n\tu32 xdr_off;\n\tint chunk_off;\n\tint chunk_no;\n\tint nchunks;\n\tstruct rpcrdma_write_array *res_ary;\n \tint ret;\n \n\tres_ary = (struct rpcrdma_write_array *)\n\t\t&rdma_resp->rm_body.rm_chunks[1];\n\t/* Write chunks start at the pagelist */\n\tnchunks = be32_to_cpu(wr_ary->wc_nchunks);\n\tfor (xdr_off = rqstp->rq_res.head[0].iov_len, chunk_no = 0;\n\t     xfer_len && chunk_no < nchunks;\n\t     chunk_no++) {\n\t\tstruct rpcrdma_segment *arg_ch;\n\t\tu64 rs_offset;\n\t\targ_ch = &wr_ary->wc_array[chunk_no].wc_target;\n\t\twrite_len = min(xfer_len, be32_to_cpu(arg_ch->rs_length));\n\t\t/* Prepare the response chunk given the length actually\n\t\t * written */\n\t\txdr_decode_hyper((__be32 *)&arg_ch->rs_offset, &rs_offset);\n\t\tsvc_rdma_xdr_encode_array_chunk(res_ary, chunk_no,\n\t\t\t\t\t\targ_ch->rs_handle,\n\t\t\t\t\t\targ_ch->rs_offset,\n\t\t\t\t\t\twrite_len);\n\t\tchunk_off = 0;\n\t\twhile (write_len) {\n\t\t\tret = send_write(xprt, rqstp,\n\t\t\t\t\t be32_to_cpu(arg_ch->rs_handle),\n\t\t\t\t\t rs_offset + chunk_off,\n\t\t\t\t\t xdr_off,\n\t\t\t\t\t write_len,\n\t\t\t\t\t vec);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto out_err;\n\t\t\tchunk_off += ret;\n\t\t\txdr_off += ret;\n\t\t\txfer_len -= ret;\n\t\t\twrite_len -= ret;\n \t\t}\n \t}\n\t/* Update the req with the number of chunks actually used */\n\tsvc_rdma_xdr_encode_write_list(rdma_resp, chunk_no);\n \n\treturn rqstp->rq_res.page_len;\n \nout_err:\n\tpr_err(\"svcrdma: failed to send write chunks, rc=%d\\n\", ret);\n\treturn -EIO;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-404"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long VideoTrack::Parse(\n    Segment* pSegment,\n    const Info& info,\n    long long element_start,\n    long long element_size,\n    VideoTrack*& pResult)\n{\n    if (pResult)\n        return -1;\n \n    if (info.type != Track::kVideo)\n        return -1;\n \n    long long width = 0;\n    long long height = 0;\n    double rate = 0.0;\n \n    IMkvReader* const pReader = pSegment->m_pReader;\n \n    const Settings& s = info.settings;\n    assert(s.start >= 0);\n    assert(s.size >= 0);\n \n    long long pos = s.start;\n    assert(pos >= 0);\n \n    const long long stop = pos + s.size;\n \n    while (pos < stop)\n    {\n        long long id, size;\n \n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n \n        if (status < 0)  //error\n            return status;\n \n        if (id == 0x30)  //pixel width\n        {\n            width = UnserializeUInt(pReader, pos, size);\n            if (width <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x3A)  //pixel height\n        {\n            height = UnserializeUInt(pReader, pos, size);\n            if (height <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x0383E3)  //frame rate\n        {\n            const long status = UnserializeFloat(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    rate);\n            if (status < 0)\n                return status;\n            if (rate <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        pos += size;  //consume payload\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    VideoTrack* const pTrack = new (std::nothrow) VideoTrack(pSegment,\n                                                             element_start,\n                                                             element_size);\n    if (pTrack == NULL)\n        return -1;  //generic error\n    const int status = info.Copy(pTrack->m_info);\n    if (status)  // error\n    {\n        delete pTrack;\n        return status;\n    }\n    pTrack->m_width = width;\n    pTrack->m_height = height;\n    pTrack->m_rate = rate;\n    pResult = pTrack;\n    return 0;  //success\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "HistogramBase* Histogram::Factory::Build() {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name_);\n  if (!histogram) {\n    const BucketRanges* created_ranges = CreateRanges();\n    const BucketRanges* registered_ranges =\n        StatisticsRecorder::RegisterOrDeleteDuplicateRanges(created_ranges);\n\n    if (bucket_count_ == 0) {\n      bucket_count_ = static_cast<uint32_t>(registered_ranges->bucket_count());\n      minimum_ = registered_ranges->range(1);\n      maximum_ = registered_ranges->range(bucket_count_ - 1);\n    }\n\n    PersistentHistogramAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          histogram_type_,\n          name_,\n          minimum_,\n          maximum_,\n          registered_ranges,\n          flags_,\n          &histogram_ref);\n    }\n\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  // Should never have been set.\n      DCHECK(!allocator);  // Shouldn't have failed.\n      flags_ &= ~HistogramBase::kIsPersistent;\n      tentative_histogram = HeapAlloc(registered_ranges);\n      tentative_histogram->SetFlags(flags_);\n    }\n\n    FillHistogram(tentative_histogram.get());\n\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n  DCHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;\n   if (bucket_count_ != 0 &&\n       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {\n    DLOG(ERROR) << \"Histogram \" << name_ << \" has bad construction arguments\";\n    return nullptr;\n  }\n  return histogram;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void i6300esb_register_types(void)\n{\n    watchdog_add_model(&model);\n    type_register_static(&i6300esb_info);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "RenderFrameProxyHost* RenderFrameHostManager::GetRenderFrameProxyHost(\n    SiteInstance* instance) const {\n  auto it = proxy_hosts_.find(instance->GetId());\n  if (it != proxy_hosts_.end())\n    return it->second.get();\n  return nullptr;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RenderFrameHostImpl::OnShowPopup(\n    const FrameHostMsg_ShowPopup_Params& params) {\n  RenderViewHostDelegateView* view =\n      render_view_host_->delegate_->GetDelegateView();\n  if (view) {\n    gfx::Point original_point(params.bounds.x(), params.bounds.y());\n    gfx::Point transformed_point =\n        static_cast<RenderWidgetHostViewBase*>(GetView())\n            ->TransformPointToRootCoordSpace(original_point);\n    gfx::Rect transformed_bounds(transformed_point.x(), transformed_point.y(),\n                                 params.bounds.width(), params.bounds.height());\n    view->ShowPopupMenu(this, transformed_bounds, params.item_height,\n                        params.item_font_size, params.selected_item,\n                        params.popup_items, params.right_aligned,\n                        params.allow_multiple_selection);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void __h2_init(void)\n{\n\talpn_register_mux(&alpn_mux_h2);\n\tcfg_register_keywords(&cfg_kws);\n\thap_register_post_deinit(__h2_deinit);\n\tpool_head_h2c = create_pool(\"h2c\", sizeof(struct h2c), MEM_F_SHARED);\n\tpool_head_h2s = create_pool(\"h2s\", sizeof(struct h2s), MEM_F_SHARED);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool HttpAuthFilterWhitelist::AddFilter(const std::string& filter,\n                                        HttpAuth::Target target) {\n  if ((target != HttpAuth::AUTH_SERVER) && (target != HttpAuth::AUTH_PROXY))\n    return false;\n  if (target == HttpAuth::AUTH_PROXY)\n    return true;\n  rules_.AddRuleFromString(filter);\n   return true;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Ins_INSTCTRL( INS_ARG )\n  {\n    FT_Long  K, L;\n\n\n    K = args[1];\n    L = args[0];\n\n    if ( K < 1 || K > 2 )\n    {\n      if ( CUR.pedantic_hinting )\n        CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    if ( L != 0 )\n        L = K;\n\n    CUR.GS.instruct_control = FT_BOOL(\n      ( (FT_Byte)CUR.GS.instruct_control & ~(FT_Byte)K ) | (FT_Byte)L );\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit **inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\n\terror = btrfs_may_create(dir, dentry);\n \tif (error)\n \t\tgoto out_dput;\n \n \tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n \n \tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(BTRFS_I(dir)->root, dentry,\n\t\t\t\t      name, namelen, async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) /* {{{ */\n {\n \tchar *p1, *p2;\n \tif (intern->file_name) {\n \t\tefree(intern->file_name);\n \t}\n\n\tintern->file_name = use_copy ? estrndup(path, len) : path;\n\tintern->file_name_len = len;\n\n\twhile(IS_SLASH_AT(intern->file_name, intern->file_name_len-1) && intern->file_name_len > 1) {\n\t\tintern->file_name[intern->file_name_len-1] = 0;\n\t\tintern->file_name_len--;\n\t}\n\n\tp1 = strrchr(intern->file_name, '/');\n#if defined(PHP_WIN32) || defined(NETWARE)\n\tp2 = strrchr(intern->file_name, '\\\\');\n#else\n\tp2 = 0;\n#endif\n\tif (p1 || p2) {\n\t\tintern->_path_len = (p1 > p2 ? p1 : p2) - intern->file_name;\n \t} else {\n \t\tintern->_path_len = 0;\n \t}\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n\tintern->_path = estrndup(path, intern->_path_len);\n} /* }}} */"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "jsonb_delete_idx(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB(0);\n\tint\t\t\tidx = PG_GETARG_INT32(1);\n\tJsonbParseState *state = NULL;\n\tJsonbIterator *it;\n\tuint32\t\tr,\n\t\t\t\ti = 0,\n\t\t\t\tn;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\")));\n\n\tif (JB_ROOT_IS_OBJECT(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from object using integer subscript\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tr = JsonbIteratorNext(&it, &v, false);\n\tAssert (r == WJB_BEGIN_ARRAY);\n\tn = v.val.array.nElems;\n\n\tif (idx < 0)\n\t{\n\t\tif (-idx > n)\n\t\t\tidx = n;\n\t\telse\n\t\t\tidx = n + idx;\n\t}\n\n\tif (idx >= n)\n\t\tPG_RETURN_JSONB(in);\n\n\tpushJsonbValue(&state, r, NULL);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, true)) != 0)\n\t{\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tif (i++ == idx)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tres = pushJsonbValue(&state, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB(JsonbValueToJsonb(res));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n if(ps_dec->init_done != 1)\n {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n /*\n     * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n     */\n {\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n            ps_dec->u1_top_bottom_decoded = 0;\n }\n }\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\n {\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 2;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n    ps_dec->u4_start_recon_deblk  = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n void *pv_buf;\n void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n        buflen = MIN(buflen, buf_size);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n /* Decoder may read extra 8 bytes near end of the frame */\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n\n             if((ret == IVD_RES_CHANGED)\n                             || (ret == IVD_MEM_ALLOC_FAILED)\n                             || (ret == ERROR_UNAVAIL_PICBUF_T)\n                            || (ret == ERROR_UNAVAIL_MVBUF_T))\n             {\n                 break;\n             }\n \n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n\n        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))\n {\n return IV_FAIL;\n }\n }\n\n\n     if((ret == IVD_RES_CHANGED)\n                     || (ret == IVD_MEM_ALLOC_FAILED)\n                     || (ret == ERROR_UNAVAIL_PICBUF_T)\n                    || (ret == ERROR_UNAVAIL_MVBUF_T))\n     {\n \n         /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n if(ret != 0)\n {\n return IV_FAIL;\n }\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-172"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer;\n    uint32_t checksum_passed = 0, bcount, meta_bc;\n    unsigned char *dp, meta_id, c1, c2;\n\n    if (strncmp (wphdr->ckID, \"wvpk\", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))\n        return FALSE;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                return FALSE;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if (bcount < meta_bc)\n            return FALSE;\n\n        if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer;\n#else\n            unsigned char *csptr = buffer;\n#endif\n            int wcount = (int)(dp - 2 - buffer) >> 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)\n                return FALSE;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static struct ip_tunnel *ipip6_tunnel_lookup(struct net *net,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     __be32 remote, __be32 local,\n\t\t\t\t\t     int sifindex)\n{\n\tunsigned int h0 = HASH(remote);\n\tunsigned int h1 = HASH(local);\n\tstruct ip_tunnel *t;\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tint ifindex = dev ? dev->ifindex : 0;\n\n\tfor_each_ip_tunnel_rcu(t, sitn->tunnels_r_l[h0 ^ h1]) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    (!dev || !t->parms.link || ifindex == t->parms.link ||\n\t\t     sifindex == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tfor_each_ip_tunnel_rcu(t, sitn->tunnels_r[h0]) {\n\t\tif (remote == t->parms.iph.daddr &&\n\t\t    (!dev || !t->parms.link || ifindex == t->parms.link ||\n\t\t     sifindex == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tfor_each_ip_tunnel_rcu(t, sitn->tunnels_l[h1]) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    (!dev || !t->parms.link || ifindex == t->parms.link ||\n\t\t     sifindex == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tt = rcu_dereference(sitn->tunnels_wc[0]);\n\tif (t && (t->dev->flags & IFF_UP))\n\t\treturn t;\n\treturn NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-772"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SPL_METHOD(SplFileInfo, setFileClass)\n{\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tzend_class_entry *ce = spl_ce_SplFileObject;\n \tzend_error_handling error_handling;\n \tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->file_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xfs_attr_node_get(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\tint error, retval;\n\tint i;\n\n\ttrace_xfs_attr_node_get(args);\n\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/*\n\t * Search to see if name exists, and get back a pointer to it.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error) {\n\t\tretval = error;\n\t} else if (retval == -EEXIST) {\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->bp != NULL);\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\t\t/*\n\t\t * Get the value, local or \"remote\"\n\t\t */\n\t\tretval = xfs_attr3_leaf_getvalue(blk->bp, args);\n\t\tif (!retval && (args->rmtblkno > 0)\n\t\t    && !(args->flags & ATTR_KERNOVAL)) {\n\t\t\tretval = xfs_attr_rmtval_get(args);\n\t\t}\n\t}\n\n\t/*\n\t * If not in a transaction, we have to release all the buffers.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\n\txfs_da_state_free(state);\n\treturn retval;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-754"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void xt_proto_fini(struct net *net, u_int8_t af)\n{\n#ifdef CONFIG_PROC_FS\n\tchar buf[XT_FUNCTION_MAXNAMELEN];\n\n\tstrlcpy(buf, xt_prefix[af], sizeof(buf));\n\tstrlcat(buf, FORMAT_TABLES, sizeof(buf));\n\tremove_proc_entry(buf, net->proc_net);\n\n\tstrlcpy(buf, xt_prefix[af], sizeof(buf));\n\tstrlcat(buf, FORMAT_TARGETS, sizeof(buf));\n\tremove_proc_entry(buf, net->proc_net);\n\n\tstrlcpy(buf, xt_prefix[af], sizeof(buf));\n\tstrlcat(buf, FORMAT_MATCHES, sizeof(buf));\n\tremove_proc_entry(buf, net->proc_net);\n#endif /*CONFIG_PROC_FS*/\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static v8::Local<v8::Value> installPrivateScriptRunner(v8::Isolate* isolate) {\n  const String className = \"PrivateScriptRunner\";\n  size_t index;\n  for (index = 0; index < WTF_ARRAY_LENGTH(kPrivateScriptSources); index++) {\n    if (className == kPrivateScriptSources[index].className)\n      break;\n  }\n  if (index == WTF_ARRAY_LENGTH(kPrivateScriptSources)) {\n    LOG(FATAL)\n        << \"Private script error: Target source code was not found. (Class \"\n           \"name = \"\n        << className.utf8().data() << \")\";\n  }\n  String resourceData =\n      loadResourceAsASCIIString(kPrivateScriptSources[index].resourceFile);\n  return compileAndRunPrivateScript(ScriptState::current(isolate), className,\n                                    resourceData.utf8().data(),\n                                    resourceData.length());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-79"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void __ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\tBUG_ON(!list_empty(&child->ptrace_entry));\n\tlist_add(&child->ptrace_entry, &new_parent->ptraced);\n\tchild->parent = new_parent;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static MagickBooleanType ReadPixelCachePixels(CacheInfo *restrict cache_info,\n  NexusInfo *restrict nexus_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register PixelPacket\n    *restrict q;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(PixelPacket);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  q=nexus_info->pixels;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register PixelPacket\n        *restrict p;\n\n      /*\n        Read pixels from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=cache_info->pixels+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read pixels from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+offset*\n          sizeof(*q),length,(unsigned char *) q);\n        if ((MagickSizeType) count < length)\n          break;\n        offset+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read pixels from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "nfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp, struct nfs4_clnt_odstate *odstate)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\tdp = alloc_init_deleg(clp, fh, odstate);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\tstatus = hash_delegation_locked(dp, fp);\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-404"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void HideHostCursor() {\n  CR_DEFINE_STATIC_LOCAL(XScopedCursor, invisible_cursor,\n                         (CreateInvisibleCursor(), ui::GetXDisplay()));\n  XDefineCursor(ui::GetXDisplay(), DefaultRootWindow(ui::GetXDisplay()),\n                invisible_cursor.get());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool WebContentsImpl::ShowingInterstitialPage() const {\n  return GetRenderManager()->interstitial_page() != NULL;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void aio_kick_handler(struct work_struct *work)\n{\n\tstruct kioctx *ctx = container_of(work, struct kioctx, wq.work);\n\tmm_segment_t oldfs = get_fs();\n\tstruct mm_struct *mm;\n\tint requeue;\n\n\tset_fs(USER_DS);\n\tuse_mm(ctx->mm);\n\tspin_lock_irq(&ctx->ctx_lock);\n\trequeue =__aio_run_iocbs(ctx);\n\tmm = ctx->mm;\n\tspin_unlock_irq(&ctx->ctx_lock);\n \tunuse_mm(mm);\n\tset_fs(oldfs);\n\t/*\n\t * we're in a worker thread already, don't use queue_delayed_work,\n\t */\n\tif (requeue)\n\t\tqueue_delayed_work(aio_wq, &ctx->wq, 0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int xcbc_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_instance *inst = (void *)tfm->__crt_alg;\n\tstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\n\tstruct xcbc_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcipher = crypto_spawn_cipher(spawn);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\treturn 0;\n};"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void WebContentsImpl::MediaStartedPlaying(\n    const WebContentsObserver::MediaPlayerInfo& media_info,\n    const WebContentsObserver::MediaPlayerId& id) {\n  if (media_info.has_video)\n    currently_playing_video_count_++;\n\n  for (auto& observer : observers_)\n    observer.MediaStartedPlaying(media_info, id);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int64_t buffer_size() {\n    return loader()->current_buffer_size_ * 32768 /* block size */;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-732"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OMX_ERRORTYPE  omx_video::allocate_output_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes)\n{\n (void)hComp, (void)port;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n    OMX_BUFFERHEADERTYPE       *bufHdr= NULL; // buffer header\n unsigned                         i= 0; // Temporary counter\n#ifdef _MSM8974_\n int align_size;\n#endif\n    DEBUG_PRINT_HIGH(\"allocate_output_buffer()for %u bytes\", (unsigned int)bytes);\n if (!m_out_mem_ptr) {\n int nBufHdrSize        = 0;\n        DEBUG_PRINT_HIGH(\"%s: size = %u, actual cnt %u\", __FUNCTION__,\n (unsigned int)m_sOutPortDef.nBufferSize, (unsigned int)m_sOutPortDef.nBufferCountActual);\n        nBufHdrSize        = m_sOutPortDef.nBufferCountActual * sizeof(OMX_BUFFERHEADERTYPE);\n\n /*\n         * Memory for output side involves the following:\n         * 1. Array of Buffer Headers\n         * 2. Bitmask array to hold the buffer allocation details\n         * In order to minimize the memory management entire allocation\n         * is done in one step.\n         */\n        m_out_mem_ptr = (OMX_BUFFERHEADERTYPE  *)calloc(nBufHdrSize,1);\n\n#ifdef USE_ION\n        m_pOutput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sOutPortDef.nBufferCountActual);\n if (m_pOutput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pOutput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n        m_pOutput_pmem = (struct pmem *) calloc(sizeof(struct pmem), m_sOutPortDef.nBufferCountActual);\n if (m_pOutput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pOutput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n if (m_out_mem_ptr && m_pOutput_pmem) {\n            bufHdr          =  m_out_mem_ptr;\n\n for (i=0; i < m_sOutPortDef.nBufferCountActual ; i++) {\n                bufHdr->nSize              = sizeof(OMX_BUFFERHEADERTYPE);\n                bufHdr->nVersion.nVersion  = OMX_SPEC_VERSION;\n                bufHdr->nAllocLen          = bytes;\n                bufHdr->nFilledLen         = 0;\n                bufHdr->pAppPrivate        = appData;\n                bufHdr->nOutputPortIndex   = PORT_INDEX_OUT;\n                bufHdr->pOutputPortPrivate = (OMX_PTR)&m_pOutput_pmem[i];\n                bufHdr->pBuffer            = NULL;\n                bufHdr++;\n                m_pOutput_pmem[i].fd = -1;\n#ifdef USE_ION\n                m_pOutput_ion[i].ion_device_fd =-1;\n                m_pOutput_ion[i].fd_ion_data.fd=-1;\n                m_pOutput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n } else {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() failed for m_out_mem_ptr/m_pOutput_pmem\");\n            eRet = OMX_ErrorInsufficientResources;\n }\n }\n\n    DEBUG_PRINT_HIGH(\"actual cnt = %u\", (unsigned int)m_sOutPortDef.nBufferCountActual);\n for (i=0; i< m_sOutPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_out_bm_count,i)) {\n            DEBUG_PRINT_LOW(\"Found a Free Output Buffer %d\",i);\n break;\n }\n }\n if (eRet == OMX_ErrorNone) {\n if (i < m_sOutPortDef.nBufferCountActual) {\n#ifdef USE_ION\n#ifdef _MSM8974_\n            align_size = ((m_sOutPortDef.nBufferSize + 4095)/4096) * 4096;\n            m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(align_size,\n &m_pOutput_ion[i].ion_alloc_data,\n &m_pOutput_ion[i].fd_ion_data, ION_FLAG_CACHED);\n#else\n            m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sOutPortDef.nBufferSize,\n &m_pOutput_ion[i].ion_alloc_data,\n &m_pOutput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pOutput_ion[i].ion_device_fd < 0) {\n                DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n\n            m_pOutput_pmem[i].fd = m_pOutput_ion[i].fd_ion_data.fd;\n#else\n            m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n if (m_pOutput_pmem[i].fd == 0) {\n                m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pOutput_pmem[i].fd < 0) {\n                DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n            m_pOutput_pmem[i].size = m_sOutPortDef.nBufferSize;\n            m_pOutput_pmem[i].offset = 0;\n\n            m_pOutput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n if(!secure_session) {\n#ifdef _MSM8974_\n                m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                    align_size,PROT_READ|PROT_WRITE,\n                    MAP_SHARED,m_pOutput_pmem[i].fd,0);\n#else\n                m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                    m_pOutput_pmem[i].size,PROT_READ|PROT_WRITE,\n                    MAP_SHARED,m_pOutput_pmem[i].fd,0);\n#endif\n if (m_pOutput_pmem[i].buffer == MAP_FAILED) {\n                    DEBUG_PRINT_ERROR(\"ERROR: MMAP_FAILED in o/p alloc buffer\");\n                close (m_pOutput_pmem[i].fd);\n#ifdef USE_ION\n                free_ion_memory(&m_pOutput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n }\n else {\n\n                 m_pOutput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));\n                 native_handle_t *handle = native_handle_create(1, 0);\n                 handle->data[0] = m_pOutput_pmem[i].fd;\n                 char *data = (char*) m_pOutput_pmem[i].buffer;\n                OMX_U32 type = 1;\n                memcpy(data, &type, sizeof(OMX_U32));\n                memcpy(data + sizeof(OMX_U32), &handle, sizeof(native_handle_t*));\n }\n\n *bufferHdr = (m_out_mem_ptr + i );\n (*bufferHdr)->pBuffer = (OMX_U8 *)m_pOutput_pmem[i].buffer;\n (*bufferHdr)->pAppPrivate = appData;\n\n            BITMASK_SET(&m_out_bm_count,i);\n\n if (dev_use_buf(&m_pOutput_pmem[i],PORT_INDEX_OUT,i) != true) {\n                DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf FAILED for o/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n } else {\n            DEBUG_PRINT_ERROR(\"ERROR: All o/p buffers are allocated, invalid allocate buf call\"\n \"for index [%d] actual: %u\", i, (unsigned int)m_sOutPortDef.nBufferCountActual);\n }\n }\n\n return eRet;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Compositor::IssueExternalBeginFrame(const viz::BeginFrameArgs& args) {\n  TRACE_EVENT1(\"ui\", \"Compositor::IssueExternalBeginFrame\", \"args\",\n               args.AsValue());\n  DCHECK(external_begin_frames_enabled_);\n  if (context_factory_private_)\n    context_factory_private_->IssueExternalBeginFrame(this, args);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->ipv6))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "const CuePoint* Cues::GetLast() const\n{\n    if (m_cue_points == NULL)\n        return NULL;\n    if (m_count <= 0)\n        return NULL;\n \n #if 0\n     LoadCuePoint();  //init cues\n\n const size_t count = m_count + m_preload_count;\n\n if (count == 0) //weird\n return NULL;\n\n const size_t index = count - 1;\n\n CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n\n CuePoint* const pCP = pp[index];\n    assert(pCP);\n\n\n     pCP->Load(m_pSegment->m_pReader);\n     assert(pCP->GetTimeCode() >= 0);\n #else\n    const long index = m_count - 1;\n \n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n \n    CuePoint* const pCP = pp[index];\n    assert(pCP);\n    assert(pCP->GetTimeCode() >= 0);\n #endif\n \n    return pCP;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void PanelsNotOverlapping(aura::Window* panel1, aura::Window* panel2) {\n    shelf_view_test()->RunMessageLoopUntilAnimationsDone();\n    gfx::Rect window1_bounds = panel1->GetBoundsInRootWindow();\n    gfx::Rect window2_bounds = panel2->GetBoundsInRootWindow();\n\n    EXPECT_FALSE(window1_bounds.Intersects(window2_bounds));\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void DownloadFileManager::CompleteDownload(DownloadId global_id) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n \n   if (!ContainsKey(downloads_, global_id))\n    return;\n\n  DownloadFile* download_file = downloads_[global_id];\n\n  VLOG(20) << \" \" << __FUNCTION__ << \"()\"\n            << \" id = \" << global_id\n            << \" download_file = \" << download_file->DebugString();\n \n   download_file->Detach();\n \n   EraseDownload(global_id);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GDataDirectory::RemoveChildFiles() {\n  for (GDataFileCollection::const_iterator iter = child_files_.begin();\n       iter != child_files_.end(); ++iter) {\n    if (directory_service_)\n      directory_service_->RemoveEntryFromResourceMap(iter->second);\n  }\n  STLDeleteValues(&child_files_);\n  child_files_.clear();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CreateFieldTrial(const char* trial_name, const char* group_name) {\n    base::FieldTrialList::CreateFieldTrial(trial_name, group_name);\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void usb_serial_console_init(int minor)\n{\n\tif (minor == 0) {\n\t\t/*\n\t\t * Call register_console() if this is the first device plugged\n\t\t * in.  If we call it earlier, then the callback to\n\t\t * console_setup() will fail, as there is not a device seen by\n\t\t * the USB subsystem yet.\n\t\t */\n\t\t/*\n\t\t * Register console.\n\t\t * NOTES:\n\t\t * console_setup() is called (back) immediately (from\n\t\t * register_console). console_write() is called immediately\n\t\t * from register_console iff CON_PRINTBUFFER is set in flags.\n\t\t */\n\t\tpr_debug(\"registering the USB serial console.\\n\");\n\t\tregister_console(&usbcons);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n \t\treturn retval;\n \t}\n \n\t/* ipc_addid() locks msq upon success. */\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n \tmsq->q_stime = msq->q_rtime = 0;\n \tmsq->q_ctime = get_seconds();\n \tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n \tINIT_LIST_HEAD(&msq->q_receivers);\n \tINIT_LIST_HEAD(&msq->q_senders);\n \n \tipc_unlock_object(&msq->q_perm);\n \trcu_read_unlock();\n \n\treturn msq->q_perm.id;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ASCII85Stream::~ASCII85Stream() {\n  delete str;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int pmu_dev_alloc(struct pmu *pmu)\n{\n\tint ret = -ENOMEM;\n\n\tpmu->dev = kzalloc(sizeof(struct device), GFP_KERNEL);\n\tif (!pmu->dev)\n\t\tgoto out;\n\n\tdevice_initialize(pmu->dev);\n\tret = dev_set_name(pmu->dev, \"%s\", pmu->name);\n\tif (ret)\n\t\tgoto free_dev;\n\n\tdev_set_drvdata(pmu->dev, pmu);\n\tpmu->dev->bus = &pmu_bus;\n\tpmu->dev->release = pmu_dev_release;\n\tret = device_add(pmu->dev);\n\tif (ret)\n\t\tgoto free_dev;\n\nout:\n\treturn ret;\n\nfree_dev:\n\tput_device(pmu->dev);\n\tgoto out;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n \n \tcmap->numchans = (box->datalen) / 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (uaddr == uaddr2)\n\t\treturn -EINVAL;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\tRB_CLEAR_NODE(&rt_waiter.pi_tree_entry);\n\tRB_CLEAR_NODE(&rt_waiter.tree_entry);\n\trt_waiter.task = NULL;\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n \tif (ret)\n \t\tgoto out_key2;\n \n \t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n \tfutex_wait_queue_me(hb, &q, to);\n \n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (pi_mutex && rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Browser::CanBookmarkAllTabs() const {\n  BookmarkModel* model = profile()->GetBookmarkModel();\n  return (model && model->IsLoaded() && (tab_count() > 1));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void php_mysqlnd_eof_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tif (!stack_allocation) {\n\t\tmnd_pefree(_packet, ((MYSQLND_PACKET_EOF *)_packet)->header.persistent);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)\n{\n    EAS_RESULT result;\n    SDLS_SYNTHESIZER_DATA dls;\n    EAS_U32 temp;\n    EAS_I32 pos;\n    EAS_I32 chunkPos;\n    EAS_I32 size;\n    EAS_I32 instSize;\n    EAS_I32 rgnPoolSize;\n    EAS_I32 artPoolSize;\n    EAS_I32 waveLenSize;\n    EAS_I32 endDLS;\n    EAS_I32 wvplPos;\n    EAS_I32 wvplSize;\n    EAS_I32 linsPos;\n    EAS_I32 linsSize;\n    EAS_I32 ptblPos;\n    EAS_I32 ptblSize;\n void *p;\n\n /* zero counts and pointers */\n    EAS_HWMemSet(&dls, 0, sizeof(dls));\n\n /* save file handle and hwInstData to save copying pointers around */\n    dls.hwInstData = hwInstData;\n    dls.fileHandle = fileHandle;\n\n /* NULL return value in case of error */\n *ppDLS = NULL;\n\n /* seek to start of DLS and read in RIFF tag and set processor endian flag */\n if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)\n return result;\n if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)\n return result;\n\n /* check for processor endian-ness */\n    dls.bigEndian = (temp == CHUNK_RIFF);\n\n /* first chunk should be DLS */\n    pos = offset;\n if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n if (temp != CHUNK_DLS)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Expected DLS chunk, got %08lx\\n\", temp); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* no instrument or wavepool chunks */\n    linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;\n\n /* scan the chunks in the DLS list */\n    endDLS = offset + size;\n    pos = offset + 12;\n while (pos < endDLS)\n {\n        chunkPos = pos;\n\n /* get the next chunk type */\n if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* parse useful chunks */\n switch (temp)\n {\n case CHUNK_CDL:\n if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)\n return result;\n if (!temp)\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n break;\n\n case CHUNK_LINS:\n                linsPos = chunkPos + 12;\n                linsSize = size - 4;\n break;\n\n case CHUNK_WVPL:\n                wvplPos = chunkPos + 12;\n                wvplSize = size - 4;\n break;\n\n case CHUNK_PTBL:\n                ptblPos = chunkPos + 8;\n                ptblSize = size - 4;\n break;\n\n default:\n break;\n }\n }\n\n /* must have a lins chunk */\n if (linsSize == 0)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No lins chunk found\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* must have a wvpl chunk */\n if (wvplSize == 0)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No wvpl chunk found\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* must have a ptbl chunk */\n if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No ptbl chunk found\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* pre-parse the wave pool chunk */\n if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)\n return result;\n\n /* limit check  */\n if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #waves [%u]\\n\", dls.waveCount); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* allocate memory for wsmp data */\n    dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));\n if (dls.wsmpData == NULL)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"EAS_HWMalloc for wsmp data failed\\n\"); */ }\n return EAS_ERROR_MALLOC_FAILED;\n }\n    EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));\n\n /* pre-parse the lins chunk */\n    result = Parse_lins(&dls, linsPos, linsSize);\n if (result == EAS_SUCCESS)\n {\n\n /* limit check  */\n if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #regions [%u]\\n\", dls.regionCount); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* limit check  */\n if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #articulations [%u]\\n\", dls.regionCount); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* limit check  */\n if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #instruments [%u]\\n\", dls.instCount); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* Allocate memory for the converted DLS data */\n /* calculate size of instrument data */\n        instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);\n\n /* calculate size of region pool */\n        rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);\n\n /* calculate size of articulation pool, add one for default articulation */\n        dls.artCount++;\n        artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);\n\n /* calculate size of wave length and offset arrays */\n        waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));\n\n /* calculate final memory size */\n        size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;\n if (size <= 0) {\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* allocate the main EAS chunk */\n        dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);\n if (dls.pDLS == NULL)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"EAS_HWMalloc failed for DLS memory allocation size %ld\\n\", size); */ }\n return EAS_ERROR_MALLOC_FAILED;\n }\n        EAS_HWMemSet(dls.pDLS, 0, size);\n        dls.pDLS->refCount = 1;\n        p = PtrOfs(dls.pDLS, sizeof(S_EAS));\n\n /* setup pointer to programs */\n        dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;\n        dls.pDLS->pDLSPrograms = p;\n        p = PtrOfs(p, instSize);\n\n /* setup pointer to regions */\n        dls.pDLS->pDLSRegions = p;\n        dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;\n        p = PtrOfs(p, rgnPoolSize);\n\n /* setup pointer to articulations */\n        dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;\n        dls.pDLS->pDLSArticulations = p;\n        p = PtrOfs(p, artPoolSize);\n\n /* setup pointer to wave length table */\n        dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;\n        dls.pDLS->pDLSSampleLen = p;\n        p = PtrOfs(p, waveLenSize);\n\n /* setup pointer to wave offsets table */\n        dls.pDLS->pDLSSampleOffsets = p;\n        p = PtrOfs(p, waveLenSize);\n\n /* setup pointer to wave pool */\n        dls.pDLS->pDLSSamples = p;\n\n /* clear filter flag */\n        dls.filterUsed = EAS_FALSE;\n\n /* parse the wave pool and load samples */\n        result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);\n\n     }\n \n     /* create the default articulation */\n    Convert_art(&dls, &defaultArt, 0);\n    dls.artCount = 1;\n \n     /* parse the lins chunk and load instruments */\n     dls.regionCount = dls.instCount = 0;\n if (result == EAS_SUCCESS)\n        result = Parse_lins(&dls, linsPos, linsSize);\n\n /* clean up any temporary objects that were allocated */\n if (dls.wsmpData)\n        EAS_HWFree(dls.hwInstData, dls.wsmpData);\n\n /* if successful, return a pointer to the EAS collection */\n if (result == EAS_SUCCESS)\n {\n *ppDLS = dls.pDLS;\n#ifdef _DEBUG_DLS\n DumpDLS(dls.pDLS);\n#endif\n }\n\n /* something went wrong, deallocate the EAS collection */\n else\n DLSCleanup(dls.hwInstData, dls.pDLS);\n\n return result;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "pid_t IPCThreadState::getCallingPid() const\n{\n return mCallingPid;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int lua_ap_clock(lua_State *L)\n{\n    apr_time_t now;\n    now = apr_time_now();\n    lua_pushnumber(L, (lua_Number) now);\n    return 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool TabsCaptureVisibleTabFunction::RunImpl() {\n  PrefService* service = profile()->GetPrefs();\n  if (service->GetBoolean(prefs::kDisableScreenshots)) {\n    error_ = keys::kScreenshotsDisabled;\n    return false;\n  }\n\n  WebContents* web_contents = NULL;\n  if (!GetTabToCapture(&web_contents))\n    return false;\n\n  image_format_ = FORMAT_JPEG;  // Default format is JPEG.\n  image_quality_ = kDefaultQuality;  // Default quality setting.\n\n  if (HasOptionalArgument(1)) {\n    DictionaryValue* options = NULL;\n    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));\n\n    if (options->HasKey(keys::kFormatKey)) {\n      std::string format;\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetString(keys::kFormatKey, &format));\n\n      if (format == keys::kFormatValueJpeg) {\n        image_format_ = FORMAT_JPEG;\n      } else if (format == keys::kFormatValuePng) {\n        image_format_ = FORMAT_PNG;\n      } else {\n        EXTENSION_FUNCTION_VALIDATE(0);\n      }\n    }\n\n    if (options->HasKey(keys::kQualityKey)) {\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetInteger(keys::kQualityKey, &image_quality_));\n     }\n   }\n \n  if (!GetExtension()->CanCaptureVisiblePage(\n        web_contents->GetURL(),\n        SessionID::IdForTab(web_contents),\n        &error_)) {\n     return false;\n   }\n \n  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();\n  content::RenderWidgetHostView* view = render_view_host->GetView();\n  if (!view) {\n    error_ = keys::kInternalVisibleTabCaptureError;\n    return false;\n  }\n  render_view_host->CopyFromBackingStore(\n      gfx::Rect(),\n      view->GetViewBounds().size(),\n      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,\n                 this));\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void PrintingMessageFilter::OnCheckForCancel(const std::string& preview_ui_addr,\n                                              int preview_request_id,\n                                              bool* cancel) {\n  PrintPreviewUI::GetCurrentPrintPreviewStatus(preview_ui_addr,\n                                                preview_request_id,\n                                                cancel);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "GF_Err sdp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "hstore_from_arrays(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tDatum\t   *value_datums;\n\tbool\t   *value_nulls;\n\tint\t\t\tvalue_count;\n\tArrayType  *key_array;\n\tArrayType  *value_array;\n\tint\t\t\ti;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tkey_array = PG_GETARG_ARRAYTYPE_P(0);\n\n\tAssert(ARR_ELEMTYPE(key_array) == TEXTOID);\n\n\t/*\n\t * must check >1 rather than != 1 because empty arrays have 0 dimensions,\n\t * not 1\n\t */\n\n\tif (ARR_NDIM(key_array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tdeconstruct_array(key_array,\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n \t/* value_array might be NULL */\n \n \tif (PG_ARGISNULL(1))\n\t{\n\t\tvalue_array = NULL;\n\t\tvalue_count = key_count;\n\t\tvalue_datums = NULL;\n\t\tvalue_nulls = NULL;\n\t}\n\telse\n\t{\n\t\tvalue_array = PG_GETARG_ARRAYTYPE_P(1);\n\n\t\tAssert(ARR_ELEMTYPE(value_array) == TEXTOID);\n\n\t\tif (ARR_NDIM(value_array) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t\tif ((ARR_NDIM(key_array) > 0 || ARR_NDIM(value_array) > 0) &&\n\t\t\t(ARR_NDIM(key_array) != ARR_NDIM(value_array) ||\n\t\t\t ARR_DIMS(key_array)[0] != ARR_DIMS(value_array)[0] ||\n\t\t\t ARR_LBOUND(key_array)[0] != ARR_LBOUND(value_array)[0]))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"arrays must have same bounds\")));\n\n\t\tdeconstruct_array(value_array,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &value_datums, &value_nulls, &value_count);\n\n\t\tAssert(key_count == value_count);\n\t}\n\n\tpairs = palloc(key_count * sizeof(Pairs));\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tif (!value_nulls || value_nulls[i])\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = 4;\n\t\t\tpairs[i].isnull = true;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].key = VARDATA_ANY(key_datums[i]);\n\t\t\tpairs[i].val = VARDATA_ANY(value_datums[i]);\n\t\t\tpairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(key_datums[i]));\n\t\t\tpairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(value_datums[i]));\n\t\t\tpairs[i].isnull = false;\n\t\t\tpairs[i].needfree = false;\n\t\t}\n\t}\n\n\tkey_count = hstoreUniquePairs(pairs, key_count, &buflen);\n\n\tout = hstorePairs(pairs, key_count, buflen);\n\n\tPG_RETURN_POINTER(out);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)\n {\n     if (!m_start.container()) {\n        ec = INVALID_STATE_ERR;\n        return 0;\n    }\n\n    Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();\n    if (!element || !element->isHTMLElement()) {\n        ec = NOT_SUPPORTED_ERR;\n         return 0;\n     }\n \n    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);\n \n     if (!fragment) {\n         ec = NOT_SUPPORTED_ERR;\n        return 0;\n    }\n\n    return fragment.release();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "entry_guards_update_all(guard_selection_t *gs)\n{\n  sampled_guards_update_from_consensus(gs);\n  entry_guards_update_filtered_sets(gs);\n  entry_guards_update_confirmed(gs);\n  entry_guards_update_primary(gs);\n  return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GLES2DecoderImpl::DoTexSubImage2D(\n  GLenum target,\n  GLint level,\n  GLint xoffset,\n  GLint yoffset,\n  GLsizei width,\n  GLsizei height,\n  GLenum format,\n  GLenum type,\n  const void * data) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glTexSubImage2D\", \"unknown texture for target\");\n    return;\n  }\n  GLenum current_type = 0;\n  GLenum internal_format = 0;\n  if (!info->GetLevelType(target, level, &current_type, &internal_format)) {\n    SetGLError(\n        GL_INVALID_OPERATION, \"glTexSubImage2D\", \"level does not exist.\");\n    return;\n  }\n  if (format != internal_format) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glTexSubImage2D\", \"format does not match internal format.\");\n    return;\n  }\n  if (type != current_type) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glTexSubImage2D\", \"type does not match type of texture.\");\n    return;\n  }\n\n  if (!info->ValidForTexture(\n          target, level, xoffset, yoffset, width, height, format, type)) {\n    SetGLError(GL_INVALID_VALUE, \"glTexSubImage2D\", \"bad dimensions.\");\n    return;\n  }\n\n  if ((GLES2Util::GetChannelsForFormat(format) &\n       (GLES2Util::kDepth | GLES2Util::kStencil)) != 0) {\n    SetGLError(\n        GL_INVALID_OPERATION,\n        \"glTexSubImage2D\", \"can not supply data for depth or stencil textures\");\n    return;\n  }\n\n  GLsizei tex_width = 0;\n  GLsizei tex_height = 0;\n  bool ok = info->GetLevelSize(target, level, &tex_width, &tex_height);\n  DCHECK(ok);\n  if (xoffset != 0 || yoffset != 0 ||\n      width != tex_width || height != tex_height) {\n    if (!texture_manager()->ClearTextureLevel(this, info, target, level)) {\n      SetGLError(GL_OUT_OF_MEMORY, \"glTexSubImage2D\", \"dimensions too big\");\n      return;\n    }\n    ScopedTextureUploadTimer timer(this);\n    glTexSubImage2D(\n        target, level, xoffset, yoffset, width, height, format, type, data);\n    return;\n  }\n\n  if (teximage2d_faster_than_texsubimage2d_ && !info->IsImmutable()) {\n    ScopedTextureUploadTimer timer(this);\n    WrappedTexImage2D(\n        target, level, format, width, height, 0, format, type, data);\n  } else {\n    ScopedTextureUploadTimer timer(this);\n    glTexSubImage2D(\n        target, level, xoffset, yoffset, width, height, format, type, data);\n  }\n  texture_manager()->SetLevelCleared(info, target, level);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "base::string16 IDNToUnicodeWithAdjustments(\n    base::StringPiece host, base::OffsetAdjuster::Adjustments* adjustments) {\n  if (adjustments)\n    adjustments->clear();\n  base::string16 input16;\n   input16.reserve(host.length());\n   input16.insert(input16.end(), host.begin(), host.end());\n \n   base::string16 out16;\n  for (size_t component_start = 0, component_end;\n       component_start < input16.length();\n       component_start = component_end + 1) {\n    component_end = input16.find('.', component_start);\n    if (component_end == base::string16::npos)\n      component_end = input16.length();  // For getting the last component.\n    size_t component_length = component_end - component_start;\n    size_t new_component_start = out16.length();\n    bool converted_idn = false;\n    if (component_end > component_start) {\n       converted_idn =\n           IDNToUnicodeOneComponent(input16.data() + component_start,\n                                   component_length, &out16);\n     }\n     size_t new_component_length = out16.length() - new_component_start;\n \n    if (converted_idn && adjustments) {\n      adjustments->push_back(base::OffsetAdjuster::Adjustment(\n          component_start, component_length, new_component_length));\n    }\n\n    if (component_end < input16.length())\n      out16.push_back('.');\n  }\n  return out16;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Curl_cookie_freelist(struct Cookie *co, bool cookiestoo)\n{\n  struct Cookie *next;\n  if(co) {\n    while(co) {\n      next = co->next;\n      if(cookiestoo)\n        freecookie(co);\n      else\n        free(co); /* we only free the struct since the \"members\" are all just\n                     pointed out in the main cookie list! */\n      co = next;\n    }\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool PrintRenderFrameHelper::FinalizePrintReadyDocument() {\n  DCHECK(!is_print_ready_metafile_sent_);\n  print_preview_context_.FinalizePrintReadyDocument();\n\n   PdfMetafileSkia* metafile = print_preview_context_.metafile();\n   PrintHostMsg_DidPreviewDocument_Params preview_params;\n \n  if (!CopyMetafileDataToSharedMem(*metafile,\n                                   &preview_params.metafile_data_handle)) {\n    LOG(ERROR) << \"CopyMetafileDataToSharedMem failed\";\n     print_preview_context_.set_error(PREVIEW_ERROR_METAFILE_COPY_FAILED);\n     return false;\n   }\n\n  preview_params.data_size = metafile->GetDataSize();\n  preview_params.document_cookie = print_pages_params_->params.document_cookie;\n  preview_params.expected_pages_count =\n      print_preview_context_.total_page_count();\n  preview_params.modifiable = print_preview_context_.IsModifiable();\n  preview_params.preview_request_id =\n      print_pages_params_->params.preview_request_id;\n\n  is_print_ready_metafile_sent_ = true;\n\n  Send(new PrintHostMsg_MetafileReadyForPrinting(routing_id(), preview_params));\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void floatArrayAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_VOID(Vector<float>, cppValue, toNativeArray<float>(jsValue, 0, info.GetIsolate()));\n    imp->setFloatArray(cppValue);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool findParam(uint32_t key, T *param,\n KeyedVector<uint32_t, uint64_t> &params) {\n    CHECK(param);\n if (params.indexOfKey(key) < 0) {\n return false;\n }\n *param = (T) params[key];\n return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void AudioSource::rampVolume(\n int32_t startFrame, int32_t rampDurationFrames,\n uint8_t *data, size_t bytes) {\n\n const int32_t kShift = 14;\n int32_t fixedMultiplier = (startFrame << kShift) / rampDurationFrames;\n const int32_t nChannels = mRecord->channelCount();\n int32_t stopFrame = startFrame + bytes / sizeof(int16_t);\n int16_t *frame = (int16_t *) data;\n if (stopFrame > rampDurationFrames) {\n        stopFrame = rampDurationFrames;\n }\n\n while (startFrame < stopFrame) {\n if (nChannels == 1) { // mono\n            frame[0] = (frame[0] * fixedMultiplier) >> kShift;\n ++frame;\n ++startFrame;\n } else { // stereo\n            frame[0] = (frame[0] * fixedMultiplier) >> kShift;\n            frame[1] = (frame[1] * fixedMultiplier) >> kShift;\n            frame += 2;\n            startFrame += 2;\n }\n\n if ((startFrame & 3) == 0) {\n            fixedMultiplier = (startFrame << kShift) / rampDurationFrames;\n }\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n \n \t/* The epoch may have changed.  If so, process all the\n \t * pending records.  This is a non-blocking operation. */\n\tdtls1_process_buffered_records(s);\n \n \t/* if we're renegotiating, then there may be buffered records */\n \tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n \t\t{\n \t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n \t\t\t{\n\t\t\tdtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\n \t\t\t}\n \t\trr->length = 0;\n \t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n \t\ts->packet_length = 0;  /* dump this record */\n \t\tgoto again;   /* get another record */\n \t\t}\n \n \treturn(1);\n \n\t}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n \tint i;\n \n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n \t\treturn 0;\n\tfor (i = 0; i < bin->nsegs; ++i)\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n \t\t\treturn bin->segs[i].vmaddr;\n \treturn 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static CURLcode create_conn_helper_init_proxy(struct connectdata *conn)\n{\n  char *proxy = NULL;\n  char *socksproxy = NULL;\n  char *no_proxy = NULL;\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  /*************************************************************\n   * Extract the user and password from the authentication string\n   *************************************************************/\n  if(conn->bits.proxy_user_passwd) {\n    result = parse_proxy_auth(data, conn);\n    if(result)\n      goto out;\n  }\n\n  /*************************************************************\n   * Detect what (if any) proxy to use\n   *************************************************************/\n  if(data->set.str[STRING_PROXY]) {\n    proxy = strdup(data->set.str[STRING_PROXY]);\n    /* if global proxy is set, this is it */\n    if(NULL == proxy) {\n      failf(data, \"memory shortage\");\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(data->set.str[STRING_PRE_PROXY]) {\n    socksproxy = strdup(data->set.str[STRING_PRE_PROXY]);\n    /* if global socks proxy is set, this is it */\n    if(NULL == socksproxy) {\n      failf(data, \"memory shortage\");\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(!data->set.str[STRING_NOPROXY]) {\n    const char *p = \"no_proxy\";\n    no_proxy = curl_getenv(p);\n    if(!no_proxy) {\n      p = \"NO_PROXY\";\n      no_proxy = curl_getenv(p);\n    }\n    if(no_proxy) {\n      infof(conn->data, \"Uses proxy env variable %s == '%s'\\n\", p, no_proxy);\n    }\n  }\n\n  if(check_noproxy(conn->host.name, data->set.str[STRING_NOPROXY] ?\n      data->set.str[STRING_NOPROXY] : no_proxy)) {\n    Curl_safefree(proxy);\n    Curl_safefree(socksproxy);\n  }\n#ifndef CURL_DISABLE_HTTP\n  else if(!proxy && !socksproxy)\n    /* if the host is not in the noproxy list, detect proxy. */\n    proxy = detect_proxy(conn);\n#endif /* CURL_DISABLE_HTTP */\n\n  Curl_safefree(no_proxy);\n\n#ifdef USE_UNIX_SOCKETS\n  /* For the time being do not mix proxy and unix domain sockets. See #1274 */\n  if(proxy && conn->unix_domain_socket) {\n    free(proxy);\n    proxy = NULL;\n  }\n#endif\n\n  if(proxy && (!*proxy || (conn->handler->flags & PROTOPT_NONETWORK))) {\n    free(proxy);  /* Don't bother with an empty proxy string or if the\n                     protocol doesn't work with network */\n    proxy = NULL;\n  }\n  if(socksproxy && (!*socksproxy ||\n                    (conn->handler->flags & PROTOPT_NONETWORK))) {\n    free(socksproxy);  /* Don't bother with an empty socks proxy string or if\n                          the protocol doesn't work with network */\n    socksproxy = NULL;\n  }\n\n  /***********************************************************************\n   * If this is supposed to use a proxy, we need to figure out the proxy host\n   * name, proxy type and port number, so that we can re-use an existing\n   * connection that may exist registered to the same proxy host.\n   ***********************************************************************/\n  if(proxy || socksproxy) {\n    if(proxy) {\n      result = parse_proxy(data, conn, proxy, conn->http_proxy.proxytype);\n      Curl_safefree(proxy); /* parse_proxy copies the proxy string */\n      if(result)\n        goto out;\n    }\n\n    if(socksproxy) {\n      result = parse_proxy(data, conn, socksproxy,\n                           conn->socks_proxy.proxytype);\n      /* parse_proxy copies the socks proxy string */\n      Curl_safefree(socksproxy);\n      if(result)\n        goto out;\n    }\n\n    if(conn->http_proxy.host.rawalloc) {\n#ifdef CURL_DISABLE_HTTP\n      /* asking for a HTTP proxy is a bit funny when HTTP is disabled... */\n      result = CURLE_UNSUPPORTED_PROTOCOL;\n      goto out;\n#else\n      /* force this connection's protocol to become HTTP if compatible */\n      if(!(conn->handler->protocol & PROTO_FAMILY_HTTP)) {\n        if((conn->handler->flags & PROTOPT_PROXY_AS_HTTP) &&\n           !conn->bits.tunnel_proxy)\n          conn->handler = &Curl_handler_http;\n        else\n          /* if not converting to HTTP over the proxy, enforce tunneling */\n          conn->bits.tunnel_proxy = TRUE;\n      }\n      conn->bits.httpproxy = TRUE;\n#endif\n    }\n    else {\n      conn->bits.httpproxy = FALSE; /* not a HTTP proxy */\n      conn->bits.tunnel_proxy = FALSE; /* no tunneling if not HTTP */\n    }\n\n    if(conn->socks_proxy.host.rawalloc) {\n      if(!conn->http_proxy.host.rawalloc) {\n        /* once a socks proxy */\n        if(!conn->socks_proxy.user) {\n          conn->socks_proxy.user = conn->http_proxy.user;\n          conn->http_proxy.user = NULL;\n          Curl_safefree(conn->socks_proxy.passwd);\n          conn->socks_proxy.passwd = conn->http_proxy.passwd;\n          conn->http_proxy.passwd = NULL;\n        }\n      }\n      conn->bits.socksproxy = TRUE;\n    }\n    else\n      conn->bits.socksproxy = FALSE; /* not a socks proxy */\n  }\n  else {\n    conn->bits.socksproxy = FALSE;\n    conn->bits.httpproxy = FALSE;\n  }\n  conn->bits.proxy = conn->bits.httpproxy || conn->bits.socksproxy;\n\n  if(!conn->bits.proxy) {\n    /* we aren't using the proxy after all... */\n    conn->bits.proxy = FALSE;\n    conn->bits.httpproxy = FALSE;\n    conn->bits.socksproxy = FALSE;\n    conn->bits.proxy_user_passwd = FALSE;\n    conn->bits.tunnel_proxy = FALSE;\n  }\n\nout:\n\n  free(socksproxy);\n  free(proxy);\n  return result;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static const char *set_limit_req_body(cmd_parms *cmd, void *conf_,\n                                      const char *arg)\n{\n    core_dir_config *conf = conf_;\n    char *errp;\n\n    if (APR_SUCCESS != apr_strtoff(&conf->limit_req_body, arg, &errp, 10)) {\n        return \"LimitRequestBody argument is not parsable.\";\n    }\n    if (*errp || conf->limit_req_body < 0) {\n        return \"LimitRequestBody requires a non-negative integer.\";\n    }\n\n    return NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,\n                                          int64_t offline_id) {\n   JNIEnv* env = AttachCurrentThread();\n   Java_OfflinePageDownloadBridge_openItem(\n      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "poppler_page_prepare_output_dev (PopplerPage *page,\n\t\t\t\t double scale,\n\t\t\t\t int rotation,\n\t\t\t\t gboolean transparent,\n\t\t\t\t OutputDevData *output_dev_data)\n{\n  CairoOutputDev *output_dev;\n  cairo_surface_t *surface;\n  double width, height;\n  int cairo_width, cairo_height, cairo_rowstride, rotate;\n  unsigned char *cairo_data;\n\n  rotate = rotation + page->page->getRotate ();\n  if (rotate == 90 || rotate == 270) {\n    height = page->page->getCropWidth ();\n    width = page->page->getCropHeight ();\n  } else {\n    width = page->page->getCropWidth ();\n    height = page->page->getCropHeight ();\n  }\n\n  cairo_width = (int) ceil(width * scale);\n  cairo_height = (int) ceil(height * scale);\n \n   output_dev = page->document->output_dev;\n   cairo_rowstride = cairo_width * 4;\n  cairo_data = (guchar *) gmalloc (cairo_height * cairo_rowstride);\n   if (transparent)\n       memset (cairo_data, 0x00, cairo_height * cairo_rowstride);\n   else\n      memset (cairo_data, 0xff, cairo_height * cairo_rowstride);\n\n  surface = cairo_image_surface_create_for_data(cairo_data,\n\t\t\t\t\t\tCAIRO_FORMAT_ARGB32,\n\t  \t\t\t\t\tcairo_width, cairo_height, \n\t\t\t\t\t\tcairo_rowstride);\n\n  output_dev_data->cairo_data = cairo_data;\n  output_dev_data->surface = surface;\n  output_dev_data->cairo = cairo_create (surface);\n  output_dev->setCairo (output_dev_data->cairo);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)\n{\n\tunsigned long i;\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadLABELImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MaxTextExtent],\n    *property;\n\n  const char\n    *label;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    width;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  property=InterpretImageProperties(image_info,image,image_info->filename);\n  (void) SetImageProperty(image,\"label\",property);\n  property=DestroyString(property);\n  label=GetImageProperty(image,\"label\");\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->text=ConstantString(label);\n  metrics.width=0;\n  metrics.ascent=0.0;\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n  if ((image->columns == 0) && (image->rows == 0))\n    {\n      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n      image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n    }\n  else\n    if ((strlen(label) > 0) &&\n        (((image->columns == 0) || (image->rows == 0)) ||\n         (fabs(image_info->pointsize) < MagickEpsilon)))\n      {\n        double\n          high,\n          low;\n\n        /*\n          Auto fit text into bounding box.\n        */\n        for ( ; ; draw_info->pointsize*=2.0)\n        {\n          (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width >= image->columns) && (height >= image->rows))\n                break;\n            }\n          else\n            if (((image->columns != 0) && (width >= image->columns)) ||\n                ((image->rows != 0) && (height >= image->rows)))\n              break;\n        }\n        high=draw_info->pointsize;\n        for (low=1.0; (high-low) > 0.5; )\n        {\n          draw_info->pointsize=(low+high)/2.0;\n          (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width < image->columns) && (height < image->rows))\n                low=draw_info->pointsize+0.5;\n              else\n                high=draw_info->pointsize-0.5;\n            }\n          else\n            if (((image->columns != 0) && (width < image->columns)) ||\n                ((image->rows != 0) && (height < image->rows)))\n              low=draw_info->pointsize+0.5;\n            else\n              high=draw_info->pointsize-0.5;\n        }\n        draw_info->pointsize=(low+high)/2.0-0.5;\n      }\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image->columns == 0)\n    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n  if (image->columns == 0)\n    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+\n      0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) floor(metrics.ascent-metrics.descent+\n      draw_info->stroke_width+0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+\n      0.5);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Draw label.\n  */\n  (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n     draw_info->direction == RightToLeftDirection ? image->columns-\n     metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?\n     metrics.ascent : 0.0);\n  draw_info->geometry=AcquireString(geometry);\n   status=AnnotateImage(image,draw_info);\n   if (image_info->pointsize == 0.0)\n     {\n      char\n        pointsize[MaxTextExtent];\n\n      (void) FormatLocaleString(pointsize,MaxTextExtent,\"%.20g\",\n        draw_info->pointsize);\n      (void) SetImageProperty(image,\"label:pointsize\",pointsize);\n    }\n  draw_info=DestroyDrawInfo(draw_info);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n  params->content_size.SetSize(\n      settings.page_setup_device_units().content_area().width(),\n      settings.page_setup_device_units().content_area().height());\n  params->printable_area.SetRect(\n      settings.page_setup_device_units().printable_area().x(),\n      settings.page_setup_device_units().printable_area().y(),\n      settings.page_setup_device_units().printable_area().width(),\n      settings.page_setup_device_units().printable_area().height());\n  params->margin_top = settings.page_setup_device_units().content_area().y();\n  params->margin_left = settings.page_setup_device_units().content_area().x();\n  params->dpi = settings.dpi();\n  params->scale_factor = settings.scale_factor();\n  params->rasterize_pdf = settings.rasterize_pdf();\n  params->document_cookie = 0;\n  params->selection_only = settings.selection_only();\n  params->supports_alpha_blend = settings.supports_alpha_blend();\n  params->should_print_backgrounds = settings.should_print_backgrounds();\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n  params->printed_doc_type = SkiaDocumentType::PDF;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool ExtensionApiTest::ExtensionSubtestsAreSkipped() {\n#if defined(OS_WIN) && !defined(NDEBUG)\n  LOG(WARNING) << \"Workaround for 177163, prematurely returning\";\n  return true;\n#else\n  return false;\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void Sp_charCodeAt(js_State *J)\n{\n\tconst char *s = checkstring(J, 0);\n\tint pos = js_tointeger(J, 1);\n\tRune rune = js_runeat(J, s, pos);\n\tif (rune > 0)\n\t\tjs_pushnumber(J, rune);\n\telse\n\t\tjs_pushnumber(J, NAN);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-400"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "append_utf8_value (const unsigned char *value, size_t length,\n                   struct stringbuf *sb)\n{\n  unsigned char tmp[6];\n  const unsigned char *s;\n  size_t n;\n  int i, nmore;\n\n  if (length && (*value == ' ' || *value == '#'))\n    {\n      tmp[0] = '\\\\';\n      tmp[1] = *value;\n      put_stringbuf_mem (sb, tmp, 2);\n      value++;\n      length--;\n    }\n  if (length && value[length-1] == ' ')\n    {\n      tmp[0] = '\\\\';\n      tmp[1] = ' ';\n      put_stringbuf_mem (sb, tmp, 2);\n       length--;\n     }\n \n  /* FIXME: check that the invalid encoding handling is correct */\n   for (s=value, n=0;;)\n     {\n       for (value = s; n < length && !(*s & 0x80); n++, s++)\n      for (value = s; n < length && !(*s & 0x80); n++, s++)\n        ;\n         append_quoted (sb, value, s-value, 0);\n       if (n==length)\n         return; /* ready */\n      assert ((*s & 0x80));\n      if ( (*s & 0xe0) == 0xc0 )      /* 110x xxxx */\n         nmore = 1;\n       else if ( (*s & 0xf0) == 0xe0 ) /* 1110 xxxx */\n         nmore = 2;\n      else if ( (*s & 0xf8) == 0xf0 ) /* 1111 0xxx */\n        nmore = 3;\n      else if ( (*s & 0xfc) == 0xf8 ) /* 1111 10xx */\n         nmore = 4;\n       else if ( (*s & 0xfe) == 0xfc ) /* 1111 110x */\n         nmore = 5;\n      else /* invalid encoding */\n        nmore = 5;  /* we will reduce the check length anyway */\n      if (n+nmore > length)\n        nmore = length - n; /* oops, encoding to short */\n \n      tmp[0] = *s++; n++;\n      for (i=1; i <= nmore; i++)\n         {\n          if ( (*s & 0xc0) != 0x80)\n            break; /* invalid encoding - stop */\n          tmp[i] = *s++;\n          n++;\n         }\n      put_stringbuf_mem (sb, tmp, i);\n     }\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n \n \tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n \t\treturn false;\n\treturn true;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int SSL_library_init(void)\n\t{\n\n#ifndef OPENSSL_NO_DES\n\tEVP_add_cipher(EVP_des_cbc());\n\tEVP_add_cipher(EVP_des_ede3_cbc());\n#endif\n#ifndef OPENSSL_NO_IDEA\n\tEVP_add_cipher(EVP_idea_cbc());\n#endif\n#ifndef OPENSSL_NO_RC4\n\tEVP_add_cipher(EVP_rc4());\n#if !defined(OPENSSL_NO_MD5) && (defined(__x86_64) || defined(__x86_64__))\n\tEVP_add_cipher(EVP_rc4_hmac_md5());\n#endif\n#endif  \n#ifndef OPENSSL_NO_RC2\n\tEVP_add_cipher(EVP_rc2_cbc());\n\t/* Not actually used for SSL/TLS but this makes PKCS#12 work\n\t * if an application only calls SSL_library_init().\n\t */\n\tEVP_add_cipher(EVP_rc2_40_cbc());\n#endif\n#ifndef OPENSSL_NO_AES\n\tEVP_add_cipher(EVP_aes_128_cbc());\n\tEVP_add_cipher(EVP_aes_192_cbc());\n        EVP_add_cipher(EVP_aes_256_cbc());\n        EVP_add_cipher(EVP_aes_128_gcm());\n        EVP_add_cipher(EVP_aes_256_gcm());\n#if 0 /* Disabled because of timing side-channel leaks. */\n #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)\n        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());\n        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());\n #endif\n#endif\n \n #endif\n #ifndef OPENSSL_NO_CAMELLIA\n#endif\n#ifndef OPENSSL_NO_CAMELLIA\n\tEVP_add_cipher(EVP_camellia_128_cbc());\n\tEVP_add_cipher(EVP_camellia_256_cbc());\n#endif\n\n#ifndef OPENSSL_NO_SEED\n\tEVP_add_cipher(EVP_seed_cbc());\n#endif\n  \n#ifndef OPENSSL_NO_MD5\n\tEVP_add_digest(EVP_md5());\n\tEVP_add_digest_alias(SN_md5,\"ssl2-md5\");\n\tEVP_add_digest_alias(SN_md5,\"ssl3-md5\");\n#endif\n#ifndef OPENSSL_NO_SHA\n\tEVP_add_digest(EVP_sha1()); /* RSA with sha1 */\n\tEVP_add_digest_alias(SN_sha1,\"ssl3-sha1\");\n\tEVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);\n#endif\n#ifndef OPENSSL_NO_SHA256\n\tEVP_add_digest(EVP_sha224());\n\tEVP_add_digest(EVP_sha256());\n#endif\n#ifndef OPENSSL_NO_SHA512\n\tEVP_add_digest(EVP_sha384());\n\tEVP_add_digest(EVP_sha512());\n#endif\n#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)\n\tEVP_add_digest(EVP_dss1()); /* DSA with sha1 */\n\tEVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);\n\tEVP_add_digest_alias(SN_dsaWithSHA1,\"DSS1\");\n\tEVP_add_digest_alias(SN_dsaWithSHA1,\"dss1\");\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\tEVP_add_digest(EVP_ecdsa());\n#endif\n\t/* If you want support for phased out ciphers, add the following */\n#if 0\n\tEVP_add_digest(EVP_sha());\n\tEVP_add_digest(EVP_dss());\n#endif\n#ifndef OPENSSL_NO_COMP\n\t/* This will initialise the built-in compression algorithms.\n\t   The value returned is a STACK_OF(SSL_COMP), but that can\n\t   be discarded safely */\n\t(void)SSL_COMP_get_compression_methods();\n#endif\n\t/* initialize cipher/digest methods table */\n\tssl_load_ciphers();\n\treturn(1);\n\t}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n {\n    u_int tlen, pdu_type, pdu_len;\n    const u_char *tptr;\n    const rpki_rtr_pdu *pdu_header;\n    tptr = pptr;\n    tlen = len;\n     if (!ndo->ndo_vflag) {\n \tND_PRINT((ndo, \", RPKI-RTR\"));\n \treturn;\n     }\n    while (tlen >= sizeof(rpki_rtr_pdu)) {\n        ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));\n\tpdu_header = (const rpki_rtr_pdu *)tptr;\n        pdu_type = pdu_header->pdu_type;\n        pdu_len = EXTRACT_32BITS(pdu_header->length);\n        ND_TCHECK2(*tptr, pdu_len);\n        /* infinite loop check */\n        if (!pdu_type || !pdu_len) {\n            break;\n        }\n        if (tlen < pdu_len) {\n            goto trunc;\n        }\n\t/*\n\t * Print the PDU.\n\t */\n\tif (rpki_rtr_pdu_print(ndo, tptr, 8))\n\t\tgoto trunc;\n        tlen -= pdu_len;\n        tptr += pdu_len;\n     }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t%s\", tstr));\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "fbCombineDisjointAtopC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineDisjointGeneralC (dest, src, mask, width, CombineAAtop);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BindSkiaToInProcessGL() {\n  static bool host_StubGL_installed = false;\n  if (!host_StubGL_installed) {\n    GrGLBinding binding;\n    switch (gfx::GetGLImplementation()) {\n      case gfx::kGLImplementationNone:\n        NOTREACHED();\n        return;\n      case gfx::kGLImplementationDesktopGL:\n        binding = kDesktop_GrGLBinding;\n        break;\n      case gfx::kGLImplementationOSMesaGL:\n        binding = kDesktop_GrGLBinding;\n        break;\n      case gfx::kGLImplementationEGLGLES2:\n        binding = kES2_GrGLBinding;\n        break;\n       case gfx::kGLImplementationMockGL:\n         NOTREACHED();\n         return;\n     }\n \n     static GrGLInterface host_gl_interface = {\n      binding,\n\n      kProbe_GrGLCapability,   // NPOTRenderTargetSupport\n      kProbe_GrGLCapability,   // MinRenderTargetHeight\n      kProbe_GrGLCapability,   // MinRenderTargetWidth\n\n      StubGLActiveTexture,\n      StubGLAttachShader,\n      StubGLBindAttribLocation,\n      StubGLBindBuffer,\n      StubGLBindTexture,\n      StubGLBlendColor,\n      StubGLBlendFunc,\n      StubGLBufferData,\n      StubGLBufferSubData,\n      StubGLClear,\n      StubGLClearColor,\n      StubGLClearStencil,\n      NULL,  // glClientActiveTexture\n      NULL,  // glColor4ub\n      StubGLColorMask,\n      NULL,  // glColorPointer\n      StubGLCompileShader,\n      StubGLCompressedTexImage2D,\n      StubGLCreateProgram,\n      StubGLCreateShader,\n      StubGLCullFace,\n      StubGLDeleteBuffers,\n      StubGLDeleteProgram,\n      StubGLDeleteShader,\n      StubGLDeleteTextures,\n      StubGLDepthMask,\n      StubGLDisable,\n      NULL,  // glDisableClientState\n      StubGLDisableVertexAttribArray,\n      StubGLDrawArrays,\n      StubGLDrawElements,\n      StubGLEnable,\n      NULL,  // glEnableClientState\n      StubGLEnableVertexAttribArray,\n      StubGLFrontFace,\n      StubGLGenBuffers,\n      StubGLGenTextures,\n      StubGLGetBufferParameteriv,\n      StubGLGetError,\n      StubGLGetIntegerv,\n      StubGLGetProgramInfoLog,\n      StubGLGetProgramiv,\n      StubGLGetShaderInfoLog,\n      StubGLGetShaderiv,\n      StubGLGetString,\n      StubGLGetUniformLocation,\n      StubGLLineWidth,\n      StubGLLinkProgram,\n      NULL,  // glLoadMatrixf\n      NULL,  // glMatrixMode\n      StubGLPixelStorei,\n      NULL,  // glPointSize\n      StubGLReadPixels,\n      StubGLScissor,\n      NULL,  // glShadeModel\n      StubGLShaderSource,\n      StubGLStencilFunc,\n      StubGLStencilFuncSeparate,\n      StubGLStencilMask,\n      StubGLStencilMaskSeparate,\n      StubGLStencilOp,\n      StubGLStencilOpSeparate,\n      NULL,  // glTexCoordPointer\n      NULL,  // glTexEnvi\n      StubGLTexImage2D,\n      StubGLTexParameteri,\n      StubGLTexSubImage2D,\n      StubGLUniform1f,\n      StubGLUniform1i,\n      StubGLUniform1fv,\n      StubGLUniform1iv,\n      StubGLUniform2f,\n      StubGLUniform2i,\n      StubGLUniform2fv,\n      StubGLUniform2iv,\n      StubGLUniform3f,\n      StubGLUniform3i,\n      StubGLUniform3fv,\n      StubGLUniform3iv,\n      StubGLUniform4f,\n      StubGLUniform4i,\n      StubGLUniform4fv,\n      StubGLUniform4iv,\n      StubGLUniformMatrix2fv,\n      StubGLUniformMatrix3fv,\n      StubGLUniformMatrix4fv,\n      StubGLUseProgram,\n      StubGLVertexAttrib4fv,\n      StubGLVertexAttribPointer,\n      NULL,  // glVertexPointer\n      StubGLViewport,\n      StubGLBindFramebuffer,\n      StubGLBindRenderbuffer,\n      StubGLCheckFramebufferStatus,\n      StubGLDeleteFramebuffers,\n      StubGLDeleteRenderbuffers,\n      StubGLFramebufferRenderbuffer,\n      StubGLFramebufferTexture2D,\n      StubGLGenFramebuffers,\n      StubGLGenRenderbuffers,\n      StubGLRenderBufferStorage,\n      StubGLRenderbufferStorageMultisample,\n      StubGLBlitFramebuffer,\n      NULL,  // glResolveMultisampleFramebuffer\n      StubGLMapBuffer,\n      StubGLUnmapBuffer,\n      NULL,  // glBindFragDataLocationIndexed\n      GrGLInterface::kStaticInitEndGuard,\n    };\n    GrGLSetGLInterface(&host_gl_interface);\n    host_StubGL_installed = true;\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (config != NULL, FALSE);\n\n\t/* Addresses */\n\tnm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);\n\n\t/* Routes */\n\t{\n\t\tint count = nm_ip4_config_get_num_routes (config);\n\t\tGArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);\n\t\tconst NMPlatformIP4Route *route;\n\t\tgboolean success;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\troute = nm_ip4_config_get_route (config, i);\n\n\t\t\t/* Don't add the route if it's more specific than one of the subnets\n\t\t\t * the device already has an IP address on.\n\t\t\t */\n\t\t\tif (   route->gateway == 0\n\t\t\t    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))\n\t\t\t\tcontinue;\n\n\t\t\tg_array_append_vals (routes, route, 1);\n\t\t}\n\n\t\tsuccess = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);\n\t\tg_array_unref (routes);\n \t\t\treturn FALSE;\n \t}\n \n\t/* MTU */\n\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n\t\tnm_platform_link_set_mtu (ifindex, mtu);\n \treturn TRUE;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n \t\treturn NULL;\n \t}\n \n \t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n \t * for the true color and palette images\n \t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long long Block::GetDiscardPadding() const\n{\n    return m_discard_padding;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void fht4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n   vp9_fht4x4_c(in, out, stride, tx_type);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void AppendParams(const std::vector<string16>& additional_names,\n                         const std::vector<string16>& additional_values,\n                         WebVector<WebString>* existing_names,\n                         WebVector<WebString>* existing_values) {\n  DCHECK(additional_names.size() == additional_values.size());\n  DCHECK(existing_names->size() == existing_values->size());\n\n  size_t existing_size = existing_names->size();\n  size_t total_size = existing_size + additional_names.size();\n\n  WebVector<WebString> names(total_size);\n  WebVector<WebString> values(total_size);\n\n  for (size_t i = 0; i < existing_size; ++i) {\n    names[i] = (*existing_names)[i];\n    values[i] = (*existing_values)[i];\n  }\n\n  for (size_t i = 0; i < additional_names.size(); ++i) {\n    names[existing_size + i] = additional_names[i];\n    values[existing_size + i] = additional_values[i];\n  }\n\n  existing_names->swap(names);\n  existing_values->swap(values);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int skcipher_prepare_alg(struct skcipher_alg *alg)\n{\n\tstruct crypto_alg *base = &alg->base;\n\n\tif (alg->ivsize > PAGE_SIZE / 8 || alg->chunksize > PAGE_SIZE / 8 ||\n\t    alg->walksize > PAGE_SIZE / 8)\n\t\treturn -EINVAL;\n\n\tif (!alg->chunksize)\n\t\talg->chunksize = base->cra_blocksize;\n\tif (!alg->walksize)\n\t\talg->walksize = alg->chunksize;\n\n\tbase->cra_type = &crypto_skcipher_type2;\n\tbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\n\tbase->cra_flags |= CRYPTO_ALG_TYPE_SKCIPHER;\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar            *norm_path_old;\n\tchar            *norm_path_new;\n\tchar            *resolve_path;\n\tM_fs_info_t     *info;\n\tM_fs_progress_t *progress      = NULL;\n\tM_uint64         entry_size;\n\tM_fs_error_t     res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be moved \n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_move(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n \t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n \t\treturn res;\n \t}\n \n \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tif (cb) {\n\t\tentry_size = M_fs_info_get_size(info);\n\n\t\tM_fs_progress_set_path(progress, norm_path_new);\n\t\tM_fs_progress_set_type(progress, M_fs_info_get_type(info));\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, entry_size);\n\t\t\tM_fs_progress_set_size_total_progess(progress, entry_size);\n\t\t}\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, 1);\n\t\t\tM_fs_progress_set_count(progress, 1);\n\t\t}\n\t}\n\n\t/* Move the file. */\n\tif (M_fs_info_get_type(info) == M_FS_TYPE_SYMLINK) {\n\t\tres = M_fs_path_readlink(&resolve_path, norm_path_old);\n\t\tif (res == M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_fs_symlink(norm_path_new, resolve_path);\n\t\t}\n\t\tM_free(resolve_path);\n\t} else {\n\t\tres = M_fs_move_file(norm_path_old, norm_path_new);\n\t}\n\t/* Failure was because we're crossing mount points. */\n\tif (res == M_FS_ERROR_NOT_SAMEDEV) {\n\t\t/* Can't rename so copy and delete. */\n\t\tif (M_fs_copy(norm_path_old, norm_path_new, mode, cb, progress_flags) == M_FS_ERROR_SUCCESS) {\n\t\t\t/* Success - Delete the original files since this is a move. */\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t}\n\n\tM_fs_info_destroy(info);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-732"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "DelegatedFrameHost::DelegatedFrameHost(const viz::FrameSinkId& frame_sink_id,\n                                       DelegatedFrameHostClient* client)\n    : frame_sink_id_(frame_sink_id),\n      client_(client),\n      compositor_(nullptr),\n      tick_clock_(new base::DefaultTickClock()),\n      skipped_frames_(false),\n      background_color_(SK_ColorRED),\n      current_scale_factor_(1.f),\n      frame_evictor_(new viz::FrameEvictor(this)) {\n  ImageTransportFactory* factory = ImageTransportFactory::GetInstance();\n  factory->GetContextFactory()->AddObserver(this);\n  viz::HostFrameSinkManager* host_frame_sink_manager =\n      factory->GetContextFactoryPrivate()->GetHostFrameSinkManager();\n  host_frame_sink_manager->RegisterFrameSinkId(frame_sink_id_, this);\n  CreateCompositorFrameSinkSupport();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool check_solid_tile(VncState *vs, int x, int y, int w, int h,\n                              uint32_t* color, bool samecolor)\n {\n    VncDisplay *vd = vs->vd;\n    switch(vd->server->pf.bytes_per_pixel) {\n     case 4:\n         return check_solid_tile32(vs, x, y, w, h, color, samecolor);\n     case 2:\n    switch(vd->server->pf.bytes_per_pixel) {\n    case 4:\n        return check_solid_tile32(vs, x, y, w, h, color, samecolor);\n    case 2:\n        return check_solid_tile16(vs, x, y, w, h, color, samecolor);\n    default:\n        return check_solid_tile8(vs, x, y, w, h, color, samecolor);\n    }\n}\n\nstatic void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n{\n    int dx, dy, dw, dh;\n    int w_prev;\n    int w_best = 0, h_best = 0;\n\n    w_prev = w;\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n            break;\n        }\n\n        for (dx = x + dw; dx < x + w_prev;) {\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n                break;\n            }\n            dx += dw;\n        }\n\n        w_prev = dx - x;\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n            w_best = w_prev;\n            h_best = dy + dh - y;\n        }\n    }\n\n    *w_ptr = w_best;\n    *h_ptr = h_best;\n}\n\nstatic void extend_solid_area(VncState *vs, int x, int y, int w, int h,\n                              uint32_t color, int *x_ptr, int *y_ptr,\n                              int *w_ptr, int *h_ptr)\n{\n    int cx, cy;\n\n    /* Try to extend the area upwards. */\n    for ( cy = *y_ptr - 1;\n          cy >= y && check_solid_tile(vs, *x_ptr, cy, *w_ptr, 1, &color, true);\n          cy-- );\n    *h_ptr += *y_ptr - (cy + 1);\n    *y_ptr = cy + 1;\n\n    /* ... downwards. */\n    for ( cy = *y_ptr + *h_ptr;\n          cy < y + h &&\n              check_solid_tile(vs, *x_ptr, cy, *w_ptr, 1, &color, true);\n          cy++ );\n    *h_ptr += cy - (*y_ptr + *h_ptr);\n\n    /* ... to the left. */\n    for ( cx = *x_ptr - 1;\n          cx >= x && check_solid_tile(vs, cx, *y_ptr, 1, *h_ptr, &color, true);\n          cx-- );\n    *w_ptr += *x_ptr - (cx + 1);\n    *x_ptr = cx + 1;\n\n    /* ... to the right. */\n    for ( cx = *x_ptr + *w_ptr;\n          cx < x + w &&\n              check_solid_tile(vs, cx, *y_ptr, 1, *h_ptr, &color, true);\n          cx++ );\n    *w_ptr += cx - (*x_ptr + *w_ptr);\n}\n\nstatic int tight_init_stream(VncState *vs, int stream_id,\n                             int level, int strategy)\n{\n    z_streamp zstream = &vs->tight.stream[stream_id];\n\n    if (zstream->opaque == NULL) {\n        int err;\n\n        VNC_DEBUG(\"VNC: TIGHT: initializing zlib stream %d\\n\", stream_id);\n        VNC_DEBUG(\"VNC: TIGHT: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n        zstream->zalloc = vnc_zlib_zalloc;\n        zstream->zfree = vnc_zlib_zfree;\n\n        err = deflateInit2(zstream, level, Z_DEFLATED, MAX_WBITS,\n                           MAX_MEM_LEVEL, strategy);\n\n        if (err != Z_OK) {\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n            return -1;\n        }\n\n        vs->tight.levels[stream_id] = level;\n        zstream->opaque = vs;\n    }\n\n    if (vs->tight.levels[stream_id] != level) {\n        if (deflateParams(zstream, level, strategy) != Z_OK) {\n            return -1;\n        }\n        vs->tight.levels[stream_id] = level;\n    }\n    return 0;\n}\n\nstatic void tight_send_compact_size(VncState *vs, size_t len)\n{\n    int lpc = 0;\n    int bytes = 0;\n    char buf[3] = {0, 0, 0};\n\n    buf[bytes++] = len & 0x7F;\n    if (len > 0x7F) {\n        buf[bytes-1] |= 0x80;\n        buf[bytes++] = (len >> 7) & 0x7F;\n        if (len > 0x3FFF) {\n            buf[bytes-1] |= 0x80;\n            buf[bytes++] = (len >> 14) & 0xFF;\n        }\n    }\n    for (lpc = 0; lpc < bytes; lpc++) {\n        vnc_write_u8(vs, buf[lpc]);\n    }\n}\n\nstatic int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight.stream[stream_id];\n    int previous_out;\n\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight.tight.buffer, vs->tight.tight.offset);\n        return bytes;\n    }\n\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n\n    /* reserve memory in output buffer */\n    buffer_reserve(&vs->tight.zlib, bytes + 64);\n\n    /* set pointers */\n    zstream->next_in = vs->tight.tight.buffer;\n    zstream->avail_in = vs->tight.tight.offset;\n    zstream->next_out = vs->tight.zlib.buffer + vs->tight.zlib.offset;\n    zstream->avail_out = vs->tight.zlib.capacity - vs->tight.zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n\n    /* start encoding */\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n\n    vs->tight.zlib.offset = vs->tight.zlib.capacity - zstream->avail_out;\n    /* ...how much data has actually been produced by deflate() */\n    bytes = previous_out - zstream->avail_out;\n\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight.zlib.buffer, bytes);\n\n    buffer_reset(&vs->tight.zlib);\n\n    return bytes;\n}\n\n/*\n * Subencoding implementations.\n */\nstatic void tight_pack24(VncState *vs, uint8_t *buf, size_t count, size_t *ret)\n \n     buf32 = (uint32_t *)buf;\n \n    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n        rshift = vs->clientds.pf.rshift;\n        gshift = vs->clientds.pf.gshift;\n        bshift = vs->clientds.pf.bshift;\n     } else {\n        rshift = 24 - vs->clientds.pf.rshift;\n        gshift = 24 - vs->clientds.pf.gshift;\n        bshift = 24 - vs->clientds.pf.bshift;\n     }\n \n     if (ret) {\n        bshift = 24 - vs->clientds.pf.bshift;\n    }\n\n    if (ret) {\n        *ret = count * 3;\n    }\n\n    while (count--) {\n        pix = *buf32++;\n        *buf++ = (char)(pix >> rshift);\n        *buf++ = (char)(pix >> gshift);\n        *buf++ = (char)(pix >> bshift);\n    }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void dictionaryMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::dictionaryMethodMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "StreamingProcessor::~StreamingProcessor() {\n    deletePreviewStream();\n    deleteRecordingStream();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool IsAcceptableCSSStyleSheetParent(const Node& parent_node) {\n  return parent_node.IsDocumentNode() || IsHTMLLinkElement(parent_node) ||\n         IsHTMLStyleElement(parent_node) || IsSVGStyleElement(parent_node) ||\n         parent_node.getNodeType() == Node::kProcessingInstructionNode;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MenuCacheDir* menu_cache_item_dup_parent( MenuCacheItem* item )\n{\n    MenuCacheDir* dir;\n    MENU_CACHE_LOCK;\n    dir = item->parent;\n    if(G_LIKELY(dir))\n        menu_cache_item_ref(MENU_CACHE_ITEM(dir));\n    MENU_CACHE_UNLOCK;\n    return dir;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "icmp6_opt_print(netdissect_options *ndo, const u_char *bp, int resid)\n{\n\tconst struct nd_opt_hdr *op;\n\tconst struct nd_opt_prefix_info *opp;\n\tconst struct nd_opt_mtu *opm;\n\tconst struct nd_opt_rdnss *oprd;\n\tconst struct nd_opt_dnssl *opds;\n\tconst struct nd_opt_advinterval *opa;\n\tconst struct nd_opt_homeagent_info *oph;\n\tconst struct nd_opt_route_info *opri;\n\tconst u_char *cp, *ep, *domp;\n\tstruct in6_addr in6;\n\tconst struct in6_addr *in6p;\n\tsize_t l;\n\tu_int i;\n\n#define ECHECK(var) if ((const u_char *)&(var) > ep - sizeof(var)) return\n\n\tcp = bp;\n\t/* 'ep' points to the end of available data. */\n\tep = ndo->ndo_snapend;\n\n\twhile (cp < ep) {\n\t\top = (const struct nd_opt_hdr *)cp;\n\n\t\tECHECK(op->nd_opt_len);\n\t\tif (resid <= 0)\n\t\t\treturn;\n\t\tif (op->nd_opt_len == 0)\n\t\t\tgoto trunc;\n\t\tif (cp + (op->nd_opt_len << 3) > ep)\n\t\t\tgoto trunc;\n\n                ND_PRINT((ndo,\"\\n\\t  %s option (%u), length %u (%u): \",\n                          tok2str(icmp6_opt_values, \"unknown\", op->nd_opt_type),\n                          op->nd_opt_type,\n                          op->nd_opt_len << 3,\n                          op->nd_opt_len));\n\n\t\tswitch (op->nd_opt_type) {\n\t\tcase ND_OPT_SOURCE_LINKADDR:\n\t\t\tl = (op->nd_opt_len << 3) - 2;\n\t\t\tprint_lladdr(ndo, cp + 2, l);\n\t\t\tbreak;\n\t\tcase ND_OPT_TARGET_LINKADDR:\n\t\t\tl = (op->nd_opt_len << 3) - 2;\n\t\t\tprint_lladdr(ndo, cp + 2, l);\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\topp = (const struct nd_opt_prefix_info *)op;\n\t\t\tND_TCHECK(opp->nd_opt_pi_prefix);\n                        ND_PRINT((ndo,\"%s/%u%s, Flags [%s], valid time %s\",\n                                  ip6addr_string(ndo, &opp->nd_opt_pi_prefix),\n                                  opp->nd_opt_pi_prefix_len,\n                                  (op->nd_opt_len != 4) ? \"badlen\" : \"\",\n                                  bittok2str(icmp6_opt_pi_flag_values, \"none\", opp->nd_opt_pi_flags_reserved),\n                                  get_lifetime(EXTRACT_32BITS(&opp->nd_opt_pi_valid_time))));\n                        ND_PRINT((ndo,\", pref. time %s\", get_lifetime(EXTRACT_32BITS(&opp->nd_opt_pi_preferred_time))));\n\t\t\tbreak;\n\t\tcase ND_OPT_REDIRECTED_HEADER:\n                        print_unknown_data(ndo, bp,\"\\n\\t    \",op->nd_opt_len<<3);\n\t\t\t/* xxx */\n\t\t\tbreak;\n\t\tcase ND_OPT_MTU:\n\t\t\topm = (const struct nd_opt_mtu *)op;\n\t\t\tND_TCHECK(opm->nd_opt_mtu_mtu);\n\t\t\tND_PRINT((ndo,\" %u%s\",\n                               EXTRACT_32BITS(&opm->nd_opt_mtu_mtu),\n                                  (op->nd_opt_len != 1) ? \"bad option length\" : \"\" ));\n                        break;\n\t\tcase ND_OPT_RDNSS:\n\t\t\toprd = (const struct nd_opt_rdnss *)op;\n\t\t\tl = (op->nd_opt_len - 1) / 2;\n\t\t\tND_PRINT((ndo,\" lifetime %us,\",\n                                  EXTRACT_32BITS(&oprd->nd_opt_rdnss_lifetime)));\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tND_TCHECK(oprd->nd_opt_rdnss_addr[i]);\n\t\t\t\tND_PRINT((ndo,\" addr: %s\",\n                                          ip6addr_string(ndo, &oprd->nd_opt_rdnss_addr[i])));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_DNSSL:\n\t\t\topds = (const struct nd_opt_dnssl *)op;\n\t\t\tND_PRINT((ndo,\" lifetime %us, domain(s):\",\n                                  EXTRACT_32BITS(&opds->nd_opt_dnssl_lifetime)));\n\t\t\tdomp = cp + 8; /* domain names, variable-sized, RFC1035-encoded */\n\t\t\twhile (domp < cp + (op->nd_opt_len << 3) && *domp != '\\0')\n\t\t\t{\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\tif ((domp = ns_nprint (ndo, domp, bp)) == NULL)\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_ADVINTERVAL:\n\t\t\topa = (const struct nd_opt_advinterval *)op;\n\t\t\tND_TCHECK(opa->nd_opt_adv_interval);\n\t\t\tND_PRINT((ndo,\" %ums\", EXTRACT_32BITS(&opa->nd_opt_adv_interval)));\n\t\t\tbreak;\n                case ND_OPT_HOMEAGENT_INFO:\n\t\t\toph = (const struct nd_opt_homeagent_info *)op;\n\t\t\tND_TCHECK(oph->nd_opt_hai_lifetime);\n\t\t\tND_PRINT((ndo,\" preference %u, lifetime %u\",\n                                  EXTRACT_16BITS(&oph->nd_opt_hai_preference),\n                                  EXTRACT_16BITS(&oph->nd_opt_hai_lifetime)));\n\t\t\tbreak;\n\t\tcase ND_OPT_ROUTE_INFO:\n\t\t\topri = (const struct nd_opt_route_info *)op;\n\t\t\tND_TCHECK(opri->nd_opt_rti_lifetime);\n\t\t\tmemset(&in6, 0, sizeof(in6));\n\t\t\tin6p = (const struct in6_addr *)(opri + 1);\n\t\t\tswitch (op->nd_opt_len) {\n\t\t\tcase 1:\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_TCHECK2(*in6p, 8);\n\t\t\t\tmemcpy(&in6, opri + 1, 8);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tND_TCHECK(*in6p);\n\t\t\t\tmemcpy(&in6, opri + 1, sizeof(in6));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo,\" %s/%u\", ip6addr_string(ndo, &in6),\n                                  opri->nd_opt_rti_prefixlen));\n\t\t\tND_PRINT((ndo,\", pref=%s\", get_rtpref(opri->nd_opt_rti_flags)));\n\t\t\tND_PRINT((ndo,\", lifetime=%s\",\n                                  get_lifetime(EXTRACT_32BITS(&opri->nd_opt_rti_lifetime))));\n\t\t\tbreak;\n\t\tdefault:\n                        if (ndo->ndo_vflag <= 1) {\n                                print_unknown_data(ndo,cp+2,\"\\n\\t  \", (op->nd_opt_len << 3) - 2); /* skip option header */\n                            return;\n                        }\n                        break;\n\t\t}\n                /* do we want to see an additional hexdump ? */\n                if (ndo->ndo_vflag> 1)\n                        print_unknown_data(ndo, cp+2,\"\\n\\t    \", (op->nd_opt_len << 3) - 2); /* skip option header */\n\n\t\tcp += op->nd_opt_len << 3;\n\t\tresid -= op->nd_opt_len << 3;\n \t}\n \treturn;\n \n trunc:\n\tND_PRINT((ndo, \"[ndp opt]\"));\n \treturn;\n #undef ECHECK\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "get_tracer_for_array(struct trace_array *tr, struct tracer *t)\n{\n\twhile (t && !trace_ok_for_array(t, tr))\n\t\tt = t->next;\n\n\treturn t;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MagickExport MagickBooleanType SetImageMask(Image *image,const PixelMask type,\n  const Image *mask,ExceptionInfo *exception)\n{\n  CacheView\n    *mask_view,\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  /*\n    Set image mask.\n  */\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (mask == (const Image *) NULL)\n    {\n      switch (type)\n      {\n        case WritePixelMask: image->write_mask=MagickFalse; break;\n        default: image->read_mask=MagickFalse; break;\n      }\n      return(SyncImagePixelCache(image,exception));\n    }\n  switch (type)\n  {\n    case WritePixelMask: image->write_mask=MagickTrue; break;\n    default: image->read_mask=MagickTrue; break;\n  }\n  if (SyncImagePixelCache(image,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  mask_view=AcquireVirtualCacheView(mask,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(mask,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(mask_view,0,y,mask->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        intensity;\n\n      intensity=GetPixelIntensity(mask,p);\n      switch (type)\n      {\n        case WritePixelMask:\n        {\n          SetPixelWriteMask(image,ClampToQuantum(QuantumRange-intensity),q);\n          break;\n        }\n        default:\n        {\n          SetPixelReadMask(image,ClampToQuantum(QuantumRange-intensity),q);\n          break;\n        }\n      }\n      p+=GetPixelChannels(mask);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  mask_view=DestroyCacheView(mask_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "processInternalEntity(XML_Parser parser, ENTITY *entity,\n                      XML_Bool betweenDecl)\n{\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  }\n  else {\n    openEntity = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (!openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd, tok,\n                      next, &next, XML_FALSE);\n  }\n  else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding, textStart,\n                       textEnd, &next, XML_FALSE);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    }\n    else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-611"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "RendererSchedulerImpl::GetSchedulerHelperForTesting() {\n  return &helper_;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "super_1_rdev_size_change(struct md_rdev *rdev, sector_t num_sectors)\n{\n\tstruct mdp_superblock_1 *sb;\n\tsector_t max_sectors;\n\tif (num_sectors && num_sectors < rdev->mddev->dev_sectors)\n\t\treturn 0; /* component must fit device */\n\tif (rdev->data_offset != rdev->new_data_offset)\n\t\treturn 0; /* too confusing */\n\tif (rdev->sb_start < rdev->data_offset) {\n\t\t/* minor versions 1 and 2; superblock before data */\n\t\tmax_sectors = i_size_read(rdev->bdev->bd_inode) >> 9;\n\t\tmax_sectors -= rdev->data_offset;\n\t\tif (!num_sectors || num_sectors > max_sectors)\n\t\t\tnum_sectors = max_sectors;\n\t} else if (rdev->mddev->bitmap_info.offset) {\n\t\t/* minor version 0 with bitmap we can't move */\n\t\treturn 0;\n\t} else {\n\t\t/* minor version 0; superblock after data */\n\t\tsector_t sb_start;\n\t\tsb_start = (i_size_read(rdev->bdev->bd_inode) >> 9) - 8*2;\n\t\tsb_start &= ~(sector_t)(4*2 - 1);\n\t\tmax_sectors = rdev->sectors + sb_start - rdev->sb_start;\n\t\tif (!num_sectors || num_sectors > max_sectors)\n\t\t\tnum_sectors = max_sectors;\n\t\trdev->sb_start = sb_start;\n\t}\n\tsb = page_address(rdev->sb_page);\n\tsb->data_size = cpu_to_le64(num_sectors);\n\tsb->super_offset = rdev->sb_start;\n\tsb->sb_csum = calc_sb_1_csum(sb);\n\tmd_super_write(rdev->mddev, rdev, rdev->sb_start, rdev->sb_size,\n\t\t       rdev->sb_page);\n\tmd_super_wait(rdev->mddev);\n\treturn num_sectors;\n\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void OnRegistryKeyChanged() {\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n    if (--registry_watcher_count_ == 0) {\n      UMA_HISTOGRAM_MEDIUM_TIMES(\n          \"DefaultBrowser.SettingsInteraction.RegistryWatcherDuration\",\n          base::TimeTicks::Now() - start_time_);\n\n      ConcludeInteraction(ConcludeReason::REGISTRY_WATCHER);\n    }\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int create_discard_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct discard_cmd_control *dcc;\n\tint err = 0, i;\n\n\tif (SM_I(sbi)->dcc_info) {\n\t\tdcc = SM_I(sbi)->dcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tdcc = kzalloc(sizeof(struct discard_cmd_control), GFP_KERNEL);\n\tif (!dcc)\n\t\treturn -ENOMEM;\n\n\tdcc->discard_granularity = DEFAULT_DISCARD_GRANULARITY;\n\tINIT_LIST_HEAD(&dcc->entry_list);\n\tfor (i = 0; i < MAX_PLIST_NUM; i++) {\n\t\tINIT_LIST_HEAD(&dcc->pend_list[i]);\n\t\tif (i >= dcc->discard_granularity - 1)\n\t\t\tdcc->pend_list_tag[i] |= P_ACTIVE;\n\t}\n\tINIT_LIST_HEAD(&dcc->wait_list);\n\tmutex_init(&dcc->cmd_lock);\n\tatomic_set(&dcc->issued_discard, 0);\n\tatomic_set(&dcc->issing_discard, 0);\n\tatomic_set(&dcc->discard_cmd_cnt, 0);\n\tdcc->nr_discards = 0;\n\tdcc->max_discards = MAIN_SEGS(sbi) << sbi->log_blocks_per_seg;\n\tdcc->undiscard_blks = 0;\n\tdcc->root = RB_ROOT;\n\n\tinit_waitqueue_head(&dcc->discard_wait_queue);\n\tSM_I(sbi)->dcc_info = dcc;\ninit_thread:\n\tdcc->f2fs_issue_discard = kthread_run(issue_discard_thread, sbi,\n\t\t\t\t\"f2fs_discard-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(dcc->f2fs_issue_discard)) {\n\t\terr = PTR_ERR(dcc->f2fs_issue_discard);\n\t\tkfree(dcc);\n\t\tSM_I(sbi)->dcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "nfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (d_really_is_negative(rdentry)) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = d_inode(rdentry)->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-404"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n {\n\tint i;\n\tint ret;\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n \t}\n \n \treturn ret;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Resource::LastPluginRefWasDeleted(bool instance_destroyed) {\n   DCHECK(resource_id_ != 0);\n   instance()->module()->GetCallbackTracker()->PostAbortForResource(\n       resource_id_);\n   resource_id_ = 0;\n  if (instance_destroyed)\n    instance_ = NULL;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int sctp_process_inv_mandatory(const struct sctp_association *asoc,\n\t\t\t\t      struct sctp_chunk *chunk,\n\t\t\t\t      struct sctp_chunk **errp)\n{\n\t/* Invalid Mandatory Parameter Error has no payload. */\n\n\tif (!*errp)\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, 0);\n\n\tif (*errp)\n\t\tsctp_init_cause(*errp, SCTP_ERROR_INV_PARAM, 0);\n\n\t/* Stop processing this chunk. */\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void UnloadController::TabReplacedAt(TabStripModel* tab_strip_model,\n                                      TabContents* old_contents,\n                                      TabContents* new_contents,\n                                      int index) {\n  TabDetachedImpl(old_contents);\n   TabAttachedImpl(new_contents->web_contents());\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n \tunsigned int value_pos;\n \tunsigned int numer, denom;\n \n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n \n \tif(value_count!=1) return 0;\n \n\tif(field_type!=5) return 0; // 5=Rational (two uint32's)\n\n \n\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n \tif(value_pos > e->d_len-8) return 0;\n \n\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n \tif(denom==0) return 0;\n \n \t*pv = ((double)numer)/denom;\n\treturn 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n \tT2_FNEXT_RSP_PARMS *parms;\n \tchar *response_data;\n \tint rc = 0;\n\tint bytes_returned, name_len;\n \t__u16 params, byte_count;\n \n \tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelPacket\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MaxTextExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False when converting or mogrifying */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MaxTextExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n              MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            /* Skip nominal layer count, frame count, and play time */\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MaxTextExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 8)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length > 1)\n              {\n                object_id=(p[0] << 8) | p[1];\n\n                if (mng_type == 2 && object_id != 0)\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),\n                     CoderError,\"Nonzero object_id in MNG-LC datastream\",\n                     \"`%s'\", image->filename);\n\n                if (object_id > MNG_MAX_OBJECTS)\n                  {\n                    /*\n                      Instead of using a warning we should allocate a larger\n                      MngInfo structure and continue.\n                    */\n                    (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(), CoderError,\n                        \"object id too large\",\"`%s'\",image->filename);\n                        object_id=MNG_MAX_OBJECTS;\n                  }\n\n                if (mng_info->exists[object_id])\n                  if (mng_info->frozen[object_id])\n                    {\n                      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                      (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(),CoderError,\n                        \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                        image->filename);\n                      continue;\n                    }\n\n                mng_info->exists[object_id]=MagickTrue;\n\n                if (length > 2)\n                  mng_info->invisible[object_id]=p[2];\n\n                /*\n                  Extract object offset info.\n                */\n                if (length > 11)\n                  {\n                    mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                        (p[5] << 16) | (p[6] << 8) | p[7]);\n\n                    mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                        (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                          object_id,(double) mng_info->x_off[object_id],\n                          object_id,(double) mng_info->y_off[object_id]);\n                      }\n                  }\n\n                /*\n                  Extract object clipping info.\n                */\n            \n                if (length > 27)\n                  mng_info->object_clip[object_id]=\n                    mng_read_box(mng_info->frame,0, &p[12]);\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.opacity=OpaqueOpacity;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length > 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && (p-chunk) < (ssize_t) (length-4))\n                      {\n                          frame_delay=1UL*image->ticks_per_second*\n                            mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && (p-chunk) < (ssize_t) (length-4))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && (p-chunk) < (ssize_t) (length-17))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->matte=MagickFalse;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,(double) mng_info->clip.right,\n                    (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n \n               for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n               {\n                 if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                     (p-chunk) < (ssize_t) (length-8))\n                   {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters \",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=SeekBlob(image,\n                              mng_info->loop_jump[loop_level], SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            if (length > 11)\n              {\n                basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                   (p[2] << 8) | p[3]);\n                basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                   (p[6] << 8) | p[7]);\n                basi_color_type=p[8];\n                basi_compression_method=p[9];\n                basi_filter_type=p[10];\n                basi_interlace_method=p[11];\n              }\n            if (length > 13)\n              basi_red=(p[12] << 8) & p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 15)\n              basi_green=(p[14] << 8) & p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 17)\n              basi_blue=(p[16] << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 19)\n              basi_alpha=(p[18] << 8) & p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 20)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->matte=MagickFalse;\n            (void) SetImageBackgroundColor(image);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register ssize_t\n                  x;\n\n                register PixelPacket\n                  *n,\n                  *q;\n\n                PixelPacket\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(q,ScaleQuantumToShort(\n                            GetPixelRed(q)));\n                          SetPixelGreen(q,ScaleQuantumToShort(\n                            GetPixelGreen(q)));\n                          SetPixelBlue(q,ScaleQuantumToShort(\n                            GetPixelBlue(q)));\n                          SetPixelOpacity(q,ScaleQuantumToShort(\n                            GetPixelOpacity(q)));\n                          q++;\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->matte != MagickFalse)\n                   (void) SetImageBackgroundColor(large_image);\n\n                else\n                  {\n                    large_image->background_color.opacity=OpaqueOpacity;\n                    (void) SetImageBackgroundColor(large_image);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",(double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) image->columns;\n                next=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (PixelPacket *) NULL) ||\n                    (next == (PixelPacket *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register PixelPacket\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRGBO(q,(pixels));\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(n)\n                                 -GetPixelRed(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(pixels)))));\n                              SetPixelGreen(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(n)\n                                 -GetPixelGreen(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(pixels)))));\n                              SetPixelBlue(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(n)\n                                 -GetPixelBlue(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(pixels)))));\n\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                    ((QM) (((ssize_t)\n                                    (2*i*(GetPixelOpacity(n)\n                                    -GetPixelOpacity(pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)))));\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelOpacity(q,\n                                 (*pixels).opacity+0);\n                              else\n                                 SetPixelOpacity(q,\n                                 (*n).opacity+0);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelOpacity(q,\n                                 (QM) (((ssize_t) (2*i*\n                                 (GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      n++;\n                      q++;\n                      pixels++;\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(PixelPacket *) RelinquishMagickMemory(prev);\n                next=(PixelPacket *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",(double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register PixelPacket\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length);\n                  n=pixels+1;\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelComponent() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 && x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelComponent() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 (QM) ((2*i*(\n                                 GetPixelRed(n)\n                                 -GetPixelRed(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(pixels)));\n\n                              SetPixelGreen(q,\n                                 (QM) ((2*i*(\n                                 GetPixelGreen(n)\n                                 -GetPixelGreen(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(pixels)));\n\n                              SetPixelBlue(q,\n                                 (QM) ((2*i*(\n                                 GetPixelBlue(n)\n                                 -GetPixelBlue(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(pixels)));\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                   (QM) ((2*i*(\n                                   GetPixelOpacity(n)\n                                   -GetPixelOpacity(pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)));\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(pixels)+0);\n                              }\n                              else\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(n)+0);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelOpacity(q,\n                                 (QM) ((2*i*( GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      q++;\n                    }\n                    n++;\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(q,ScaleShortToQuantum(\n                            GetPixelRed(q)));\n                        SetPixelGreen(q,ScaleShortToQuantum(\n                            GetPixelGreen(q)));\n                        SetPixelBlue(q,ScaleShortToQuantum(\n                            GetPixelBlue(q)));\n                        SetPixelOpacity(q,ScaleShortToQuantum(\n                            GetPixelOpacity(q)));\n                        q++;\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy, and promote any depths > 8 to 16.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      GetImageException(image,exception);\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->matte=MagickFalse;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,(double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,&image->exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage();\");\n\n  return(image);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int __init sit_init(void)\n{\n\tint err;\n \n \tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n \n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n \terr = register_pernet_device(&sit_net_ops);\n \tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n \treturn err;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void PasswordAutofillManager::OnShowPasswordSuggestions(\n    int key,\n    base::i18n::TextDirection text_direction,\n    const base::string16& typed_username,\n    int options,\n    const gfx::RectF& bounds) {\n  std::vector<autofill::Suggestion> suggestions;\n  LoginToPasswordInfoMap::const_iterator fill_data_it =\n      login_to_password_info_.find(key);\n  if (fill_data_it == login_to_password_info_.end()) {\n    NOTREACHED();\n    return;\n  }\n  GetSuggestions(fill_data_it->second, typed_username, &suggestions,\n                 (options & autofill::SHOW_ALL) != 0,\n                 (options & autofill::IS_PASSWORD_FIELD) != 0);\n\n  form_data_key_ = key;\n\n  if (suggestions.empty()) {\n    autofill_client_->HideAutofillPopup();\n    return;\n  }\n\n  if (options & autofill::IS_PASSWORD_FIELD) {\n    autofill::Suggestion password_field_suggestions(l10n_util::GetStringUTF16(\n        IDS_AUTOFILL_PASSWORD_FIELD_SUGGESTIONS_TITLE));\n    password_field_suggestions.frontend_id = autofill::POPUP_ITEM_ID_TITLE;\n    suggestions.insert(suggestions.begin(), password_field_suggestions);\n  }\n\n  GURL origin = (fill_data_it->second).origin;\n  bool is_context_secure = autofill_client_->IsContextSecure() &&\n                           (!origin.is_valid() || !origin.SchemeIs(\"http\"));\n  if (!is_context_secure && security_state::IsHttpWarningInFormEnabled()) {\n    std::string icon_str;\n\n    if (origin.is_valid() && origin.SchemeIs(\"http\")) {\n      icon_str = \"httpWarning\";\n    } else {\n      icon_str = \"httpsInvalid\";\n    }\n\n    autofill::Suggestion http_warning_suggestion(\n        l10n_util::GetStringUTF8(IDS_AUTOFILL_LOGIN_HTTP_WARNING_MESSAGE),\n        l10n_util::GetStringUTF8(IDS_AUTOFILL_HTTP_WARNING_LEARN_MORE),\n        icon_str, autofill::POPUP_ITEM_ID_HTTP_NOT_SECURE_WARNING_MESSAGE);\n#if !defined(OS_ANDROID)\n      suggestions.insert(suggestions.begin(), autofill::Suggestion());\n      suggestions.front().frontend_id = autofill::POPUP_ITEM_ID_SEPARATOR;\n#endif\n      suggestions.insert(suggestions.begin(), http_warning_suggestion);\n\n      if (!did_show_form_not_secure_warning_) {\n        did_show_form_not_secure_warning_ = true;\n        metrics_util::LogShowedFormNotSecureWarningOnCurrentNavigation();\n      }\n  }\n\n   if (ShouldShowManualFallbackForPreLollipop(\n           autofill_client_->GetSyncService())) {\n     if (base::FeatureList::IsEnabled(\n            password_manager::features::kEnableManualFallbacksFilling) &&\n         (options & autofill::IS_PASSWORD_FIELD) && password_client_ &&\n         password_client_->IsFillingFallbackEnabledForCurrentPage()) {\n       AddSimpleSuggestionWithSeparatorOnTop(\n          IDS_AUTOFILL_SHOW_ALL_SAVED_FALLBACK,\n          autofill::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY, &suggestions);\n\n      show_all_saved_passwords_shown_context_ =\n          metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_PASSWORD;\n      metrics_util::LogContextOfShowAllSavedPasswordsShown(\n          show_all_saved_passwords_shown_context_);\n    }\n    if (base::FeatureList::IsEnabled(\n            password_manager::features::kEnableManualFallbacksGeneration) &&\n        password_manager_util::GetPasswordSyncState(\n            autofill_client_->GetSyncService()) == SYNCING_NORMAL_ENCRYPTION) {\n      AddSimpleSuggestionWithSeparatorOnTop(\n          IDS_AUTOFILL_GENERATE_PASSWORD_FALLBACK,\n          autofill::POPUP_ITEM_ID_GENERATE_PASSWORD_ENTRY, &suggestions);\n    }\n  }\n\n  autofill_client_->ShowAutofillPopup(bounds,\n                                      text_direction,\n                                      suggestions,\n                                      weak_ptr_factory_.GetWeakPtr());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "BrowserContext* DownloadItemImpl::GetBrowserContext() const {\n  return delegate_->GetBrowserContext();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "VaapiVideoDecodeAccelerator::VaapiH264Accelerator::CreateH264Picture() {\n   scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();\n   if (!va_surface)\n     return nullptr;\n\n  return new VaapiH264Picture(std::move(va_surface));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OMX_ERRORTYPE omx_vdec::update_portdef(OMX_PARAM_PORTDEFINITIONTYPE *portDefn)\n{\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n struct v4l2_format fmt;\n if (!portDefn) {\n return OMX_ErrorBadParameter;\n\n     }\n     DEBUG_PRINT_LOW(\"omx_vdec::update_portdef\");\n     portDefn->nVersion.nVersion = OMX_SPEC_VERSION;\n    portDefn->nSize = sizeof(portDefn);\n     portDefn->eDomain    = OMX_PortDomainVideo;\n     if (drv_ctx.frame_rate.fps_denominator > 0)\n         portDefn->format.video.xFramerate = (drv_ctx.frame_rate.fps_numerator /\n            drv_ctx.frame_rate.fps_denominator) << 16; //Q16 format\n else {\n        DEBUG_PRINT_ERROR(\"Error: Divide by zero\");\n return OMX_ErrorBadParameter;\n }\n    memset(&fmt, 0x0, sizeof(struct v4l2_format));\n if (0 == portDefn->nPortIndex) {\n        portDefn->eDir =  OMX_DirInput;\n        portDefn->nBufferCountActual = drv_ctx.ip_buf.actualcount;\n        portDefn->nBufferCountMin    = drv_ctx.ip_buf.mincount;\n        portDefn->nBufferSize        = drv_ctx.ip_buf.buffer_size;\n        portDefn->format.video.eColorFormat = OMX_COLOR_FormatUnused;\n        portDefn->format.video.eCompressionFormat = eCompressionFormat;\n        portDefn->bEnabled   = m_inp_bEnabled;\n        portDefn->bPopulated = m_inp_bPopulated;\n\n        fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n        fmt.fmt.pix_mp.pixelformat = output_capability;\n } else if (1 == portDefn->nPortIndex) {\n unsigned int buf_size = 0;\n if (!client_buffers.update_buffer_req()) {\n            DEBUG_PRINT_ERROR(\"client_buffers.update_buffer_req Failed\");\n return OMX_ErrorHardware;\n }\n if (!client_buffers.get_buffer_req(buf_size)) {\n            DEBUG_PRINT_ERROR(\"update buffer requirements\");\n return OMX_ErrorHardware;\n }\n        portDefn->nBufferSize = buf_size;\n        portDefn->eDir =  OMX_DirOutput;\n        portDefn->nBufferCountActual = drv_ctx.op_buf.actualcount;\n        portDefn->nBufferCountMin    = drv_ctx.op_buf.mincount;\n        portDefn->format.video.eCompressionFormat = OMX_VIDEO_CodingUnused;\n        portDefn->bEnabled   = m_out_bEnabled;\n        portDefn->bPopulated = m_out_bPopulated;\n if (!client_buffers.get_color_format(portDefn->format.video.eColorFormat)) {\n            DEBUG_PRINT_ERROR(\"Error in getting color format\");\n return OMX_ErrorHardware;\n }\n        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n        fmt.fmt.pix_mp.pixelformat = capture_capability;\n } else {\n        portDefn->eDir = OMX_DirMax;\n        DEBUG_PRINT_LOW(\" get_parameter: Bad Port idx %d\",\n (int)portDefn->nPortIndex);\n        eRet = OMX_ErrorBadPortIndex;\n }\n if (is_down_scalar_enabled) {\n int ret = 0;\n        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_G_FMT, &fmt);\n if (ret) {\n            DEBUG_PRINT_ERROR(\"update_portdef : Error in getting port resolution\");\n return OMX_ErrorHardware;\n } else {\n            portDefn->format.video.nFrameWidth = fmt.fmt.pix_mp.width;\n            portDefn->format.video.nFrameHeight = fmt.fmt.pix_mp.height;\n            portDefn->format.video.nStride = fmt.fmt.pix_mp.plane_fmt[0].bytesperline;\n            portDefn->format.video.nSliceHeight = fmt.fmt.pix_mp.plane_fmt[0].reserved[0];\n }\n } else {\n    portDefn->format.video.nFrameHeight =  drv_ctx.video_resolution.frame_height;\n    portDefn->format.video.nFrameWidth  =  drv_ctx.video_resolution.frame_width;\n    portDefn->format.video.nStride = drv_ctx.video_resolution.stride;\n    portDefn->format.video.nSliceHeight = drv_ctx.video_resolution.scan_lines;\n }\n\n if ((portDefn->format.video.eColorFormat == OMX_COLOR_FormatYUV420Planar) ||\n (portDefn->format.video.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar)) {\n           portDefn->format.video.nStride = ALIGN(drv_ctx.video_resolution.frame_width, 16);\n        portDefn->format.video.nSliceHeight = drv_ctx.video_resolution.frame_height;\n }\n    DEBUG_PRINT_HIGH(\"update_portdef(%u): Width = %u Height = %u Stride = %d \"\n \"SliceHeight = %u eColorFormat = %d nBufSize %u nBufCnt %u\",\n (unsigned int)portDefn->nPortIndex,\n (unsigned int)portDefn->format.video.nFrameWidth,\n (unsigned int)portDefn->format.video.nFrameHeight,\n (int)portDefn->format.video.nStride,\n (unsigned int)portDefn->format.video.nSliceHeight,\n (unsigned int)portDefn->format.video.eColorFormat,\n (unsigned int)portDefn->nBufferSize,\n (unsigned int)portDefn->nBufferCountActual);\n\n return eRet;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n     int off_cur;\n     int off_cur_end;\n \n     for (y = 0; y < lines; y++) {\n        off_cur = off_begin;\n        off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n         memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n        off_begin += off_pitch;\n     }\n    uint8_t *dst;\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n    if (blit_is_unsafe(s, false))\n        return 0;\n\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n\tunsigned int random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Trace(blink::Visitor* visitor) {\n    visitor->Trace(consumer_);\n    visitor->Trace(client_);\n    FetchDataLoader::Trace(visitor);\n    BytesConsumer::Client::Trace(visitor);\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-79"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Resource::IsLoadEventBlockingResourceType() const {\n  switch (type_) {\n    case Resource::kMainResource:\n    case Resource::kImage:\n    case Resource::kCSSStyleSheet:\n    case Resource::kScript:\n    case Resource::kFont:\n    case Resource::kSVGDocument:\n    case Resource::kXSLStyleSheet:\n    case Resource::kImportResource:\n      return true;\n    case Resource::kRaw:\n    case Resource::kLinkPrefetch:\n    case Resource::kTextTrack:\n    case Resource::kAudio:\n    case Resource::kVideo:\n    case Resource::kManifest:\n    case Resource::kMock:\n      return false;\n  }\n  NOTREACHED();\n  return false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static u32 vlan_dev_fix_features(struct net_device *dev, u32 features)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tu32 old_features = features;\n\n\tfeatures &= real_dev->features;\n\tfeatures &= real_dev->vlan_features;\n\n\tfeatures |= old_features & NETIF_F_SOFT_FEATURES;\n\n\tif (dev_ethtool_get_rx_csum(real_dev))\n\t\tfeatures |= NETIF_F_RXCSUM;\n\tfeatures |= NETIF_F_LLTX;\n\n\treturn features;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool AXNodeObject::hasContentEditableAttributeSet() const {\n  const AtomicString& contentEditableValue = getAttribute(contenteditableAttr);\n  if (contentEditableValue.isNull())\n     return false;\n   return contentEditableValue.isEmpty() ||\n         equalIgnoringCase(contentEditableValue, \"true\");\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static av_cold int xpm_decode_close(AVCodecContext *avctx)\n{\n     XPMDecContext *x = avctx->priv_data;\n     av_freep(&x->pixels);\n \n     return 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,\n                               int linesize_align[AV_NUM_DATA_POINTERS])\n{\n    int i;\n    int w_align = 1;\n    int h_align = 1;\n    AVPixFmtDescriptor const *desc = av_pix_fmt_desc_get(s->pix_fmt);\n\n    if (desc) {\n        w_align = 1 << desc->log2_chroma_w;\n        h_align = 1 << desc->log2_chroma_h;\n    }\n\n    switch (s->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUYV422:\n    case AV_PIX_FMT_YVYU422:\n    case AV_PIX_FMT_UYVY422:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_GBRP:\n    case AV_PIX_FMT_GBRAP:\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n    case AV_PIX_FMT_YUVJ420P:\n    case AV_PIX_FMT_YUVJ422P:\n    case AV_PIX_FMT_YUVJ440P:\n    case AV_PIX_FMT_YUVJ444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9LE:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10LE:\n    case AV_PIX_FMT_YUV420P10BE:\n    case AV_PIX_FMT_YUV420P12LE:\n    case AV_PIX_FMT_YUV420P12BE:\n    case AV_PIX_FMT_YUV420P14LE:\n    case AV_PIX_FMT_YUV420P14BE:\n    case AV_PIX_FMT_YUV420P16LE:\n    case AV_PIX_FMT_YUV420P16BE:\n    case AV_PIX_FMT_YUVA420P9LE:\n    case AV_PIX_FMT_YUVA420P9BE:\n    case AV_PIX_FMT_YUVA420P10LE:\n    case AV_PIX_FMT_YUVA420P10BE:\n    case AV_PIX_FMT_YUVA420P16LE:\n    case AV_PIX_FMT_YUVA420P16BE:\n    case AV_PIX_FMT_YUV422P9LE:\n    case AV_PIX_FMT_YUV422P9BE:\n    case AV_PIX_FMT_YUV422P10LE:\n    case AV_PIX_FMT_YUV422P10BE:\n    case AV_PIX_FMT_YUV422P12LE:\n    case AV_PIX_FMT_YUV422P12BE:\n    case AV_PIX_FMT_YUV422P14LE:\n    case AV_PIX_FMT_YUV422P14BE:\n    case AV_PIX_FMT_YUV422P16LE:\n    case AV_PIX_FMT_YUV422P16BE:\n    case AV_PIX_FMT_YUVA422P9LE:\n    case AV_PIX_FMT_YUVA422P9BE:\n    case AV_PIX_FMT_YUVA422P10LE:\n    case AV_PIX_FMT_YUVA422P10BE:\n    case AV_PIX_FMT_YUVA422P16LE:\n    case AV_PIX_FMT_YUVA422P16BE:\n    case AV_PIX_FMT_YUV440P10LE:\n    case AV_PIX_FMT_YUV440P10BE:\n    case AV_PIX_FMT_YUV440P12LE:\n    case AV_PIX_FMT_YUV440P12BE:\n    case AV_PIX_FMT_YUV444P9LE:\n    case AV_PIX_FMT_YUV444P9BE:\n    case AV_PIX_FMT_YUV444P10LE:\n    case AV_PIX_FMT_YUV444P10BE:\n    case AV_PIX_FMT_YUV444P12LE:\n    case AV_PIX_FMT_YUV444P12BE:\n    case AV_PIX_FMT_YUV444P14LE:\n    case AV_PIX_FMT_YUV444P14BE:\n    case AV_PIX_FMT_YUV444P16LE:\n    case AV_PIX_FMT_YUV444P16BE:\n    case AV_PIX_FMT_YUVA444P9LE:\n    case AV_PIX_FMT_YUVA444P9BE:\n    case AV_PIX_FMT_YUVA444P10LE:\n    case AV_PIX_FMT_YUVA444P10BE:\n    case AV_PIX_FMT_YUVA444P16LE:\n    case AV_PIX_FMT_YUVA444P16BE:\n    case AV_PIX_FMT_GBRP9LE:\n    case AV_PIX_FMT_GBRP9BE:\n    case AV_PIX_FMT_GBRP10LE:\n    case AV_PIX_FMT_GBRP10BE:\n    case AV_PIX_FMT_GBRP12LE:\n    case AV_PIX_FMT_GBRP12BE:\n    case AV_PIX_FMT_GBRP14LE:\n    case AV_PIX_FMT_GBRP14BE:\n    case AV_PIX_FMT_GBRP16LE:\n    case AV_PIX_FMT_GBRP16BE:\n    case AV_PIX_FMT_GBRAP12LE:\n    case AV_PIX_FMT_GBRAP12BE:\n    case AV_PIX_FMT_GBRAP16LE:\n    case AV_PIX_FMT_GBRAP16BE:\n        w_align = 16; //FIXME assume 16 pixel per macroblock\n        h_align = 16 * 2; // interlaced needs 2 macroblocks height\n        break;\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUVJ411P:\n    case AV_PIX_FMT_UYYVYY411:\n        w_align = 32;\n        h_align = 16 * 2;\n        break;\n    case AV_PIX_FMT_YUV410P:\n        if (s->codec_id == AV_CODEC_ID_SVQ1) {\n            w_align = 64;\n            h_align = 64;\n        }\n        break;\n    case AV_PIX_FMT_RGB555:\n        if (s->codec_id == AV_CODEC_ID_RPZA) {\n             w_align = 4;\n             h_align = 4;\n         }\n         break;\n     case AV_PIX_FMT_PAL8:\n     case AV_PIX_FMT_BGR8:\n    case AV_PIX_FMT_RGB8:\n        if (s->codec_id == AV_CODEC_ID_SMC ||\n            s->codec_id == AV_CODEC_ID_CINEPAK) {\n             w_align = 4;\n             h_align = 4;\n         }\n        if (s->codec_id == AV_CODEC_ID_JV) {\n             w_align = 8;\n             h_align = 8;\n         }\n        break;\n    case AV_PIX_FMT_BGR24:\n        if ((s->codec_id == AV_CODEC_ID_MSZH) ||\n            (s->codec_id == AV_CODEC_ID_ZLIB)) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    case AV_PIX_FMT_RGB24:\n        if (s->codec_id == AV_CODEC_ID_CINEPAK) {\n            w_align = 4;\n            h_align = 4;\n        }\n        break;\n    default:\n        break;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_IFF_ILBM) {\n        w_align = FFMAX(w_align, 8);\n    }\n\n    *width  = FFALIGN(*width, w_align);\n    *height = FFALIGN(*height, h_align);\n    if (s->codec_id == AV_CODEC_ID_H264 || s->lowres) {\n        *height += 2;\n\n        *width = FFMAX(*width, 32);\n    }\n\n    for (i = 0; i < 4; i++)\n        linesize_align[i] = STRIDE_ALIGN;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void AutofillDialogViews::UpdateForErrors() {\n  ValidateForm();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int __glXDisp_ChangeDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)\n{\n    xGLXChangeDrawableAttributesSGIXReq *req =\n\t(xGLXChangeDrawableAttributesSGIXReq *)pc;\n\n    return DoChangeDrawableAttributes(cl->client, req->drawable,\n\t\t\t\t      req->numAttribs, (CARD32 *) (req + 1));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void exitFromChild(int retcode) {\n#ifdef COVERAGE_TEST\n    exit(retcode);\n#else\n    _exit(retcode);\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline void gen_op_movq(int d_offset, int s_offset)\n{\n    tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env, s_offset);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-94"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void LayerWebKitThread::setNeedsCommit()\n {\n     if (m_owner)\n        m_owner->notifySyncRequired();\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tut8 *end, *need = NULL;\n\tconst char *section_name = \"\";\n\tElf_(Shdr) *link_shdr = NULL;\n\tconst char *link_section_name = \"\";\n\tSdb *sdb_vernaux = NULL;\n\tSdb *sdb_version = NULL;\n\tSdb *sdb = NULL;\n\tint i, cnt;\n\n\tif (!bin || !bin->dynstr) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn NULL;\n\t}\n\tif (shdr->sh_size < 1) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) {\n\t\tbprintf (\"Warning: Cannot allocate memory for Elf_(Verneed)\\n\");\n\t\tgoto beach;\n\t}\n\tend = need + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"num_entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tif (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) {\n\t\tgoto beach;\n\t}\n\tif (shdr->sh_offset + shdr->sh_size < shdr->sh_size) {\n\t\tgoto beach;\n\t}\n\ti = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size);\n\tif (i < 0)\n\t\tgoto beach;\n\tfor (i = 0, cnt = 0; cnt < shdr->sh_info; ++cnt) {\n\t\tint j, isum;\n\t\tut8 *vstart = need + i;\n\t\tElf_(Verneed) vvn = {0};\n\t\tif (vstart + sizeof (Elf_(Verneed)) > end) {\n\t\t\tgoto beach;\n\t\t}\n\t\tElf_(Verneed) *entry = &vvn;\n\t\tchar key[32] = {0};\n\t\tsdb_version = sdb_new0 ();\n\t\tif (!sdb_version) {\n\t\t\tgoto beach;\n\t\t}\n\t\tj = 0;\n\t\tvvn.vn_version = READ16 (vstart, j)\n\t\tvvn.vn_cnt = READ16 (vstart, j)\n\t\tvvn.vn_file = READ32 (vstart, j)\n\t\tvvn.vn_aux = READ32 (vstart, j)\n\t\tvvn.vn_next = READ32 (vstart, j)\n\n\t\tsdb_num_set (sdb_version, \"vn_version\", entry->vn_version, 0);\n\t\tsdb_num_set (sdb_version, \"idx\", i, 0);\n\t\tif (entry->vn_file > bin->dynstr_size) {\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\tchar *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16);\n\t\t\tsdb_set (sdb_version, \"file_name\", s, 0);\n \t\t\tfree (s);\n \t\t}\n \t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n\t\tvstart += entry->vn_aux;\n \t\tfor (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) {\n \t\t\tint k;\n \t\t\tElf_(Vernaux) * aux = NULL;\n\t\t\tElf_(Vernaux) vaux = {0};\n\t\t\tsdb_vernaux = sdb_new0 ();\n\t\t\tif (!sdb_vernaux) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\taux = (Elf_(Vernaux)*)&vaux;\n\t\t\tk = 0;\n\t\t\tvaux.vna_hash = READ32 (vstart, k)\n\t\t\tvaux.vna_flags = READ16 (vstart, k)\n\t\t\tvaux.vna_other = READ16 (vstart, k)\n\t\t\tvaux.vna_name = READ32 (vstart, k)\n\t\t\tvaux.vna_next = READ32 (vstart, k)\n\t\t\tif (aux->vna_name > bin->dynstr_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_vernaux, \"idx\", isum, 0);\n\t\t\tif (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) {\n\t\t\t\tchar name [16];\n\t\t\t\tstrncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1);\n\t\t\t\tname[sizeof(name)-1] = 0;\n\t\t\t\tsdb_set (sdb_vernaux, \"name\", name, 0);\n\t\t\t}\n\t\t\tsdb_set (sdb_vernaux, \"flags\", get_ver_flags (aux->vna_flags), 0);\n\t\t\tsdb_num_set (sdb_vernaux, \"version\", aux->vna_other, 0);\n\t\t\tisum += aux->vna_next;\n\t\t\tvstart += aux->vna_next;\n\t\t\tsnprintf (key, sizeof (key), \"vernaux%d\", j);\n\t\t\tsdb_ns_set (sdb_version, key, sdb_vernaux);\n\t\t}\n\t\tif ((int)entry->vn_next < 0) {\n\t\t\tbprintf (\"Invalid vn_next\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += entry->vn_next;\n\t\tsnprintf (key, sizeof (key), \"version%d\", cnt );\n\t\tsdb_ns_set (sdb, key, sdb_version);\n\t\tif (!entry->vn_next) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (need);\n\treturn sdb;\nbeach:\n\tfree (need);\n\tsdb_free (sdb_vernaux);\n\tsdb_free (sdb_version);\n\tsdb_free (sdb);\n\treturn NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool BrowserCommandController::IsCommandEnabled(int id) const {\n  return command_updater_.IsCommandEnabled(id);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "handle_bytes_read(int handle)\n{\n\tif (handle_is_ok(handle, HANDLE_FILE))\n\t\treturn (handles[handle].bytes_read);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-269"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "clock_gettime(clockid_t clk_id, struct timespec *tp)\n{\n\tFILETIME ft;\n\tULARGE_INTEGER li, li2;\n\tBOOL ok = FALSE;\n\tdouble d;\n\tstatic double perfcnt_per_sec = 0.0;\n\tstatic BOOL initialized = FALSE;\n\n\tif (!initialized) {\n\t\tQueryPerformanceFrequency((LARGE_INTEGER *)&li);\n\t\tperfcnt_per_sec = 1.0 / li.QuadPart;\n\t\tinitialized = TRUE;\n\t}\n\n\tif (tp) {\n\t\tmemset(tp, 0, sizeof(*tp));\n\n\t\tif (clk_id == CLOCK_REALTIME) {\n\n\t\t\t/* BEGIN: CLOCK_REALTIME = wall clock (date and time) */\n\t\t\tGetSystemTimeAsFileTime(&ft);\n\t\t\tli.LowPart = ft.dwLowDateTime;\n\t\t\tli.HighPart = ft.dwHighDateTime;\n\t\t\tli.QuadPart -= 116444736000000000; /* 1.1.1970 in filedate */\n\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_REALTIME */\n\n\t\t} else if (clk_id == CLOCK_MONOTONIC) {\n\n\t\t\t/* BEGIN: CLOCK_MONOTONIC = stopwatch (time differences) */\n\t\t\tQueryPerformanceCounter((LARGE_INTEGER *)&li);\n\t\t\td = li.QuadPart * perfcnt_per_sec;\n\t\t\ttp->tv_sec = (time_t)d;\n\t\t\td -= (double)tp->tv_sec;\n\t\t\ttp->tv_nsec = (long)(d * 1.0E9);\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_MONOTONIC */\n\n\t\t} else if (clk_id == CLOCK_THREAD) {\n\n\t\t\t/* BEGIN: CLOCK_THREAD = CPU usage of thread */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetThreadTimes(GetCurrentThread(),\n\t\t\t                   &t_create,\n\t\t\t                   &t_exit,\n\t\t\t                   &t_kernel,\n\t\t\t                   &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_THREAD */\n\n\t\t} else if (clk_id == CLOCK_PROCESS) {\n\n\t\t\t/* BEGIN: CLOCK_PROCESS = CPU usage of process */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetProcessTimes(GetCurrentProcess(),\n\t\t\t                    &t_create,\n\t\t\t                    &t_exit,\n\t\t\t                    &t_kernel,\n\t\t\t                    &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_PROCESS */\n\n\t\t} else {\n\n\t\t\t/* BEGIN: unknown clock */\n\t\t\t/* ok = FALSE; already set by init */\n\t\t\t/* END: unknown clock */\n\t\t}\n\t}\n\n\treturn ok ? 0 : -1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void metx_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tif (ptr->config) gf_isom_box_del((GF_Box *)ptr->config);\n\tgf_free(ptr);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "XGetModifierMapping(register Display *dpy)\n{\n    xGetModifierMappingReply rep;\n    register xReq *req;\n    unsigned long nbytes;\n    XModifierKeymap *res;\n\n    LockDisplay(dpy);\n     GetEmptyReq(GetModifierMapping, req);\n     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);\n \n    if (rep.length < (INT_MAX >> 2)) {\n \tnbytes = (unsigned long)rep.length << 2;\n \tres = Xmalloc(sizeof (XModifierKeymap));\n \tif (res)\n    } else\n\tres = NULL;\n    if ((! res) || (! res->modifiermap)) {\n\tXfree(res);\n\tres = (XModifierKeymap *) NULL;\n\t_XEatDataWords(dpy, rep.length);\n    } else {\n\t_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);\n\tres->max_keypermod = rep.numKeyPerModifier;\n    }\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (res);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SkBitmap Browser::GetCurrentPageIcon() const {\n  TabContents* contents = GetSelectedTabContents();\n  return contents ? contents->GetFavicon() : SkBitmap();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int snd_card_file_remove(struct snd_card *card, struct file *file)\n{\n\tstruct snd_monitor_file *mfile, *found = NULL;\n\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tif (mfile->file == file) {\n\t\t\tlist_del(&mfile->list);\n\t\t\tspin_lock(&shutdown_lock);\n\t\t\tlist_del(&mfile->shutdown_list);\n\t\t\tspin_unlock(&shutdown_lock);\n\t\t\tif (mfile->disconnected_f_op)\n\t\t\t\tfops_put(mfile->disconnected_f_op);\n\t\t\tfound = mfile;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&card->files_lock);\n\tif (!found) {\n\t\tdev_err(card->dev, \"card file remove problem (%p)\\n\", file);\n\t\treturn -ENOENT;\n\t}\n\tkfree(found);\n\tput_device(&card->card_dev);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void v9fs_symlink(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsString name;\n    V9fsString symname;\n    V9fsFidState *dfidp;\n    V9fsQID qid;\n    struct stat stbuf;\n    int32_t dfid;\n    int err = 0;\n    gid_t gid;\n    size_t offset = 7;\n\n    v9fs_string_init(&name);\n    v9fs_string_init(&symname);\n    err = pdu_unmarshal(pdu, offset, \"dssd\", &dfid, &name, &symname, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_symlink(pdu->tag, pdu->id, dfid, name.data, symname.data, gid);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    err = v9fs_co_symlink(pdu, dfidp, &name, symname.data, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err =  pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_symlink_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n    v9fs_string_free(&symname);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "oxide::BrowserContext* WebContext::GetContext() {\n   if (context_.get()) {\n     return context_.get();\n   }\n \n   DCHECK(construct_props_);\n \n  oxide::BrowserContext::Params params(\n       construct_props_->data_path,\n       construct_props_->cache_path,\n       construct_props_->max_cache_size_hint,\n       construct_props_->session_cookie_mode);\n   params.host_mapping_rules = construct_props_->host_mapping_rules;\n \n  context_ = oxide::BrowserContext::Create(params);\n \n   UserAgentSettings* ua_settings = UserAgentSettings::Get(context_.get());\n  if (!construct_props_->product.empty()) {\n    ua_settings->SetProduct(construct_props_->product);\n  }\n  if (!construct_props_->user_agent.empty()) {\n    ua_settings->SetUserAgent(construct_props_->user_agent);\n  }\n  if (!construct_props_->accept_langs.empty()) {\n    ua_settings->SetAcceptLangs(construct_props_->accept_langs);\n  }\n  ua_settings->SetUserAgentOverrides(construct_props_->user_agent_overrides);\n  ua_settings->SetLegacyUserAgentOverrideEnabled(\n      construct_props_->legacy_user_agent_override_enabled);\n\n  context_->SetCookiePolicy(construct_props_->cookie_policy);\n  context_->SetIsPopupBlockerEnabled(construct_props_->popup_blocker_enabled);\n  context_->SetDoNotTrack(construct_props_->do_not_track);\n\n  MediaCaptureDevicesContext* dc =\n      MediaCaptureDevicesContext::Get(context_.get());\n\n  if (!construct_props_->default_audio_capture_device_id.empty()) {\n    if (!dc->SetDefaultAudioDeviceId(\n        construct_props_->default_audio_capture_device_id)) {\n      client_->DefaultAudioCaptureDeviceChanged();\n    }\n  }\n  if (!construct_props_->default_video_capture_device_id.empty()) {\n    if (!dc->SetDefaultVideoDeviceId(\n        construct_props_->default_video_capture_device_id)) {\n      client_->DefaultVideoCaptureDeviceChanged();\n    }\n  }\n\n  dc->set_client(this);\n\n  DevToolsManager* devtools = DevToolsManager::Get(context_.get());\n  if (!construct_props_->devtools_ip.empty()) {\n    devtools->SetAddress(construct_props_->devtools_ip);\n  }\n  if (construct_props_->devtools_port != -1) {\n    devtools->SetPort(construct_props_->devtools_port);\n  }\n  devtools->SetEnabled(construct_props_->devtools_enabled);\n\n  context_->SetDelegate(delegate_.get());\n\n  construct_props_.reset();\n\n  UpdateUserScripts();\n\n  return context_.get();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static DiceResponseHandlerFactory* GetInstance() {\n    return base::Singleton<DiceResponseHandlerFactory>::get();\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int nl80211_send_mpath(struct sk_buff *msg, u32 pid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tu8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_STATION);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, dst);\n\tNLA_PUT(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION, pinfo->generation);\n\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_MPATH_INFO);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (pinfo->filled & MPATH_INFO_FRAME_QLEN)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_FRAME_QLEN,\n\t\t\t    pinfo->frame_qlen);\n\tif (pinfo->filled & MPATH_INFO_SN)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_SN,\n\t\t\t    pinfo->sn);\n\tif (pinfo->filled & MPATH_INFO_METRIC)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_METRIC,\n\t\t\t    pinfo->metric);\n\tif (pinfo->filled & MPATH_INFO_EXPTIME)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_EXPTIME,\n\t\t\t    pinfo->exptime);\n\tif (pinfo->filled & MPATH_INFO_FLAGS)\n\t\tNLA_PUT_U8(msg, NL80211_MPATH_INFO_FLAGS,\n\t\t\t    pinfo->flags);\n\tif (pinfo->filled & MPATH_INFO_DISCOVERY_TIMEOUT)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,\n\t\t\t    pinfo->discovery_timeout);\n\tif (pinfo->filled & MPATH_INFO_DISCOVERY_RETRIES)\n\t\tNLA_PUT_U8(msg, NL80211_MPATH_INFO_DISCOVERY_RETRIES,\n\t\t\t    pinfo->discovery_retries);\n\n\tnla_nest_end(msg, pinfoattr);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mSignalledError) {\n return;\n }\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (NULL == mCodecCtx) {\n if (OK != initDecoder()) {\n return;\n }\n }\n if (outputBufferWidth() != mStride) {\n /* Set the run-time (dynamic) parameters */\n        mStride = outputBufferWidth();\n        setParams(mStride);\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n /* If input EOS is seen and decoder is not in flush mode,\n     * set the decoder in flush mode.\n     * There can be a case where EOS is sent along with last picture data\n     * In that case, only after decoding that input data, decoder has to be\n     * put in flush. This case is handled here  */\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n            mReceivedEOS = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n                setFlushMode();\n }\n }\n\n /* Get a free slot in timestamp array to hold input timestamp */\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n \n             GETTIME(&mTimeStart, NULL);\n             /* Compute time elapsed between end of previous decode()\n             * to start of current decode() */\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n /* Compute time taken for decode() */\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            ALOGV(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n /* If the input did not contain picture data, then ignore\n                 * the associated timestamp */\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n                outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n\n                outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];\n                mTimeStampsValid[s_dec_op.u4_ts] = false;\n\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(outQueue.begin());\n                outInfo = NULL;\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n } else {\n /* If in flush mode and no output is returned by the codec,\n                 * then come out of flush mode */\n                mIsInFlush = false;\n\n /* If EOS was recieved on input port and there is no output\n                 * from the codec, then signal EOS on output port */\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    format,\n    magick[MagickPathExtent];\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  Quantum\n    index;\n\n  QuantumAny\n    pixel;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register unsigned char\n    *q;\n\n  size_t\n    extent,\n    imageListLength,\n    packet_size;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    QuantumAny\n      max_value;\n\n    /*\n      Write PNM file header.\n    */\n    packet_size=3;\n    quantum_type=RGBQuantum;\n    (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);\n    max_value=GetQuantumRange(image->depth);\n    switch (magick[1])\n    {\n      case 'A':\n      case 'a':\n      {\n        format='7';\n        break;\n      }\n      case 'B':\n      case 'b':\n      {\n        format='4';\n        if (image_info->compression == NoCompression)\n          format='1';\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        format='F';\n        if (SetImageGray(image,exception) != MagickFalse)\n          format='f';\n        break;\n      }\n      case 'G':\n      case 'g':\n      {\n        format='5';\n        if (image_info->compression == NoCompression)\n          format='2';\n        break;\n      }\n      case 'N':\n      case 'n':\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            format='5';\n            if (image_info->compression == NoCompression)\n              format='2';\n            if (SetImageMonochrome(image,exception) != MagickFalse)\n              {\n                format='4';\n                if (image_info->compression == NoCompression)\n                  format='1';\n              }\n            break;\n          }\n      }\n      default:\n      {\n        format='6';\n        if (image_info->compression == NoCompression)\n          format='3';\n        break;\n      }\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"P%c\\n\",format);\n    (void) WriteBlobString(image,buffer);\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      {\n        register const char\n          *p;\n\n        /*\n          Write comments to file.\n        */\n        (void) WriteBlobByte(image,'#');\n        for (p=value; *p != '\\0'; p++)\n        {\n          (void) WriteBlobByte(image,(unsigned char) *p);\n          if ((*p == '\\n') || (*p == '\\r'))\n            (void) WriteBlobByte(image,'#');\n        }\n        (void) WriteBlobByte(image,'\\n');\n      }\n    if (format != '7')\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g\\n\",\n          (double) image->columns,(double) image->rows);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        char\n          type[MagickPathExtent];\n\n        /*\n          PAM header.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"WIDTH %.20g\\nHEIGHT %.20g\\n\",(double) image->columns,(double)\n          image->rows);\n        (void) WriteBlobString(image,buffer);\n        quantum_type=GetQuantumType(image,exception);\n        switch (quantum_type)\n        {\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            packet_size=4;\n            (void) CopyMagickString(type,\"CMYK\",MagickPathExtent);\n            break;\n          }\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            packet_size=1;\n            (void) CopyMagickString(type,\"GRAYSCALE\",MagickPathExtent);\n            if (IdentifyImageMonochrome(image,exception) != MagickFalse)\n              (void) CopyMagickString(type,\"BLACKANDWHITE\",MagickPathExtent);\n            break;\n          }\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            packet_size=3;\n            (void) CopyMagickString(type,\"RGB\",MagickPathExtent);\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            packet_size++;\n            (void) ConcatenateMagickString(type,\"_ALPHA\",MagickPathExtent);\n          }\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"DEPTH %.20g\\nMAXVAL %.20g\\n\",(double) packet_size,(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"TUPLTYPE %s\\nENDHDR\\n\",type);\n        (void) WriteBlobString(image,buffer);\n      }\n    /*\n      Convert runextent encoded to PNM raster pixels.\n    */\n    switch (format)\n    {\n      case '1':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?\n              '0' : '1');\n            *q++=' ';\n            if ((q-pixels+1) >= (ssize_t) sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '2':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ClampToQuantum(GetPixelLuma(image,p));\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\"%u \",\n                ScaleQuantumToChar(index));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToShort(index));\n              else\n                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                   \"%u \",ScaleQuantumToLong(index));\n             extent=(size_t) count;\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            if ((q-pixels+extent+2) >= sizeof(pixels))\n               {\n                 *q++='\\n';\n                 (void) WriteBlob(image,q-pixels,pixels);\n                 q=pixels;\n               }\n             p+=GetPixelChannels(image);\n           }\n           *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '3':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                \"%u %u %u \",ScaleQuantumToChar(GetPixelRed(image,p)),\n                ScaleQuantumToChar(GetPixelGreen(image,p)),\n                ScaleQuantumToChar(GetPixelBlue(image,p)));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToShort(GetPixelRed(image,p)),\n                  ScaleQuantumToShort(GetPixelGreen(image,p)),\n                  ScaleQuantumToShort(GetPixelBlue(image,p)));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToLong(GetPixelRed(image,p)),\n                   ScaleQuantumToLong(GetPixelGreen(image,p)),\n                   ScaleQuantumToLong(GetPixelBlue(image,p)));\n             extent=(size_t) count;\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n             if ((q-pixels+extent+2) >= sizeof(pixels))\n               {\n                 *q++='\\n';\n                 (void) WriteBlob(image,q-pixels,pixels);\n                 q=pixels;\n               }\n             p+=GetPixelChannels(image);\n           }\n           *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '4':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        image->depth=1;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GrayQuantum,pixels,exception);\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '5':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,GrayQuantum);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GrayQuantum,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                        image,p)),max_value);\n                    else\n                      {\n                        if (image->depth == 8)\n                          pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                        p)),max_value);\n                    else\n                      {\n                        if (image->depth == 16)\n                          pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (IsPixelGray(image,p) == MagickFalse)\n                  pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),\n                    max_value);\n                else\n                  {\n                    if (image->depth == 16)\n                      pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n                    else\n                      pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                  }\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '6':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '7':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PAM.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                      p)),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=(unsigned char) ScaleQuantumToAny(\n                          GetPixelAlpha(image,p),max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlack(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                default:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        register unsigned char\n          *pixels;\n\n        (void) WriteBlobString(image,image->endian == LSBEndian ? \"-1.0\\n\" :\n          \"1.0\\n\");\n        image->depth=32;\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          (void) WriteBlob(image,extent,pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void LoginHtmlDialog::Observe(NotificationType type,\n                              const NotificationSource& source,\n                              const NotificationDetails& details) {\n  DCHECK(type.value == NotificationType::LOAD_COMPLETED_MAIN_FRAME);\n  if (bubble_frame_view_)\n    bubble_frame_view_->StopThrobber();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int yr_execute_code(\n    YR_RULES* rules,\n    YR_SCAN_CONTEXT* context,\n    int timeout,\n    time_t start_time)\n{\n  int64_t mem[MEM_SIZE];\n  int32_t sp = 0;\n  uint8_t* ip = rules->code_start;\n\n  YR_VALUE args[MAX_FUNCTION_ARGS];\n  YR_VALUE *stack;\n  YR_VALUE r1;\n  YR_VALUE r2;\n  YR_VALUE r3;\n\n  #ifdef PROFILING_ENABLED\n  YR_RULE* current_rule = NULL;\n  #endif\n\n   YR_RULE* rule;\n   YR_MATCH* match;\n   YR_OBJECT_FUNCTION* function;\n \n   char* identifier;\n   char* args_fmt;\n\n  int i;\n  int found;\n  int count;\n  int result = ERROR_SUCCESS;\n  int stop = FALSE;\n  int cycle = 0;\n  int tidx = context->tidx;\n  int stack_size;\n\n  #ifdef PROFILING_ENABLED\n  clock_t start = clock();\n  #endif\n\n  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);\n\n  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));\n\n   if (stack == NULL)\n     return ERROR_INSUFFICIENT_MEMORY;\n \n   while(!stop)\n   {\n     switch(*ip)\n    {\n      case OP_NOP:\n        break;\n        \n      case OP_HALT:\n        assert(sp == 0); // When HALT is reached the stack should be empty.\n        stop = TRUE;\n        break;\n\n      case OP_PUSH:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        push(r1);\n        break;\n\n      case OP_POP:\n        pop(r1);\n        break;\n\n      case OP_CLEAR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i] = 0;\n        break;\n\n      case OP_ADD_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        if (!is_undef(r2))\n          mem[r1.i] += r2.i;\n        break;\n\n      case OP_INCR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i]++;\n        break;\n\n      case OP_PUSH_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = mem[r1.i];\n        push(r1);\n        break;\n\n      case OP_POP_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        mem[r1.i] = r2.i;\n        break;\n\n      case OP_SWAPUNDEF:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n\n        if (is_undef(r2))\n        {\n          r1.i = mem[r1.i];\n          push(r1);\n        }\n        else\n        {\n          push(r2);\n        }\n        break;\n\n      case OP_JNUNDEF:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1), ip);\n        break;\n\n      case OP_JLE:\n        pop(r2);\n        pop(r1);\n        push(r1);\n        push(r2);\n\n        ip = jmp_if(r1.i <= r2.i, ip);\n        break;\n\n      case OP_JTRUE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1) && r1.i, ip);\n        break;\n\n      case OP_JFALSE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(is_undef(r1) || !r1.i, ip);\n        break;\n\n      case OP_AND:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1) || is_undef(r2))\n          r1.i = 0;\n        else\n          r1.i = r1.i && r2.i;\n\n        push(r1);\n        break;\n\n      case OP_OR:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          push(r2);\n        }\n        else if (is_undef(r2))\n        {\n          push(r1);\n        }\n        else\n        {\n          r1.i = r1.i || r2.i;\n          push(r1);\n        }\n        break;\n\n      case OP_NOT:\n        pop(r1);\n\n        if (is_undef(r1))\n          r1.i = UNDEFINED;\n        else\n          r1.i= !r1.i;\n\n        push(r1);\n        break;\n\n      case OP_MOD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i % r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_SHR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >> r2.i;\n        push(r1);\n        break;\n\n      case OP_SHL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i << r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_NOT:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = ~r1.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_AND:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i & r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_OR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i | r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_XOR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i ^ r2.i;\n        push(r1);\n        break;\n\n      case OP_PUSH_RULE:\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_INIT_RULE:\n        #ifdef PROFILING_ENABLED\n        current_rule = *(YR_RULE**)(ip + 1);\n        #endif\n        ip += sizeof(uint64_t);\n        break;\n\n      case OP_MATCH_RULE:\n        pop(r1);\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        if (!is_undef(r1) && r1.i)\n          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;\n        else if (RULE_IS_GLOBAL(rule))\n          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;\n\n        #ifdef PROFILING_ENABLED\n         rule->clock_ticks += clock() - start;\n         start = clock();\n         #endif\n         break;\n \n       case OP_OBJ_LOAD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        r1.o = (YR_OBJECT*) yr_hash_table_lookup(\n            context->objects_table,\n            identifier,\n            NULL);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_FIELD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        pop(r1);\n        ensure_defined(r1);\n\n        r1.o = yr_object_lookup_field(r1.o, identifier);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_VALUE:\n        pop(r1);\n        ensure_defined(r1);\n\n        switch(r1.o->type)\n        {\n          case OBJECT_TYPE_INTEGER:\n            r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_FLOAT:\n            if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))\n              r1.i = UNDEFINED;\n            else\n              r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_STRING:\n            if (((YR_OBJECT_STRING*) r1.o)->value == NULL)\n              r1.i = UNDEFINED;\n            else\n              r1.p = ((YR_OBJECT_STRING*) r1.o)->value;\n            break;\n\n          default:\n            assert(FALSE);\n        }\n\n        push(r1);\n        break;\n\n      case OP_INDEX_ARRAY:\n        pop(r1);  // index\n        pop(r2);  // array\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_ARRAY);\n\n        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_LOOKUP_DICT:\n        pop(r1);  // key\n        pop(r2);  // dictionary\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);\n\n        r1.o = yr_object_dict_get_item(\n            r2.o, 0, r1.ss->c_string);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_CALL:\n        args_fmt = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        i = (int) strlen(args_fmt);\n        count = 0;\n\n\n        while (i > 0)\n        {\n          pop(r1);\n\n          if (is_undef(r1))  // count the number of undefined args\n            count++;\n\n          args[i - 1] = r1;\n          i--;\n        }\n\n        pop(r2);\n        ensure_defined(r2);\n\n        if (count > 0)\n        {\n\n          r1.i = UNDEFINED;\n          push(r1);\n          break;\n        }\n\n        function = (YR_OBJECT_FUNCTION*) r2.o;\n        result = ERROR_INTERNAL_FATAL_ERROR;\n\n        for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        {\n          if (function->prototypes[i].arguments_fmt == NULL)\n            break;\n\n          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)\n          {\n            result = function->prototypes[i].code(args, context, function);\n            break;\n           }\n         }\n \n         assert(i < MAX_OVERLOADED_FUNCTIONS);\n \n         if (result == ERROR_SUCCESS)\n        {\n          r1.o = function->return_obj;\n          push(r1);\n        }\n        else\n        {\n          stop = TRUE;\n        }\n \n         break;\n \n       case OP_FOUND:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_FOUND_AT:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          r1.i = 0;\n          push(r1);\n          break;\n        }\n\n        match = r2.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL)\n        {\n          if (r1.i == match->base + match->offset)\n          {\n            r3.i = TRUE;\n            break;\n          }\n\n          if (r1.i < match->base + match->offset)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_FOUND_IN:\n        pop(r3);\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        match = r3.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL && !r3.i)\n        {\n          if (match->base + match->offset >= r1.i &&\n              match->base + match->offset <= r2.i)\n          {\n            r3.i = TRUE;\n          }\n\n          if (match->base + match->offset > r2.i)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_COUNT:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].count;\n        push(r1);\n        break;\n\n      case OP_OFFSET:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->base + match->offset;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_LENGTH:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->match_length;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_OF:\n        found = 0;\n        count = 0;\n        pop(r1);\n\n        while (!is_undef(r1))\n        {\n          if (r1.s->matches[tidx].tail != NULL)\n            found++;\n          count++;\n          pop(r1);\n        }\n\n        pop(r2);\n\n        if (is_undef(r2))\n          r1.i = found >= count ? 1 : 0;\n        else\n          r1.i = found >= r2.i ? 1 : 0;\n\n        push(r1);\n        break;\n\n      case OP_FILESIZE:\n        r1.i = context->file_size;\n        push(r1);\n        break;\n\n      case OP_ENTRYPOINT:\n        r1.i = context->entry_point;\n        push(r1);\n        break;\n\n      case OP_INT8:\n        pop(r1);\n        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16:\n        pop(r1);\n        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32:\n        pop(r1);\n        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8:\n        pop(r1);\n        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16:\n        pop(r1);\n        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32:\n        pop(r1);\n        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT8BE:\n        pop(r1);\n        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16BE:\n        pop(r1);\n        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32BE:\n        pop(r1);\n        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8BE:\n        pop(r1);\n        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16BE:\n        pop(r1);\n        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32BE:\n        pop(r1);\n        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_CONTAINS:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        r1.i = memmem(r1.ss->c_string, r1.ss->length,\n                      r2.ss->c_string, r2.ss->length) != NULL;\n        push(r1);\n        break;\n\n      case OP_IMPORT:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        result = yr_modules_load((char*) r1.p, context);\n\n        if (result != ERROR_SUCCESS)\n          stop = TRUE;\n\n        break;\n\n      case OP_MATCHES:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r2);\n        ensure_defined(r1);\n\n        if (r1.ss->length == 0)\n        {\n          r1.i = FALSE;\n          push(r1);\n          break;\n        }\n\n        result = yr_re_exec(\n          (uint8_t*) r2.re->code,\n          (uint8_t*) r1.ss->c_string,\n          r1.ss->length,\n          0,\n          r2.re->flags | RE_FLAGS_SCAN,\n          NULL,\n          NULL,\n          &found);\n\n        if (result != ERROR_SUCCESS)\n          stop = TRUE;\n\n        r1.i = found >= 0;\n        push(r1);\n        break;\n\n      case OP_INT_TO_DBL:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r2 = stack[sp - r1.i];\n        if (is_undef(r2))\n          stack[sp - r1.i].i = UNDEFINED;\n        else\n          stack[sp - r1.i].d = (double) r2.i;\n        break;\n\n      case OP_STR_TO_BOOL:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = r1.ss->length > 0;\n        push(r1);\n        break;\n\n      case OP_INT_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i == r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i != r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i < r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i > r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i <= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i + r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i - r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i * r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i / r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_INT_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = -r1.i;\n        push(r1);\n        break;\n\n      case OP_DBL_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d < r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d > r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d <= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d >= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d == r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d != r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d + r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d - r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d * r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d / r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.d = -r1.d;\n        push(r1);\n        break;\n\n      case OP_STR_EQ:\n      case OP_STR_NEQ:\n      case OP_STR_LT:\n      case OP_STR_LE:\n      case OP_STR_GT:\n      case OP_STR_GE:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        switch(*ip)\n        {\n          case OP_STR_EQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);\n            break;\n          case OP_STR_NEQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);\n            break;\n          case OP_STR_LT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);\n            break;\n          case OP_STR_LE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);\n            break;\n          case OP_STR_GT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);\n            break;\n          case OP_STR_GE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);\n            break;\n        }\n\n        push(r1);\n        break;\n\n      default:\n        assert(FALSE);\n    }\n\n    if (timeout > 0)  // timeout == 0 means no timeout\n    {\n\n      if (++cycle == 10)\n      {\n        if (difftime(time(NULL), start_time) > timeout)\n        {\n          #ifdef PROFILING_ENABLED\n          assert(current_rule != NULL);\n          current_rule->clock_ticks += clock() - start;\n          #endif\n          result = ERROR_SCAN_TIMEOUT;\n          stop = TRUE;\n        }\n\n        cycle = 0;\n      }\n    }\n\n     ip++;\n   }\n \n   yr_modules_unload_all(context);\n   yr_free(stack);\n \n  return result;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PHP_FUNCTION(imageconvolution)\n{\n\tzval *SIM, *hash_matrix;\n\tzval **var = NULL, **var2 = NULL;\n\tgdImagePtr im_src = NULL;\n\tdouble div, offset;\n\tint nelem, i, j, res;\n\tfloat matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"radd\", &SIM, &hash_matrix, &div, &offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));\n\tif (nelem != 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {\n\t\t\tif (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n \n \t\t\tfor (j=0; j<3; j++) {\n \t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n\t\t\t\t\tSEPARATE_ZVAL(var2);\n\t\t\t\t\tconvert_to_double(*var2);\n\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n \t\t\t\t} else {\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have a 3x3 matrix\");\n \t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres = gdImageConvolution(im_src, matrix, (float)div, (float)offset);\n\n\tif (res) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Editor::ChangeSelectionAfterCommand(\n    const SelectionInDOMTree& new_selection,\n    const SetSelectionData& options) {\n  if (new_selection.IsNone())\n    return;\n\n   bool selection_did_not_change_dom_position =\n       new_selection == GetFrame().Selection().GetSelectionInDOMTree();\n   GetFrame().Selection().SetSelection(\n      SelectionInDOMTree::Builder(new_selection)\n          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())\n          .Build(),\n      options);\n \n  if (selection_did_not_change_dom_position) {\n    Client().RespondToChangedSelection(\n        frame_, GetFrame().Selection().GetSelectionInDOMTree().Type());\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Browser::ShouldSaveWindowPlacement() const {\n  switch (type_) {\n    case TYPE_TABBED:\n      return true;\n    case TYPE_POPUP:\n      return browser_defaults::kRestorePopups || is_devtools();\n    case TYPE_PANEL:\n      return false;\n    default:\n      return false;\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "jsonb_to_recordset(PG_FUNCTION_ARGS)\n{\n\treturn populate_recordset_worker(fcinfo, \"jsonb_to_recordset\", false);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool ImeObserver::HasListener(const std::string& event_name) const {\n  return extensions::EventRouter::Get(profile_)->HasEventListener(event_name);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n \t\treturn NULL;\n \t}\n\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n \tif (!buf) {\n \t\treturn r_bin_dyldcache_free (bin);\n \t}\n\tbin->b = r_buf_new();\n\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n \t\treturn r_bin_dyldcache_free (bin);\n \t}\n \tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Element::rendererIsFocusable() const\n{\n    if (isInCanvasSubtree()) {\n        const Element* e = this;\n        while (e && !e->hasLocalName(canvasTag))\n            e = e->parentElement();\n        ASSERT(e);\n        return e->renderer() && e->renderer()->style()->visibility() == VISIBLE;\n    }\n\n    if (renderer()) {\n        ASSERT(!renderer()->needsLayout());\n    } else {\n        ASSERT(!document()->childNeedsStyleRecalc());\n    }\n\n    if (!renderer() || renderer()->style()->visibility() != VISIBLE)\n        return false;\n\n    return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "const SeekHead* Segment::GetSeekHead() const { return m_pSeekHead; }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void VaapiVideoDecodeAccelerator::ReusePictureBuffer(\n    int32_t picture_buffer_id) {\n  VLOGF(4) << \"picture id=\" << picture_buffer_id;\n  DCHECK(task_runner_->BelongsToCurrentThread());\n  TRACE_EVENT1(\"Video Decoder\", \"VAVDA::ReusePictureBuffer\", \"Picture id\",\n               picture_buffer_id);\n\n  if (!PictureById(picture_buffer_id)) {\n    VLOGF(3) << \"got picture id=\" << picture_buffer_id\n             << \" not in use (anymore?).\";\n    return;\n  }\n\n  --num_frames_at_client_;\n  TRACE_COUNTER1(\"Video Decoder\", \"Textures at client\", num_frames_at_client_);\n\n  output_buffers_.push(picture_buffer_id);\n  TryOutputSurface();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int cxusb_dualdig4_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 ircode[4];\n\tint i;\n\tstruct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,\n\t\t\t       .buf = ircode, .len = 4 };\n\n\tif (usb_set_interface(adap->dev->udev, 0, 1) < 0)\n\t\terr(\"set interface failed\");\n\n\tcxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0);\n\n\t/* reset the tuner and demodulator */\n\tcxusb_bluebird_gpio_rw(adap->dev, 0x04, 0);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x01, 1);\n\tcxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1);\n\n\tadap->fe_adap[0].fe =\n\t\tdvb_attach(zl10353_attach,\n\t\t\t   &cxusb_zl10353_xc3028_config_no_i2c_gate,\n\t\t\t   &adap->dev->i2c_adap);\n\tif ((adap->fe_adap[0].fe) == NULL)\n\t\treturn -EIO;\n\n\t/* try to determine if there is no IR decoder on the I2C bus */\n\tfor (i = 0; adap->dev->props.rc.core.rc_codes && i < 5; i++) {\n\t\tmsleep(20);\n\t\tif (cxusb_i2c_xfer(&adap->dev->i2c_adap, &msg, 1) != 1)\n\t\t\tgoto no_IR;\n\t\tif (ircode[0] == 0 && ircode[1] == 0)\n\t\t\tcontinue;\n\t\tif (ircode[2] + ircode[3] != 0xff) {\nno_IR:\n\t\t\tadap->dev->props.rc.core.rc_codes = NULL;\n\t\t\tinfo(\"No IR receiver detected on this device.\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "path_open(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P_COPY(0);\n\n\tpath->closed = FALSE;\n\n\tPG_RETURN_PATH_P(path);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp) {\n\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     header->nFilledLen = rangeLength;\n     header->nOffset = rangeOffset;\n \n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    buffer_meta->CopyToOMX(header);\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void bnep_net_setup(struct net_device *dev)\n{\n\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n \tdev->addr_len = ETH_ALEN;\n \n \tether_setup(dev);\n \tdev->netdev_ops = &bnep_netdev_ops;\n \n \tdev->watchdog_timeo  = HZ * 2;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int PreProcessingFx_ProcessReverse(effect_handle_t     self,\n                                    audio_buffer_t    *inBuffer,\n                                   audio_buffer_t    *outBuffer)\n {\n     preproc_effect_t * effect = (preproc_effect_t *)self;\n     int    status = 0;\n\n if (effect == NULL){\n        ALOGW(\"PreProcessingFx_ProcessReverse() ERROR effect == NULL\");\n return -EINVAL;\n }\n preproc_session_t * session = (preproc_session_t *)effect->session;\n\n if (inBuffer == NULL  || inBuffer->raw == NULL){\n        ALOGW(\"PreProcessingFx_ProcessReverse() ERROR bad pointer\");\n return -EINVAL;\n }\n\n    session->revProcessedMsk |= (1<<effect->procId);\n\n\n\n if ((session->revProcessedMsk & session->revEnabledMsk) == session->revEnabledMsk) {\n        effect->session->revProcessedMsk = 0;\n if (session->revResampler != NULL) {\n size_t fr = session->frameCount - session->framesRev;\n if (inBuffer->frameCount < fr) {\n                fr = inBuffer->frameCount;\n }\n if (session->revBufSize < session->framesRev + fr) {\n                session->revBufSize = session->framesRev + fr;\n                session->revBuf = (int16_t *)realloc(session->revBuf,\n                                  session->revBufSize * session->inChannelCount * sizeof(int16_t));\n }\n            memcpy(session->revBuf + session->framesRev * session->inChannelCount,\n                   inBuffer->s16,\n                   fr * session->inChannelCount * sizeof(int16_t));\n\n            session->framesRev += fr;\n            inBuffer->frameCount = fr;\n if (session->framesRev < session->frameCount) {\n return 0;\n }\n spx_uint32_t frIn = session->framesRev;\n spx_uint32_t frOut = session->apmFrameCount;\n if (session->inChannelCount == 1) {\n                speex_resampler_process_int(session->revResampler,\n 0,\n                                            session->revBuf,\n &frIn,\n                                            session->revFrame->_payloadData,\n &frOut);\n } else {\n                speex_resampler_process_interleaved_int(session->revResampler,\n                                                        session->revBuf,\n &frIn,\n                                                        session->revFrame->_payloadData,\n &frOut);\n }\n            memcpy(session->revBuf,\n                   session->revBuf + frIn * session->inChannelCount,\n (session->framesRev - frIn) * session->inChannelCount * sizeof(int16_t));\n            session->framesRev -= frIn;\n } else {\n size_t fr = session->frameCount - session->framesRev;\n if (inBuffer->frameCount < fr) {\n                fr = inBuffer->frameCount;\n }\n            memcpy(session->revFrame->_payloadData + session->framesRev * session->inChannelCount,\n                   inBuffer->s16,\n                   fr * session->inChannelCount * sizeof(int16_t));\n            session->framesRev += fr;\n            inBuffer->frameCount = fr;\n if (session->framesRev < session->frameCount) {\n return 0;\n }\n            session->framesRev = 0;\n }\n        session->revFrame->_payloadDataLengthInSamples =\n                session->apmFrameCount * session->inChannelCount;\n        effect->session->apm->AnalyzeReverseStream(session->revFrame);\n return 0;\n } else {\n return -ENODATA;\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Smb4KGlobal::openShare( Smb4KShare *share, OpenWith openWith )\n{\n  if ( !share || share->isInaccessible() )\n  {\n    return;\n  }\n\n  switch ( openWith )\n  {\n    case FileManager:\n    {\n      KUrl url;\n      url.setPath( share->canonicalPath() );\n\n      (void) new KRun( url, 0, 0, true );\n\n      break;\n    }\n    case Konsole:\n    {\n      QString konsole = KGlobal::dirs()->findResource( \"exe\", \"konsole\" );\n\n      if ( konsole.isEmpty() )\n      {\n        Smb4KNotification::commandNotFound(\"konsole\");\n      }\n      else\n      {\n        KRun::runCommand( konsole+\" --workdir \"+KShell::quoteArg( share->canonicalPath() ), 0 );\n      }\n\n      break;\n    }\n    default:\n    {\n      break;\n    }\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int robots_fsio_stat(pr_fs_t *fs, const char *path, struct stat *st) {\n  st->st_dev = (dev_t) 0;\n  st->st_ino = (ino_t) 0;\n  st->st_mode = (S_IFREG|S_IRUSR|S_IRGRP|S_IROTH);\n  st->st_nlink = 0;\n  st->st_uid = (uid_t) 0;\n  st->st_gid = (gid_t) 0;\n  st->st_atime = 0;\n  st->st_mtime = 0;\n  st->st_ctime = 0;\n  st->st_size = strlen(AUTH_ROBOTS_TXT);\n  st->st_blksize = 1024;\n  st->st_blocks = 1;\n\n  return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-59"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void sync_descbuffer_for_device(struct b43_dmaring *ring,\n\t\t\t\t    dma_addr_t addr, size_t len)\n{\n\tB43_WARN_ON(ring->tx);\n\tdma_sync_single_for_device(ring->dev->dev->dma_dev,\n\t\t\t\t   addr, len, DMA_FROM_DEVICE);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static jint android_net_wifi_doIntCommand(JNIEnv* env, jobject, jstring javaCommand) {\n return doIntCommand(env, javaCommand);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BeginTrace() {\n    BeginSpecificTrace(\"*\");\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *service_name_tlv = NULL, service_name_tlv_length;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CONNECT\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n \t\t\t\t\t\t      sock->service_name,\n \t\t\t\t\t\t      sock->service_name_len,\n \t\t\t\t\t\t      &service_name_tlv_length);\n \t\tsize += service_name_tlv_length;\n \t}\n \n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n \tsize += rw_tlv_length;\n \n \tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(service_name_tlv);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "base::WaitableEvent* ProxyChannelDelegate::GetShutdownEvent() {\n  return &shutdown_event_;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int find_high_bit(unsigned int x)\n {\n \tint i;\n \tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n \t}\n \treturn 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-682"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void EC_pre_comp_free(EC_GROUP *group)\n{\n    switch (group->pre_comp_type) {\n    default:\n        break;\n#ifdef ECP_NISTZ256_REFERENCE_IMPLEMENTATION\n    case PCT_nistz256:\n        EC_nistz256_pre_comp_free(group->pre_comp.nistz256);\n        break;\n#endif\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n    case PCT_nistp224:\n        EC_nistp224_pre_comp_free(group->pre_comp.nistp224);\n        break;\n    case PCT_nistp256:\n        EC_nistp256_pre_comp_free(group->pre_comp.nistp256);\n        break;\n    case PCT_nistp521:\n        EC_nistp521_pre_comp_free(group->pre_comp.nistp521);\n        break;\n#endif\n    case PCT_ec:\n        EC_ec_pre_comp_free(group->pre_comp.ec);\n        break;\n    }\n    group->pre_comp.ec = NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-311"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int create_cgroup(struct cgroup_mount_point *mp, const char *path)\n{\n\treturn create_or_remove_cgroup(false, mp, path, false);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-59"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  MagickBooleanType\n    closed_path;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *stroke_polygon;\n\n  register const PrimitiveInfo\n    *p,\n    *q;\n\n  /*\n    Draw stroked polygon.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n   if (clone_info->stroke_pattern != (Image *) NULL)\n     clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n       MagickTrue,exception);\n  clone_info->stroke.alpha=(Quantum) TransparentAlpha;\n   clone_info->stroke_width=0.0;\n   clone_info->fill_rule=NonZeroRule;\n   status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    stroke_polygon=TraceStrokePolygon(draw_info,p);\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    if (status == 0)\n      break;\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    q=p+p->coordinates-1;\n    closed_path=(q->point.x == p->point.x) && (q->point.y == p->point.y) ?\n      MagickTrue : MagickFalse;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        DrawRoundLinecap(image,draw_info,p,exception);\n        DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n     /* destroy msix memory region */\n     if (dev->msix_table && dev->msix_pba\n         && dev->msix_entry_used) {\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n     }\n \n     usb_bus_release(&xhci->bus);\n    usb_bus_release(&xhci->bus);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "read_Header(struct archive_read *a, struct _7z_header_info *h,\n    int check_header_id)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tstruct _7z_folder *folders;\n\tstruct _7z_stream_info *si = &(zip->si);\n\tstruct _7zip_entry *entries;\n\tuint32_t folderIndex, indexInFolder;\n\tunsigned i;\n\tint eindex, empty_streams, sindex;\n\n\tif (check_header_id) {\n\t\t/*\n\t\t * Read Header.\n\t\t */\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\tif (*p != kHeader)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read ArchiveProperties.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kArchiveProperties) {\n\t\tfor (;;) {\n\t\t\tuint64_t size;\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (*p == 0)\n\t\t\t\tbreak;\n\t\t\tif (parse_7zip_uint64(a, &size) < 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read MainStreamsInfo.\n\t */\n\tif (*p == kMainStreamsInfo) {\n\t\tif (read_StreamsInfo(a, &(zip->si)) < 0)\n\t\t\treturn (-1);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\tif (*p == kEnd)\n\t\treturn (0);\n\n\t/*\n\t * Read FilesInfo.\n\t */\n\tif (*p != kFilesInfo)\n\t\treturn (-1);\n\n\tif (parse_7zip_uint64(a, &(zip->numFiles)) < 0)\n\t\treturn (-1);\n\tif (UMAX_ENTRY < zip->numFiles)\n\t\treturn (-1);\n\n\tzip->entries = calloc((size_t)zip->numFiles, sizeof(*zip->entries));\n\tif (zip->entries == NULL)\n\t\treturn (-1);\n\tentries = zip->entries;\n\n\tempty_streams = 0;\n\tfor (;;) {\n\t\tint type;\n\t\tuint64_t size;\n\t\tsize_t ll;\n\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t\ttype = *p;\n\t\tif (type == kEnd)\n\t\t\tbreak;\n\n\t\tif (parse_7zip_uint64(a, &size) < 0)\n\t\t\treturn (-1);\n\t\tif (zip->header_bytes_remaining < size)\n\t\t\treturn (-1);\n\t\tll = (size_t)size;\n \n \t\tswitch (type) {\n \t\tcase kEmptyStream:\n \t\t\th->emptyStreamBools = calloc((size_t)zip->numFiles,\n \t\t\t    sizeof(*h->emptyStreamBools));\n \t\t\tif (h->emptyStreamBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(\n\t\t\t    a, h->emptyStreamBools, (size_t)zip->numFiles) < 0)\n\t\t\t\treturn (-1);\n\t\t\tempty_streams = 0;\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tif (h->emptyStreamBools[i])\n\t\t\t\t\tempty_streams++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase kEmptyFile:\n\t\t\tif (empty_streams <= 0) {\n\t\t\t\t/* Unexcepted sequence. Skip this. */\n\t\t\t\tif (header_bytes(a, ll) == NULL)\n \t\t\t\t\treturn (-1);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\th->emptyFileBools = calloc(empty_streams,\n \t\t\t    sizeof(*h->emptyFileBools));\n \t\t\tif (h->emptyFileBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(a, h->emptyFileBools, empty_streams) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kAnti:\n\t\t\tif (empty_streams <= 0) {\n\t\t\t\t/* Unexcepted sequence. Skip this. */\n\t\t\t\tif (header_bytes(a, ll) == NULL)\n \t\t\t\t\treturn (-1);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\th->antiBools = calloc(empty_streams,\n \t\t\t    sizeof(*h->antiBools));\n \t\t\tif (h->antiBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (read_Bools(a, h->antiBools, empty_streams) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kCTime:\n\t\tcase kATime:\n\t\tcase kMTime:\n\t\t\tif (read_Times(a, h, type) < 0)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\tcase kName:\n\t\t{\n\t\t\tunsigned char *np;\n\t\t\tsize_t nl, nb;\n\n\t\t\t/* Skip one byte. */\n\t\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tll--;\n\n \t\t\tif ((ll & 1) || ll < zip->numFiles * 4)\n \t\t\t\treturn (-1);\n \n \t\t\tzip->entry_names = malloc(ll);\n \t\t\tif (zip->entry_names == NULL)\n \t\t\t\treturn (-1);\n\t\t\tnp = zip->entry_names;\n\t\t\tnb = ll;\n\t\t\t/*\n\t\t\t * Copy whole file names.\n\t\t\t * NOTE: This loop prevents from expanding\n\t\t\t * the uncompressed buffer in order not to\n\t\t\t * use extra memory resource.\n\t\t\t */\n\t\t\twhile (nb) {\n\t\t\t\tsize_t b;\n\t\t\t\tif (nb > UBUFF_SIZE)\n\t\t\t\t\tb = UBUFF_SIZE;\n\t\t\t\telse\n\t\t\t\t\tb = nb;\n\t\t\t\tif ((p = header_bytes(a, b)) == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tmemcpy(np, p, b);\n\t\t\t\tnp += b;\n\t\t\t\tnb -= b;\n\t\t\t}\n\t\t\tnp = zip->entry_names;\n\t\t\tnl = ll;\n\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tentries[i].utf16name = np;\n#if defined(_WIN32) && !defined(__CYGWIN__) && defined(_DEBUG)\n\t\t\t\tentries[i].wname = (wchar_t *)np;\n#endif\n\n\t\t\t\t/* Find a terminator. */\n\t\t\t\twhile (nl >= 2 && (np[0] || np[1])) {\n\t\t\t\t\tnp += 2;\n\t\t\t\t\tnl -= 2;\n\t\t\t\t}\n\t\t\t\tif (nl < 2)\n\t\t\t\t\treturn (-1);/* Terminator not found */\n\t\t\t\tentries[i].name_len = np - entries[i].utf16name;\n\t\t\t\tnp += 2;\n\t\t\t\tnl -= 2;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase kAttributes:\n\t\t{\n\t\t\tint allAreDefined;\n\n \t\t\tif ((p = header_bytes(a, 2)) == NULL)\n \t\t\t\treturn (-1);\n \t\t\tallAreDefined = *p;\n \t\t\th->attrBools = calloc((size_t)zip->numFiles,\n \t\t\t    sizeof(*h->attrBools));\n \t\t\tif (h->attrBools == NULL)\n\t\t\t\treturn (-1);\n\t\t\tif (allAreDefined)\n\t\t\t\tmemset(h->attrBools, 1, (size_t)zip->numFiles);\n\t\t\telse {\n\t\t\t\tif (read_Bools(a, h->attrBools,\n\t\t\t\t      (size_t)zip->numFiles) < 0)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tfor (i = 0; i < zip->numFiles; i++) {\n\t\t\t\tif (h->attrBools[i]) {\n\t\t\t\t\tif ((p = header_bytes(a, 4)) == NULL)\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\tentries[i].attr = archive_le32dec(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase kDummy:\n\t\t\tif (ll == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (header_bytes(a, ll) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Set up entry's attributes.\n\t */\n\tfolders = si->ci.folders;\n\teindex = sindex = 0;\n\tfolderIndex = indexInFolder = 0;\n\tfor (i = 0; i < zip->numFiles; i++) {\n\t\tif (h->emptyStreamBools == NULL || h->emptyStreamBools[i] == 0)\n\t\t\tentries[i].flg |= HAS_STREAM;\n\t\t/* The high 16 bits of attributes is a posix file mode. */\n\t\tentries[i].mode = entries[i].attr >> 16;\n\t\tif (entries[i].flg & HAS_STREAM) {\n\t\t\tif ((size_t)sindex >= si->ss.unpack_streams)\n\t\t\t\treturn (-1);\n\t\t\tif (entries[i].mode == 0)\n\t\t\t\tentries[i].mode = AE_IFREG | 0666;\n\t\t\tif (si->ss.digestsDefined[sindex])\n\t\t\t\tentries[i].flg |= CRC32_IS_SET;\n\t\t\tentries[i].ssIndex = sindex;\n\t\t\tsindex++;\n\t\t} else {\n\t\t\tint dir;\n\t\t\tif (h->emptyFileBools == NULL)\n\t\t\t\tdir = 1;\n\t\t\telse {\n\t\t\t\tif (h->emptyFileBools[eindex])\n\t\t\t\t\tdir = 0;\n\t\t\t\telse\n\t\t\t\t\tdir = 1;\n\t\t\t\teindex++;\n\t\t\t}\n\t\t\tif (entries[i].mode == 0) {\n\t\t\t\tif (dir)\n\t\t\t\t\tentries[i].mode = AE_IFDIR | 0777;\n\t\t\t\telse\n\t\t\t\t\tentries[i].mode = AE_IFREG | 0666;\n\t\t\t} else if (dir &&\n\t\t\t    (entries[i].mode & AE_IFMT) != AE_IFDIR) {\n\t\t\t\tentries[i].mode &= ~AE_IFMT;\n\t\t\t\tentries[i].mode |= AE_IFDIR;\n\t\t\t}\n\t\t\tif ((entries[i].mode & AE_IFMT) == AE_IFDIR &&\n\t\t\t    entries[i].name_len >= 2 &&\n\t\t\t    (entries[i].utf16name[entries[i].name_len-2] != '/' ||\n\t\t\t     entries[i].utf16name[entries[i].name_len-1] != 0)) {\n\t\t\t\tentries[i].utf16name[entries[i].name_len] = '/';\n\t\t\t\tentries[i].utf16name[entries[i].name_len+1] = 0;\n\t\t\t\tentries[i].name_len += 2;\n\t\t\t}\n\t\t\tentries[i].ssIndex = -1;\n\t\t}\n\t\tif (entries[i].attr & 0x01)\n\t\t\tentries[i].mode &= ~0222;/* Read only. */\n\n\t\tif ((entries[i].flg & HAS_STREAM) == 0 && indexInFolder == 0) {\n\t\t\t/*\n\t\t\t * The entry is an empty file or a directory file,\n\t\t\t * those both have no contents.\n\t\t\t */\n\t\t\tentries[i].folderIndex = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (indexInFolder == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tif (folderIndex >= si->ci.numFolders)\n\t\t\t\t\treturn (-1);\n\t\t\t\tif (folders[folderIndex].numUnpackStreams)\n\t\t\t\t\tbreak;\n\t\t\t\tfolderIndex++;\n\t\t\t}\n\t\t}\n\t\tentries[i].folderIndex = folderIndex;\n\t\tif ((entries[i].flg & HAS_STREAM) == 0)\n\t\t\tcontinue;\n\t\tindexInFolder++;\n\t\tif (indexInFolder >= folders[folderIndex].numUnpackStreams) {\n\t\t\tfolderIndex++;\n\t\t\tindexInFolder = 0;\n\t\t}\n\t}\n\n\treturn (0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n \n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void saa7164_bus_verify(struct saa7164_dev *dev)\n{\n\tstruct tmComResBusInfo *b = &dev->bus;\n\tint bug = 0;\n\n\tif (saa7164_readl(b->m_dwSetReadPos) > b->m_dwSizeSetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwSetWritePos) > b->m_dwSizeSetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwGetReadPos) > b->m_dwSizeGetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwGetWritePos) > b->m_dwSizeGetRing)\n\t\tbug++;\n\n\tif (bug) {\n\t\tsaa_debug = 0xffff; /* Ensure we get the bus dump */\n\t\tsaa7164_bus_dump(dev);\n\t\tsaa_debug = 1024; /* Ensure we get the bus dump */\n\t\tBUG();\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BrowserCommandController::RemoveInterstitialObservers(\n    TabContents* contents) {\n   registrar_.Remove(this, content::NOTIFICATION_INTERSTITIAL_ATTACHED,\n                    content::Source<WebContents>(contents->web_contents()));\n   registrar_.Remove(this, content::NOTIFICATION_INTERSTITIAL_DETACHED,\n                    content::Source<WebContents>(contents->web_contents()));\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Instance::HandleInputEvent(const pp::InputEvent& event) {\n  pp::InputEvent event_device_res(event);\n  {\n    pp::MouseInputEvent mouse_event(event);\n    if (!mouse_event.is_null()) {\n      pp::Point point = mouse_event.GetPosition();\n      pp::Point movement = mouse_event.GetMovement();\n      ScalePoint(device_scale_, &point);\n      ScalePoint(device_scale_, &movement);\n      mouse_event = pp::MouseInputEvent(\n          this,\n          event.GetType(),\n          event.GetTimeStamp(),\n          event.GetModifiers(),\n          mouse_event.GetButton(),\n          point,\n          mouse_event.GetClickCount(),\n          movement);\n      event_device_res = mouse_event;\n    }\n  }\n\n  if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE &&\n     (event.GetModifiers() & PP_INPUTEVENT_MODIFIER_MIDDLEBUTTONDOWN)) {\n    pp::MouseInputEvent mouse_event(event_device_res);\n    pp::Point pos = mouse_event.GetPosition();\n    EnableAutoscroll(pos);\n    UpdateCursor(CalculateAutoscroll(pos));\n    return true;\n  } else {\n    DisableAutoscroll();\n  }\n\n#ifdef ENABLE_THUMBNAILS\n  if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSELEAVE)\n    thumbnails_.SlideOut();\n\n  if (thumbnails_.HandleEvent(event_device_res))\n    return true;\n#endif\n\n  if (toolbar_->HandleEvent(event_device_res))\n    return true;\n\n#ifdef ENABLE_THUMBNAILS\n  if (v_scrollbar_.get() && event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE) {\n    pp::MouseInputEvent mouse_event(event);\n    pp::Point pt = mouse_event.GetPosition();\n    pp::Rect v_scrollbar_rc;\n    v_scrollbar_->GetLocation(&v_scrollbar_rc);\n    if (v_scrollbar_rc.Contains(pt) &&\n        (event.GetModifiers() & PP_INPUTEVENT_MODIFIER_LEFTBUTTONDOWN)) {\n      thumbnails_.SlideIn();\n    }\n\n    if (!v_scrollbar_rc.Contains(pt) && thumbnails_.visible() &&\n        !(event.GetModifiers() & PP_INPUTEVENT_MODIFIER_LEFTBUTTONDOWN) &&\n        !thumbnails_.rect().Contains(pt)) {\n      thumbnails_.SlideOut();\n    }\n  }\n#endif\n\n  pp::InputEvent offset_event(event_device_res);\n  bool try_engine_first = true;\n  switch (offset_event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n    case PP_INPUTEVENT_TYPE_MOUSEENTER:\n    case PP_INPUTEVENT_TYPE_MOUSELEAVE: {\n      pp::MouseInputEvent mouse_event(event_device_res);\n      pp::MouseInputEvent mouse_event_dip(event);\n      pp::Point point = mouse_event.GetPosition();\n      point.set_x(point.x() - available_area_.x());\n      offset_event = pp::MouseInputEvent(\n          this,\n          event.GetType(),\n          event.GetTimeStamp(),\n          event.GetModifiers(),\n          mouse_event.GetButton(),\n          point,\n          mouse_event.GetClickCount(),\n          mouse_event.GetMovement());\n      if (!engine_->IsSelecting()) {\n        if (!IsOverlayScrollbar() &&\n            !available_area_.Contains(mouse_event.GetPosition())) {\n          try_engine_first = false;\n        } else if (IsOverlayScrollbar()) {\n          pp::Rect temp;\n          if ((v_scrollbar_.get() && v_scrollbar_->GetLocation(&temp) &&\n              temp.Contains(mouse_event_dip.GetPosition())) ||\n              (h_scrollbar_.get() && h_scrollbar_->GetLocation(&temp) &&\n              temp.Contains(mouse_event_dip.GetPosition()))) {\n            try_engine_first = false;\n          }\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  if (try_engine_first && engine_->HandleEvent(offset_event))\n    return true;\n\n  if (v_scrollbar_.get() && event.GetType() == PP_INPUTEVENT_TYPE_KEYDOWN) {\n    pp::KeyboardInputEvent keyboard_event(event);\n    bool no_h_scrollbar = !h_scrollbar_.get();\n    uint32_t key_code = keyboard_event.GetKeyCode();\n    bool page_down = no_h_scrollbar && key_code == ui::VKEY_RIGHT;\n    bool page_up = no_h_scrollbar && key_code == ui::VKEY_LEFT;\n    if (zoom_mode_ == ZOOM_FIT_TO_PAGE) {\n      bool has_shift =\n          keyboard_event.GetModifiers() & PP_INPUTEVENT_MODIFIER_SHIFTKEY;\n      bool key_is_space = key_code == ui::VKEY_SPACE;\n      page_down |= key_is_space || key_code == ui::VKEY_NEXT;\n      page_up |= (key_is_space && has_shift) || (key_code == ui::VKEY_PRIOR);\n     }\n     if (page_down) {\n       int page = engine_->GetFirstVisiblePage();\n      if (engine_->GetPageRect(page).bottom() * zoom_ <=\n          v_scrollbar_->GetValue())\n        page++;\n      ScrollToPage(page + 1);\n      UpdateCursor(PP_CURSORTYPE_POINTER);\n       return true;\n     } else if (page_up) {\n       int page = engine_->GetFirstVisiblePage();\n       if (engine_->GetPageRect(page).y() * zoom_ >= v_scrollbar_->GetValue())\n         page--;\n       ScrollToPage(page);\n      UpdateCursor(PP_CURSORTYPE_POINTER);\n      return true;\n    }\n  }\n\n  if (v_scrollbar_.get() && v_scrollbar_->HandleEvent(event)) {\n    UpdateCursor(PP_CURSORTYPE_POINTER);\n    return true;\n  }\n\n  if (h_scrollbar_.get() && h_scrollbar_->HandleEvent(event)) {\n    UpdateCursor(PP_CURSORTYPE_POINTER);\n    return true;\n  }\n\n  if (timer_pending_ &&\n      (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEUP ||\n       event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE)) {\n    timer_factory_.CancelAll();\n    timer_pending_ = false;\n  } else if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE &&\n             engine_->IsSelecting()) {\n    bool set_timer = false;\n    pp::MouseInputEvent mouse_event(event);\n    if (v_scrollbar_.get() &&\n        (mouse_event.GetPosition().y() <= 0 ||\n         mouse_event.GetPosition().y() >= (plugin_dip_size_.height() - 1))) {\n      v_scrollbar_->ScrollBy(\n          PP_SCROLLBY_LINE, mouse_event.GetPosition().y() >= 0 ? 1: -1);\n      set_timer = true;\n    }\n    if (h_scrollbar_.get() &&\n        (mouse_event.GetPosition().x() <= 0 ||\n         mouse_event.GetPosition().x() >= (plugin_dip_size_.width() - 1))) {\n      h_scrollbar_->ScrollBy(PP_SCROLLBY_LINE,\n          mouse_event.GetPosition().x() >= 0 ? 1: -1);\n      set_timer = true;\n    }\n\n    if (set_timer) {\n      last_mouse_event_ = pp::MouseInputEvent(event);\n\n      pp::CompletionCallback callback =\n          timer_factory_.NewCallback(&Instance::OnTimerFired);\n      pp::Module::Get()->core()->CallOnMainThread(kDragTimerMs, callback);\n      timer_pending_ = true;\n    }\n  }\n\n  if (event.GetType() == PP_INPUTEVENT_TYPE_KEYDOWN &&\n      event.GetModifiers() & kDefaultKeyModifier) {\n    pp::KeyboardInputEvent keyboard_event(event);\n    switch (keyboard_event.GetKeyCode()) {\n      case 'A':\n        engine_->SelectAll();\n        return true;\n    }\n  }\n\n  return (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEDOWN);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int GetLayersUpdateTimeHistogramBucket(size_t numLayers) {\n  if (numLayers < 10)\n    return 0;\n  if (numLayers < 30)\n    return 1;\n  if (numLayers < 70)\n    return 2;\n  if (numLayers < 150)\n    return 3;\n  return 4;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!vcpu->arch.apic)\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic))\n\t\t\treturn PTR_ERR(u.lapic);\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof irq))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof cpuid))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(vcpu, argp, kvm_get_msr, 1);\n\t\tbreak;\n\tcase KVM_SET_MSRS:\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tbreak;\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof tac))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof tac))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\n\t\tr = -EINVAL;\n\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\tgoto out;\n \t\tr = -EFAULT;\n \t\tif (copy_from_user(&va, argp, sizeof va))\n \t\t\tgoto out;\n\t\tr = 0;\n\t\tkvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n \t\tbreak;\n \t}\n \tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tkvm_set_tsc_khz(vcpu, user_tsc_khz);\n\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\n\treturn r;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static unsigned int ssh_tty_parse_boolean(char *s)\n{\n    if (stricmp(s, \"yes\") == 0 ||\n\tstricmp(s, \"on\") == 0 ||\n\tstricmp(s, \"true\") == 0 ||\n\tstricmp(s, \"+\") == 0)\n\treturn 1; /* true */\n    else if (stricmp(s, \"no\") == 0 ||\n\t     stricmp(s, \"off\") == 0 ||\n\t     stricmp(s, \"false\") == 0 ||\n\t     stricmp(s, \"-\") == 0)\n\treturn 0; /* false */\n    else\n\treturn (atoi(s) != 0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int pagemap_hugetlb_range(pte_t *pte, unsigned long hmask,\n\t\t\t\t unsigned long addr, unsigned long end,\n\t\t\t\t struct mm_walk *walk)\n{\n\tstruct pagemapread *pm = walk->private;\n\tint err = 0;\n\tu64 pfn;\n\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tint offset = (addr & ~hmask) >> PAGE_SHIFT;\n\t\tpfn = huge_pte_to_pagemap_entry(*pte, offset);\n\t\terr = add_to_pagemap(addr, pfn, pm);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcond_resched();\n\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int __init md5_mod_init(void)\n{\n\treturn crypto_register_shash(&alg);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int libevt_record_values_read_event(\n     libevt_record_values_t *record_values,\n     uint8_t *record_data,\n     size_t record_data_size,\n     uint8_t strict_mode,\n     libcerror_error_t **error )\n{\n\tstatic char *function      = \"libevt_record_values_read_event\";\n\tsize_t record_data_offset  = 0;\n\tsize_t strings_data_offset = 0;\n\tssize_t value_data_size    = 0;\n\tuint32_t data_offset       = 0;\n\tuint32_t data_size         = 0;\n\tuint32_t members_data_size = 0;\n\tuint32_t size              = 0;\n\tuint32_t size_copy         = 0;\n\tuint32_t strings_offset    = 0;\n\tuint32_t strings_size      = 0;\n\tuint32_t user_sid_offset   = 0;\n\tuint32_t user_sid_size     = 0;\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tuint32_t value_32bit       = 0;\n\tuint16_t value_16bit       = 0;\n#endif\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid record data size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size < ( sizeof( evt_record_event_header_t ) + 4 ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: record data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->size,\n\t size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->record_number,\n\t record_values->number );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->creation_time,\n\t record_values->creation_time );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->written_time,\n\t record_values->written_time );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_identifier,\n\t record_values->event_identifier );\n\n\tbyte_stream_copy_to_uint16_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_type,\n\t record_values->event_type );\n\n\tbyte_stream_copy_to_uint16_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_category,\n\t record_values->event_category );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->strings_offset,\n\t strings_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->user_sid_size,\n\t user_sid_size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->user_sid_offset,\n\t user_sid_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->data_size,\n\t data_size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->data_offset,\n\t data_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t &( record_data[ record_data_size - 4 ] ),\n\t size_copy );\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: size\\t\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: signature\\t\\t\\t\\t: %c%c%c%c\\n\",\n\t\t function,\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 0 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 1 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 2 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 3 ] );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: record number\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t record_values->number );\n\n\t\tif( libevt_debug_print_posix_time_value(\n\t\t     function,\n\t\t     \"creation time\\t\\t\\t\\t\",\n\t\t     ( (evt_record_event_header_t *) record_data )->creation_time,\n\t\t     4,\n\t\t     LIBFDATETIME_ENDIAN_LITTLE,\n\t\t     LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED,\n\t\t     LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t \"%s: unable to print POSIX time value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libevt_debug_print_posix_time_value(\n\t\t     function,\n\t\t     \"written time\\t\\t\\t\\t\",\n\t\t     ( (evt_record_event_header_t *) record_data )->written_time,\n\t\t     4,\n\t\t     LIBFDATETIME_ENDIAN_LITTLE,\n\t\t     LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED,\n\t\t     LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t \"%s: unable to print POSIX time value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t record_values->event_identifier );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: code\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t record_values->event_identifier & 0x0000ffffUL );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: facility\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x0fff0000UL ) >> 16 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: reserved\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x10000000UL ) >> 28 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: customer flags\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x20000000UL ) >> 29 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: severity\\t\\t: %\" PRIu32 \" (\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0xc0000000UL ) >> 30 );\n\t\tlibevt_debug_print_event_identifier_severity(\n\t\t record_values->event_identifier );\n\t\tlibcnotify_printf(\n\t\t \")\\n\" );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event type\\t\\t\\t\\t: %\" PRIu16 \" (\",\n\t\t function,\n\t\t record_values->event_type );\n\t\tlibevt_debug_print_event_type(\n\t\t record_values->event_type );\n\t\tlibcnotify_printf(\n\t\t \")\\n\" );\n\n\t\tbyte_stream_copy_to_uint16_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->number_of_strings,\n\t\t value_16bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: number of strings\\t\\t\\t: %\" PRIu16 \"\\n\",\n\t\t function,\n\t\t value_16bit );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event category\\t\\t\\t\\t: %\" PRIu16 \"\\n\",\n\t\t function,\n\t\t record_values->event_category );\n\n\t\tbyte_stream_copy_to_uint16_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->event_flags,\n\t\t value_16bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: event flags\\t\\t\\t\\t: 0x%04\" PRIx16 \"\\n\",\n\t\t function,\n\t\t value_16bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->closing_record_number,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: closing record values number\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: strings offset\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t strings_offset );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: user security identifier (SID) size\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t user_sid_size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: user security identifier (SID) offset\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t user_sid_offset );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: data size\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: data offset\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t data_offset );\n\t}\n#endif\n\trecord_data_offset = sizeof( evt_record_event_header_t );\n\n\tif( ( user_sid_offset == 0 )\n\t && ( user_sid_size != 0 ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: user SID offset or size value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( user_sid_offset != 0 )\n\t{\n\t\tif( ( (size_t) user_sid_offset < record_data_offset )\n\t\t || ( (size_t) user_sid_offset >= ( record_data_size - 4 ) ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: user SID offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( user_sid_size != 0 )\n\t\t{\n\t\t\tif( (size_t) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t\t \"%s: user SID size value out of bounds.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\t/* If the strings offset is points at the offset at record data size - 4\n\t * the strings are empty. For this to be sane the data offset should\n\t * be the same as the strings offset or the data size 0.\n\t */\n\tif( ( (size_t) strings_offset < user_sid_offset )\n\t || ( (size_t) strings_offset >= ( record_data_size - 4 ) ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: strings offset value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( ( (size_t) data_offset < strings_offset )\n\t || ( (size_t) data_offset >= ( record_data_size - 4 ) ) )\n\t{\n\t\tif( data_size != 0 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: data offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tdata_offset = (uint32_t) record_data_size - 4;\n\t}\n\tif( ( (size_t) strings_offset >= ( record_data_size - 4 ) )\n\t && ( strings_offset != data_offset ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: strings offset value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( strings_offset != 0 )\n\t{\n\t\tif( strings_offset < record_data_offset )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: strings offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tif( user_sid_offset != 0 )\n\t{\n\t\tmembers_data_size = user_sid_offset - (uint32_t) record_data_offset;\n\t}\n\telse if( strings_offset != 0 )\n\t{\n\t\tmembers_data_size = strings_offset - (uint32_t) record_data_offset;\n\t}\n\tif( strings_offset != 0 )\n\t{\n\t\tstrings_size = data_offset - strings_offset;\n\t}\n\tif( data_size != 0 )\n\t{\n\t\tif( (size_t) ( data_offset + data_size ) > ( record_data_size - 4 ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: data size value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tif( members_data_size != 0 )\n\t{\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: members data:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t members_data_size,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n#endif\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->source_name ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create source name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_string(\n\t\t                   record_values->source_name,\n\t\t                   &( record_data[ record_data_offset ] ),\n\t\t                   members_data_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of source name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: source name\\t\\t\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->source_name,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print source name value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += value_data_size;\n\t\tmembers_data_size  -= (uint32_t) value_data_size;\n\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->computer_name ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create computer name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_string(\n\t\t                   record_values->computer_name,\n\t\t                   &( record_data[ record_data_offset ] ),\n\t\t                   members_data_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of computer name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: computer name\\t\\t\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->computer_name,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print computer name value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += value_data_size;\n\t\tmembers_data_size  -= (uint32_t) value_data_size;\n\n\t\tif( members_data_size > 0 )\n\t\t{\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\t\tif( libcnotify_verbose != 0 )\n\t\t\t{\n\t\t\t\tlibcnotify_printf(\n\t\t\t\t \"%s: members trailing data:\\n\",\n\t\t\t\t function );\n\t\t\t\tlibcnotify_print_data(\n\t\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t\t members_data_size,\n\t\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t\t}\n#endif\n\t\t\trecord_data_offset += members_data_size;\n\t\t}\n \t}\n \tif( user_sid_size != 0 )\n \t{\n \t\tif( libfvalue_value_type_initialize(\n \t\t     &( record_values->user_security_identifier ),\n \t\t     LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create user security identifier (SID) value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfvalue_value_set_data(\n\t\t     record_values->user_security_identifier,\n\t\t     &( record_data[ user_sid_offset ] ),\n\t\t     (size_t) user_sid_size,\n\t\t     LIBFVALUE_ENDIAN_LITTLE,\n\t\t     LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of user security identifier (SID) value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: user security identifier (SID)\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->user_security_identifier,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print user security identifier (SID) value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += user_sid_size;\n \t}\n \tif( strings_size != 0 )\n \t{\n #if defined( HAVE_DEBUG_OUTPUT )\n \t\tif( libcnotify_verbose != 0 )\n \t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: strings data:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ strings_offset ] ),\n\t\t\t strings_size,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n#endif\n\t\tif( size_copy == 0 )\n\t\t{\n\t\t\t/* If the strings data is truncated\n\t\t\t */\n\t\t\tstrings_data_offset = strings_offset + strings_size - 2;\n\n\t\t\twhile( strings_data_offset > strings_offset )\n\t\t\t{\n\t\t\t\tif( ( record_data[ strings_data_offset ] != 0 )\n\t\t\t\t || ( record_data[ strings_data_offset + 1 ] != 0 ) )\n\t\t\t\t{\n\t\t\t\t\tstrings_size += 2;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrings_data_offset -= 2;\n\t\t\t\tstrings_size        -= 2;\n\t\t\t}\n\t\t}\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->strings ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create strings value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_strings_array(\n\t\t                   record_values->strings,\n\t\t                   &( record_data[ strings_offset ] ),\n\t\t                   strings_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of strings value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\trecord_data_offset += strings_size;\n \t}\n \tif( data_size != 0 )\n \t{\n #if defined( HAVE_DEBUG_OUTPUT )\n \t\tif( libcnotify_verbose != 0 )\n \t\t{\n \t\t\tlibcnotify_printf(\n \t\t\t \"%s: data:\\n\",\n \t\t\t function );\n \t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ data_offset ] ),\n \t\t\t (size_t) data_size,\n \t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n \t\t}\n#endif\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->data ),\n\t\t     LIBFVALUE_VALUE_TYPE_BINARY_DATA,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create data value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfvalue_value_set_data(\n\t\t     record_values->data,\n\t\t     &( record_data[ record_data_offset ] ),\n\t\t     (size_t) data_size,\n\t\t     LIBFVALUE_ENDIAN_LITTLE,\n\t\t     LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of data value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\trecord_data_offset += data_size;\n#endif\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tif( record_data_offset < ( record_data_size - 4 ) )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: padding:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t (size_t) record_data_size - record_data_offset - 4,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n\t\tlibcnotify_printf(\n\t\t \"%s: size copy\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size_copy );\n\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\tif( ( strict_mode == 0 )\n\t && ( size_copy == 0 ) )\n\t{\n\t\tsize_copy = size;\n\t}\n\tif( size != size_copy )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for size and size copy.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( record_data_size != (size_t) size )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for record_values data size and size.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( record_values->data != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->data ),\n\t\t NULL );\n\t}\n\tif( record_values->strings != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->strings ),\n\t\t NULL );\n\t}\n\tif( record_values->user_security_identifier != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->user_security_identifier ),\n\t\t NULL );\n\t}\n\tif( record_values->computer_name != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->computer_name ),\n\t\t NULL );\n\t}\n\tif( record_values->source_name != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->source_name ),\n\t\t NULL );\n\t}\n\treturn( -1 );\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static char* tcmu_get_path( struct tcmu_device *dev)\n{\n\tchar *config;\n\n\tconfig = strchr(tcmu_get_dev_cfgstring(dev), '/');\n\tif (!config) {\n\t\ttcmu_err(\"no configuration found in cfgstring\\n\");\n\t\treturn NULL;\n\t}\n\tconfig += 1; /* get past '/' */\n\n \treturn config;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static std::pair<blink::Image*, float> BrokenCanvas(float device_scale_factor) {\n  if (device_scale_factor >= 2) {\n    DEFINE_STATIC_REF(blink::Image, broken_canvas_hi_res,\n                      (blink::Image::LoadPlatformResource(\"brokenCanvas@2x\")));\n    return std::make_pair(broken_canvas_hi_res, 2);\n  }\n\n  DEFINE_STATIC_REF(blink::Image, broken_canvas_lo_res,\n                    (blink::Image::LoadPlatformResource(\"brokenCanvas\")));\n  return std::make_pair(broken_canvas_lo_res, 1);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool FindAndUpdateProperty(const chromeos::ImeProperty& new_prop,\n                           chromeos::ImePropertyList* prop_list) {\n   for (size_t i = 0; i < prop_list->size(); ++i) {\n    chromeos::ImeProperty& prop = prop_list->at(i);\n     if (prop.key == new_prop.key) {\n       const int saved_id = prop.selection_item_id;\n      prop = new_prop;\n      prop.selection_item_id = saved_id;\n      return true;\n    }\n  }\n  return false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "std::string ChromeContentBrowserClient::GetDefaultDownloadName() {\n  return l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PrepareFrameAndViewForPrint::PrepareFrameAndViewForPrint(\n    const PrintMsg_Print_Params& print_params,\n    WebFrame* frame,\n    const WebNode& node)\n        : frame_(frame),\n          node_to_print_(node),\n          web_view_(frame->view()),\n          expected_pages_count_(0),\n          use_browser_overlays_(true),\n          finished_(false) {\n  WebPrintParams webkit_print_params;\n  ComputeWebKitPrintParamsInDesiredDpi(print_params, &webkit_print_params);\n\n  if (WebFrame* web_frame = web_view_->mainFrame())\n    prev_scroll_offset_ = web_frame->scrollOffset();\n  prev_view_size_ = web_view_->size();\n\n  StartPrinting(webkit_print_params);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)\n{\n struct ifreq ifr;\n int sk, err;\n\n    sk = socket(AF_INET, SOCK_DGRAM, 0);\n if (sk < 0)\n return -1;\n\n\n     memset(&ifr, 0, sizeof(ifr));\n     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);\n    err = ioctl(sk, SIOCGIFHWADDR, &ifr);\n     if (err < 0)\n     {\n         BTIF_TRACE_ERROR(\"Could not get network hardware for interface:%s, errno:%s\", devname, strerror(errno));\n        close(sk);\n return -1;\n }\n\n    strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);\n    memcpy(ifr.ifr_hwaddr.sa_data, addr->address, 6);\n\n /* The IEEE has specified that the most significant bit of the most significant byte is used to\n     * determine a multicast address. If its a 1, that means multicast, 0 means unicast.\n     * Kernel returns an error if we try to set a multicast address for the tun-tap ethernet interface.\n     * Mask this bit to avoid any issue with auto generated address.\n     */\n if (ifr.ifr_hwaddr.sa_data[0] & 0x01) {\n        BTIF_TRACE_WARNING(\"Not a unicast MAC address, force multicast bit flipping\");\n\n         ifr.ifr_hwaddr.sa_data[0] &= ~0x01;\n     }\n \n    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);\n \n     if (err < 0) {\n         BTIF_TRACE_ERROR(\"Could not set bt address for interface:%s, errno:%s\", devname, strerror(errno));\n        close(sk);\n return -1;\n }\n\n    memset(&ifr, 0, sizeof(ifr));\n    strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);\n\n\n     ifr.ifr_flags |= IFF_UP;\n     ifr.ifr_flags |= IFF_MULTICAST;\n \n    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);\n \n \n     if (err < 0) {\n        BTIF_TRACE_ERROR(\"Could not bring up network interface:%s, errno:%d\", devname, errno);\n        close(sk);\n return -1;\n }\n    close(sk);\n    BTIF_TRACE_DEBUG(\"network interface: %s is up\", devname);\n return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n \tif (file->private_data) {\n \t\ttu = file->private_data;\n \t\tfile->private_data = NULL;\n \t\tif (tu->timeri)\n \t\t\tsnd_timer_close(tu->timeri);\n \t\tkfree(tu->queue);\n \t\tkfree(tu->tqueue);\n \t\tkfree(tu);\n\t}\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ModuleExport void UnregisterPNGImage(void)\n{\n  (void) UnregisterMagickInfo(\"MNG\");\n  (void) UnregisterMagickInfo(\"PNG\");\n  (void) UnregisterMagickInfo(\"PNG8\");\n  (void) UnregisterMagickInfo(\"PNG24\");\n  (void) UnregisterMagickInfo(\"PNG32\");\n  (void) UnregisterMagickInfo(\"PNG48\");\n  (void) UnregisterMagickInfo(\"PNG64\");\n  (void) UnregisterMagickInfo(\"PNG00\");\n  (void) UnregisterMagickInfo(\"JNG\");\n\n#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  if (ping_semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&ping_semaphore);\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int dns_packet_append_answer(DnsPacket *p, DnsAnswer *a) {\n        DnsResourceRecord *rr;\n        DnsAnswerFlags flags;\n        int r;\n\n        assert(p);\n\n        DNS_ANSWER_FOREACH_FLAGS(rr, flags, a) {\n                r = dns_packet_append_rr(p, rr, flags, NULL, NULL);\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "double ConvolverNode::latencyTime() const\n {\n    return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "update_info_partition_on_linux_dmmp (Device *device)\n{\n  const gchar *dm_name;\n  const gchar* const *targets_type;\n  const gchar* const *targets_params;\n  gchar *params;\n  gint linear_slave_major;\n  gint linear_slave_minor;\n  guint64 offset_sectors;\n  Device *linear_slave;\n  gchar *s;\n\n  params = NULL;\n\n  dm_name = g_udev_device_get_property (device->priv->d, \"DM_NAME\");\n  if (dm_name == NULL)\n     goto out;\n \n   targets_type = g_udev_device_get_property_as_strv (device->priv->d, \"UDISKS_DM_TARGETS_TYPE\");\n   if (targets_type == NULL || g_strcmp0 (targets_type[0], \"linear\") != 0)\n     goto out;\n    goto out;\n  params = decode_udev_encoded_string (targets_params[0]);\n\n  if (sscanf (params,\n              \"%d:%d %\" G_GUINT64_FORMAT,\n              &linear_slave_major,\n              &linear_slave_minor,\n              &offset_sectors) != 3)\n    goto out;\n\n  linear_slave = daemon_local_find_by_dev (device->priv->daemon,\n                                              makedev (linear_slave_major, linear_slave_minor));\n  if (linear_slave == NULL)\n    goto out;\n  if (!linear_slave->priv->device_is_linux_dmmp)\n    goto out;\n\n  /* The Partition* properties has been set as part of\n   * update_info_partition() by reading UDISKS_PARTITION_*\n   * properties.. so here we bascially just update the presentation\n   * device file name and and whether the device is a drive.\n   */\n\n  s = g_strdup_printf (\"/dev/mapper/%s\", dm_name);\n  device_set_device_file_presentation (device, s);\n  g_free (s);\n\n  device_set_device_is_drive (device, FALSE);\n\n out:\n  g_free (params);\n  return TRUE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline void ne2000_dma_update(NE2000State *s, int len)\n{\n    s->rsar += len;\n    /* wrap */\n    /* XXX: check what to do if rsar > stop */\n    if (s->rsar == s->stop)\n        s->rsar = s->start;\n\n    if (s->rcnt <= len) {\n        s->rcnt = 0;\n        /* signal end of transfer */\n        s->isr |= ENISR_RDC;\n        ne2000_update_irq(s);\n    } else {\n        s->rcnt -= len;\n    }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static EAS_RESULT PushcdlStack (EAS_U32 *pStack, EAS_INT *pStackPtr, EAS_U32 value)\n\n {\n \n     /* stack overflow, return an error */\n    if (*pStackPtr >= CDL_STACK_SIZE)\n         return EAS_ERROR_FILE_FORMAT;\n \n     /* push the value onto the stack */\n     *pStackPtr = *pStackPtr + 1;\n    pStack[*pStackPtr] = value;\n return EAS_SUCCESS;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void LayerTreeHost::DidFailToInitializeCompositorFrameSink() {\n  DCHECK(new_compositor_frame_sink_);\n  current_compositor_frame_sink_ = nullptr;\n  new_compositor_frame_sink_ = nullptr;\n  client_->DidFailToInitializeCompositorFrameSink();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n {\tsf_count_t total = 0 ;\n \tssize_t\tcount ;\n \n \tif (psf->virtual_io)\n \t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n \n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "u32 gf_sys_clock()\n{\n\treturn OS_GetSysClock();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        break;\n    }\n    image->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n         ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n       }\n     pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length,\n       sizeof(*sun_pixels));\n     if (sun_pixels == (unsigned char *) NULL)\n       {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n            SetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n              SetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,ConstrainColormapIndex(image,*p));\n              p++;\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->matte != MagickFalse)\n            bytes_per_pixel++;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                }\n              else\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    GetPixelRed(q)].red);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    GetPixelGreen(q)].green);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    GetPixelBlue(q)].blue);\n                }\n              q++;\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void sycc420_to_rgb(opj_image_t *img)\n {\n \tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n \tconst int *y, *cb, *cr, *ny;\n\tunsigned int maxw, maxh, max;\n \tint offset, upb;\n\tunsigned int i, j;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n \n\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)\n \t{\n \t\tny = y + maxw;\n \t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n \n\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n \t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n \t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n \t\t}\n\t\tif(j < maxw)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n \t\t}\n \t\ty += maxw; r += maxw; g += maxw; b += maxw;\n \t}\n\tif(i < maxh)\n \t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t}\n\t}\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n \tfree(img->comps[1].data); img->comps[1].data = d1;\n \tfree(img->comps[2].data); img->comps[2].data = d2;\n \n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n \treturn;\n \n fails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n }/* sycc420_to_rgb() */"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int nfs_idmap_legacy_upcall(struct key_construction *cons,\n\t\t\t\t   const char *op,\n\t\t\t\t   void *aux)\n{\n\tstruct idmap_legacy_upcalldata *data;\n\tstruct rpc_pipe_msg *msg;\n\tstruct idmap_msg *im;\n\tstruct idmap *idmap = (struct idmap *)aux;\n\tstruct key *key = cons->key;\n\tint ret = -ENOMEM;\n\n\t/* msg and im are freed in idmap_pipe_destroy_msg */\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out1;\n\n\tmsg = &data->pipe_msg;\n\tim = &data->idmap_msg;\n\tdata->idmap = idmap;\n\tdata->key_cons = cons;\n\n\tret = nfs_idmap_prepare_message(key->description, idmap, im, msg);\n\tif (ret < 0)\n\t\tgoto out2;\n\n\tret = -EAGAIN;\n\tif (!nfs_idmap_prepare_pipe_upcall(idmap, data))\n\t\tgoto out2;\n\n\tret = rpc_queue_upcall(idmap->idmap_pipe, msg);\n\tif (ret < 0)\n\t\tnfs_idmap_abort_pipe_upcall(idmap, ret);\n\n\treturn ret;\nout2:\n\tkfree(data);\nout1:\n\tcomplete_request_key(cons, ret);\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool tcp_alloc_md5sig_pool(void)\n{\n\tif (unlikely(!tcp_md5sig_pool_populated)) {\n\t\tmutex_lock(&tcp_md5sig_mutex);\n\n\t\tif (!tcp_md5sig_pool_populated)\n\t\t\t__tcp_alloc_md5sig_pool();\n\n\t\tmutex_unlock(&tcp_md5sig_mutex);\n\t}\n\treturn tcp_md5sig_pool_populated;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-369"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static noinline __kprobes int vmalloc_fault(unsigned long address)\n{\n\tunsigned long pgd_paddr;\n\tpmd_t *pmd_k;\n\tpte_t *pte_k;\n\n\t/* Make sure we are in vmalloc area: */\n\tif (!(address >= VMALLOC_START && address < VMALLOC_END))\n\t\treturn -1;\n\n\tWARN_ON_ONCE(in_nmi());\n\n\t/*\n\t * Synchronize this task's top level page-table\n\t * with the 'reference' page table.\n\t *\n\t * Do _not_ use \"current\" here. We might be inside\n\t * an interrupt in the middle of a task switch..\n\t */\n\tpgd_paddr = read_cr3();\n\tpmd_k = vmalloc_sync_one(__va(pgd_paddr), address);\n\tif (!pmd_k)\n\t\treturn -1;\n\n\tpte_k = pte_offset_kernel(pmd_k, address);\n\tif (!pte_present(*pte_k))\n\t\treturn -1;\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)\n {\n     FileSystemFlags flags(options);\n    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();\n     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void handle_rc_connect (tBTA_AV_RC_OPEN *p_rc_open)\n{\n    BTIF_TRACE_DEBUG(\"%s: rc_handle: %d\", __FUNCTION__, p_rc_open->rc_handle);\n bt_status_t result = BT_STATUS_SUCCESS;\n#if (AVRC_CTLR_INCLUDED == TRUE)\n bt_bdaddr_t rc_addr;\n#endif\n\n if(p_rc_open->status == BTA_AV_SUCCESS)\n {\n if (btif_rc_cb.rc_connected)\n {\n            BTIF_TRACE_ERROR(\"Got RC OPEN in connected state, Connected RC: %d \\\n                and Current RC: %d\", btif_rc_cb.rc_handle,p_rc_open->rc_handle );\n if ((btif_rc_cb.rc_handle != p_rc_open->rc_handle)\n && (bdcmp(btif_rc_cb.rc_addr, p_rc_open->peer_addr)))\n {\n                BTIF_TRACE_DEBUG(\"Got RC connected for some other handle\");\n                BTA_AvCloseRc(p_rc_open->rc_handle);\n return;\n }\n }\n        memcpy(btif_rc_cb.rc_addr, p_rc_open->peer_addr, sizeof(BD_ADDR));\n        btif_rc_cb.rc_features = p_rc_open->peer_features;\n        btif_rc_cb.rc_vol_label=MAX_LABEL;\n        btif_rc_cb.rc_volume=MAX_VOLUME;\n\n        btif_rc_cb.rc_connected = TRUE;\n        btif_rc_cb.rc_handle = p_rc_open->rc_handle;\n\n /* on locally initiated connection we will get remote features as part of connect */\n if (btif_rc_cb.rc_features != 0)\n            handle_rc_features();\n\n        result = uinput_driver_check();\n if(result == BT_STATUS_SUCCESS)\n {\n            init_uinput();\n }\n#if (AVRC_CTLR_INCLUDED == TRUE)\n        bdcpy(rc_addr.address, btif_rc_cb.rc_addr);\n /* report connection state if device is AVRCP target */\n if (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG) {\n if (bt_rc_ctrl_callbacks != NULL) {\n                HAL_CBACK(bt_rc_ctrl_callbacks, connection_state_cb, TRUE, &rc_addr);\n }\n }\n#endif\n }\n else\n {\n        BTIF_TRACE_ERROR(\"%s Connect failed with error code: %d\",\n            __FUNCTION__, p_rc_open->status);\n        btif_rc_cb.rc_connected = FALSE;\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void ipgre_dev_free(struct net_device *dev)\n{\n\tfree_percpu(dev->tstats);\n\tfree_netdev(dev);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "R_API void r_bin_class_add_field(RBinFile *binfile, const char *classname, const char *name) {\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int perf_rotate_context(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event_context *ctx = NULL;\n\tint rotate = 0;\n\n\tif (cpuctx->ctx.nr_events) {\n\t\tif (cpuctx->ctx.nr_events != cpuctx->ctx.nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tctx = cpuctx->task_ctx;\n\tif (ctx && ctx->nr_events) {\n\t\tif (ctx->nr_events != ctx->nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tif (!rotate)\n\t\tgoto done;\n\n\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\tif (ctx)\n\t\tctx_sched_out(ctx, cpuctx, EVENT_FLEXIBLE);\n\n\trotate_ctx(&cpuctx->ctx);\n\tif (ctx)\n\t\trotate_ctx(ctx);\n\n\tperf_event_sched_in(cpuctx, ctx, current);\n\n\tperf_pmu_enable(cpuctx->ctx.pmu);\n\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\ndone:\n\n\treturn rotate;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "asmlinkage void __sched notrace preempt_schedule(void)\n{\n\t/*\n\t * If there is a non-zero preempt_count or interrupts are disabled,\n\t * we do not want to preempt the current task. Just return..\n\t */\n\tif (likely(!preemptible()))\n\t\treturn;\n\n\tdo {\n\t\t__preempt_count_add(PREEMPT_ACTIVE);\n\t\t__schedule();\n\t\t__preempt_count_sub(PREEMPT_ACTIVE);\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t\tbarrier();\n\t} while (need_resched());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "const gfx::Transform& LayerTreeHostImpl::DrawTransform() const {\n  return external_transform_;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Response StorageHandler::TrackCacheStorageForOrigin(const std::string& origin) {\n  if (!process_)\n     return Response::InternalError();\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid())\n    return Response::InvalidParams(origin + \" is not a valid URL\");\n\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::BindOnce(&CacheStorageObserver::TrackOriginOnIOThread,\n                     base::Unretained(GetCacheStorageObserver()),\n                     url::Origin::Create(origin_url)));\n  return Response::OK();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "on_register_handler(TCMUService1HandlerManager1 *interface,\n\t\t    GDBusMethodInvocation *invocation,\n\t\t    gchar *subtype,\n\t\t    gchar *cfg_desc,\n\t\t    gpointer user_data)\n{\n\tstruct tcmur_handler *handler;\n\tstruct dbus_info *info;\n\tchar *bus_name;\n\n\tbus_name = g_strdup_printf(\"org.kernel.TCMUService1.HandlerManager1.%s\",\n\t\t\t\t   subtype);\n\n\thandler               = g_new0(struct tcmur_handler, 1);\n\thandler->subtype      = g_strdup(subtype);\n\thandler->cfg_desc     = g_strdup(cfg_desc);\n\thandler->open         = dbus_handler_open;\n\thandler->close        = dbus_handler_close;\n \thandler->handle_cmd   = dbus_handler_handle_cmd;\n \n \tinfo = g_new0(struct dbus_info, 1);\n \tinfo->register_invocation = invocation;\n \tinfo->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,\n \t\t\t\t\t    bus_name,\n\t\t\t\t\t    G_BUS_NAME_WATCHER_FLAGS_NONE,\n\t\t\t\t\t    on_handler_appeared,\n\t\t\t\t\t    on_handler_vanished,\n\t\t\t\t\t    handler,\n\t\t\t\t\t    NULL);\n\tg_free(bus_name);\n\thandler->opaque = info;\n\treturn TRUE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "CatalogueRescan (FontPathElementPtr fpe)\n{\n    CataloguePtr\tcat = fpe->private;\n    char\t\tlink[MAXFONTFILENAMELEN];\n    char\t\tdest[MAXFONTFILENAMELEN];\n    char\t\t*attrib;\n    FontPathElementPtr\tsubfpe;\n    struct stat\t\tstatbuf;\n    const char\t\t*path;\n    DIR\t\t\t*dir;\n    struct dirent\t*entry;\n    int\t\t\tlen;\n    int\t\t\tpathlen;\n\n    path = fpe->name + strlen(CataloguePrefix);\n    if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))\n\treturn BadFontPath;\n\n    if (statbuf.st_mtime <= cat->mtime)\n\treturn Successful;\n\n    dir = opendir(path);\n    if (dir == NULL)\n    {\n\txfree(cat);\n\treturn BadFontPath;\n    }\n\n    CatalogueUnrefFPEs (fpe);\n     while (entry = readdir(dir), entry != NULL)\n     {\n \tsnprintf(link, sizeof link, \"%s/%s\", path, entry->d_name);\n\tlen = readlink(link, dest, sizeof dest);\n \tif (len < 0)\n \t    continue;\n\tdest[len] = '\\0';\n\n\tif (dest[0] != '/')\n\t{\n\t   pathlen = strlen(path);\n\t   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);\n\t   memcpy(dest, path, pathlen);\n\t   memcpy(dest + pathlen, \"/\", 1);\n\t   len += pathlen + 1;\n\t}\n\n\tattrib = strchr(link, ':');\n\tif (attrib && len + strlen(attrib) < sizeof dest)\n\t{\n\t    memcpy(dest + len, attrib, strlen(attrib));\n\t    len += strlen(attrib);\n\t}\n\n\tsubfpe = xalloc(sizeof *subfpe);\n\tif (subfpe == NULL)\n\t    continue;\n\n\t/* The fonts returned by OpenFont will point back to the\n\t * subfpe they come from.  So set the type of the subfpe to\n\t * what the catalogue fpe was assigned, so calls to CloseFont\n\t * (which uses font->fpe->type) goes to CatalogueCloseFont. */\n\tsubfpe->type = fpe->type;\n\tsubfpe->name_length = len;\n\tsubfpe->name = xalloc (len + 1);\n\tif (subfpe == NULL)\n\t{\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tmemcpy(subfpe->name, dest, len);\n\tsubfpe->name[len] = '\\0';\n\n\t/* The X server will manipulate the subfpe ref counts\n\t * associated with the font in OpenFont and CloseFont, so we\n\t * have to make sure it's valid. */\n\tsubfpe->refcount = 1;\n\n\tif (FontFileInitFPE (subfpe) != Successful)\n\t{\n\t    xfree(subfpe->name);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n\n\tif (CatalogueAddFPE(cat, subfpe) != Successful)\n\t{\n\t    FontFileFreeFPE (subfpe);\n\t    xfree(subfpe);\n\t    continue;\n\t}\n    }\n\n    closedir(dir);\n\n    qsort(cat->fpeList,\n\t  cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);\n\n    cat->mtime = statbuf.st_mtime;\n\n    return Successful;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PlatformSensor::PlatformSensor(mojom::SensorType type,\n                               mojo::ScopedSharedBufferMapping mapping,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n      shared_buffer_mapping_(std::move(mapping)),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-732"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static unsigned long kvm_get_guest_ip(void)\n{\n\tunsigned long ip = 0;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tip = kvm_rip_read(__this_cpu_read(current_vcpu));\n\n\treturn ip;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool AddFilter(const std::string& event_name,\n               const std::string& extension_id,\n               const base::DictionaryValue& filter) {\n  FilteredEventListenerKey key(extension_id, event_name);\n  FilteredEventListenerCounts& all_counts = g_filtered_listener_counts.Get();\n  FilteredEventListenerCounts::const_iterator counts = all_counts.find(key);\n  if (counts == all_counts.end()) {\n    counts =\n        all_counts\n            .insert(std::make_pair(key, base::WrapUnique(new ValueCounter())))\n            .first;\n  }\n  return counts->second->Add(filter);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Document::ClearFocusedElementSoon() {\n  if (!clear_focused_element_timer_.IsActive())\n    clear_focused_element_timer_.StartOneShot(TimeDelta(), FROM_HERE);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,\n                      gcry_mpi_t r, gcry_mpi_t s,\n                      int flags, int hashalgo)\n{\n  gpg_err_code_t rc = 0;\n  int extraloops = 0;\n  gcry_mpi_t k, dr, sum, k_1, x;\n  mpi_point_struct I;\n  gcry_mpi_t hash;\n   const void *abuf;\n   unsigned int abits, qbits;\n   mpi_ec_t ctx;\n \n   if (DBG_CIPHER)\n     log_mpidump (\"ecdsa sign hash  \", input );\n\n  /* Convert the INPUT into an MPI if needed.  */\n  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);\n  if (rc)\n    return rc;\n   if (rc)\n     return rc;\n \n   k = NULL;\n   dr = mpi_alloc (0);\n   sum = mpi_alloc (0);\n    {\n      do\n        {\n          mpi_free (k);\n          k = NULL;\n          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)\n            {\n              /* Use Pornin's method for deterministic DSA.  If this\n                 flag is set, it is expected that HASH is an opaque\n                 MPI with the to be signed hash.  That hash is also\n                 used as h1 from 3.2.a.  */\n              if (!mpi_is_opaque (input))\n                {\n                  rc = GPG_ERR_CONFLICT;\n                  goto leave;\n                }\n\n              abuf = mpi_get_opaque (input, &abits);\n              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,\n                                            abuf, (abits+7)/8,\n                                            hashalgo, extraloops);\n              if (rc)\n                goto leave;\n              extraloops++;\n            }\n          else\n            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);\n\n          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);\n          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))\n            {\n              if (DBG_CIPHER)\n                log_debug (\"ecc sign: Failed to get affine coordinates\\n\");\n              rc = GPG_ERR_BAD_SIGNATURE;\n              goto leave;\n            }\n          mpi_mod (r, x, skey->E.n);  /* r = x mod n */\n        }\n      while (!mpi_cmp_ui (r, 0));\n\n      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */\n      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */\n      mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */\n      mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */\n    }\n  while (!mpi_cmp_ui (s, 0));\n\n  if (DBG_CIPHER)\n         }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int midi_setup_portprefix(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_portprefix;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Verify_MakeGroupObsolete() {\n    EXPECT_TRUE(delegate()->obsoleted_success_);\n    EXPECT_EQ(group_.get(), delegate()->obsoleted_group_.get());\n    EXPECT_TRUE(group_->is_obsolete());\n    EXPECT_TRUE(storage()->usage_map_.empty());\n\n    AppCacheDatabase::GroupRecord group_record;\n    AppCacheDatabase::CacheRecord cache_record;\n    EXPECT_FALSE(database()->FindGroup(1, &group_record));\n    EXPECT_FALSE(database()->FindCache(1, &cache_record));\n\n    std::vector<AppCacheDatabase::EntryRecord> entry_records;\n    database()->FindEntriesForCache(1, &entry_records);\n    EXPECT_TRUE(entry_records.empty());\n    std::vector<AppCacheDatabase::NamespaceRecord> intercept_records;\n    std::vector<AppCacheDatabase::NamespaceRecord> fallback_records;\n    database()->FindNamespacesForCache(1, &intercept_records,\n                                       &fallback_records);\n    EXPECT_TRUE(fallback_records.empty());\n    std::vector<AppCacheDatabase::OnlineWhiteListRecord> whitelist_records;\n    database()->FindOnlineWhiteListForCache(1, &whitelist_records);\n    EXPECT_TRUE(whitelist_records.empty());\n\n     EXPECT_TRUE(storage()->usage_map_.empty());\n     EXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);\n     EXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);\n    EXPECT_EQ(-kDefaultEntrySize, mock_quota_manager_proxy_->last_delta_);\n \n     TestFinished();\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool WebRtcAudioRenderer::Initialize(WebRtcAudioRendererSource* source) {\n  base::AutoLock auto_lock(lock_);\n  DCHECK_EQ(state_, UNINITIALIZED);\n  DCHECK(source);\n  DCHECK(!sink_);\n  DCHECK(!source_);\n\n  sink_ = AudioDeviceFactory::NewOutputDevice();\n  DCHECK(sink_);\n\n  int sample_rate = GetAudioOutputSampleRate();\n  DVLOG(1) << \"Audio output hardware sample rate: \" << sample_rate;\n  UMA_HISTOGRAM_ENUMERATION(\"WebRTC.AudioOutputSampleRate\",\n                            sample_rate, media::kUnexpectedAudioSampleRate);\n\n  if (std::find(&kValidOutputRates[0],\n                &kValidOutputRates[0] + arraysize(kValidOutputRates),\n                sample_rate) ==\n                    &kValidOutputRates[arraysize(kValidOutputRates)]) {\n    DLOG(ERROR) << sample_rate << \" is not a supported output rate.\";\n    return false;\n  }\n\n  media::ChannelLayout channel_layout = media::CHANNEL_LAYOUT_STEREO;\n\n  int buffer_size = 0;\n\n#if defined(OS_WIN)\n  channel_layout = media::CHANNEL_LAYOUT_STEREO;\n\n\n  if (sample_rate == 96000 || sample_rate == 48000) {\n    buffer_size = (sample_rate / 100);\n  } else {\n    buffer_size = 2 * 440;\n  }\n\n  if (base::win::GetVersion() < base::win::VERSION_VISTA) {\n    buffer_size = 3 * buffer_size;\n    DLOG(WARNING) << \"Extending the output buffer size by a factor of three \"\n                  << \"since Windows XP has been detected.\";\n  }\n#elif defined(OS_MACOSX)\n  channel_layout = media::CHANNEL_LAYOUT_MONO;\n \n \n  if (sample_rate == 48000) {\n    buffer_size = 480;\n   } else {\n    buffer_size = 440;\n  }\n#elif defined(OS_LINUX) || defined(OS_OPENBSD)\n  channel_layout = media::CHANNEL_LAYOUT_MONO;\n\n  buffer_size = 480;\n#else\n  DLOG(ERROR) << \"Unsupported platform\";\n  return false;\n#endif\n\n  params_.Reset(media::AudioParameters::AUDIO_PCM_LOW_LATENCY, channel_layout,\n                sample_rate, 16, buffer_size);\n\n  buffer_.reset(new int16[params_.frames_per_buffer() * params_.channels()]);\n\n  source_ = source;\n  source->SetRenderFormat(params_);\n\n  sink_->Initialize(params_, this);\n  sink_->SetSourceRenderView(source_render_view_id_);\n  sink_->Start();\n\n  state_ = PAUSED;\n\n  UMA_HISTOGRAM_ENUMERATION(\"WebRTC.AudioOutputChannelLayout\",\n                            channel_layout, media::CHANNEL_LAYOUT_MAX);\n  UMA_HISTOGRAM_ENUMERATION(\"WebRTC.AudioOutputFramesPerBuffer\",\n                            buffer_size, kUnexpectedAudioBufferSize);\n  AddHistogramFramesPerBuffer(buffer_size);\n\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "GBool isOk() { return data != NULL; }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Resource* ResourceFetcher::MatchPreload(const FetchParameters& params,\n                                        Resource::Type type) {\n  auto it = preloads_.find(PreloadKey(params.Url(), type));\n  if (it == preloads_.end())\n    return nullptr;\n\n  Resource* resource = it->value;\n\n  if (resource->MustRefetchDueToIntegrityMetadata(params))\n    return nullptr;\n\n  if (params.IsSpeculativePreload())\n    return resource;\n  if (params.IsLinkPreload()) {\n    resource->SetLinkPreload(true);\n    return resource;\n  }\n\n  const ResourceRequest& request = params.GetResourceRequest();\n  if (request.DownloadToFile())\n    return nullptr;\n\n  if (IsImageResourceDisallowedToBeReused(*resource) ||\n      !resource->CanReuse(params))\n    return nullptr;\n\n  if (!resource->MatchPreload(params, Context().GetLoadingTaskRunner().get()))\n    return nullptr;\n  preloads_.erase(it);\n  matched_preloads_.push_back(resource);\n  return resource;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "seamless_send_sync()\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"SYNC\", \"\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "WebMediaPlayer::CORSMode HTMLMediaElement::CorsMode() const {\n  const AtomicString& cross_origin_mode = FastGetAttribute(crossoriginAttr);\n  if (cross_origin_mode.IsNull())\n    return WebMediaPlayer::kCORSModeUnspecified;\n  if (DeprecatedEqualIgnoringCase(cross_origin_mode, \"use-credentials\"))\n    return WebMediaPlayer::kCORSModeUseCredentials;\n  return WebMediaPlayer::kCORSModeAnonymous;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-732"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void enumAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    TestObjectV8Internal::enumAttrAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void ndisc_router_discovery(struct sk_buff *skb)\n{\n\tstruct ra_msg *ra_msg = (struct ra_msg *)skb_transport_header(skb);\n\tstruct neighbour *neigh = NULL;\n\tstruct inet6_dev *in6_dev;\n\tstruct rt6_info *rt = NULL;\n\tint lifetime;\n\tstruct ndisc_options ndopts;\n\tint optlen;\n\tunsigned int pref = 0;\n\n\t__u8 *opt = (__u8 *)(ra_msg + 1);\n\n\toptlen = (skb_tail_pointer(skb) - skb_transport_header(skb)) -\n\t\tsizeof(struct ra_msg);\n\n\tND_PRINTK(2, info,\n\t\t  \"RA: %s, dev: %s\\n\",\n\t\t  __func__, skb->dev->name);\n\tif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {\n\t\tND_PRINTK(2, warn, \"RA: source address is not link-local\\n\");\n\t\treturn;\n\t}\n\tif (optlen < 0) {\n\t\tND_PRINTK(2, warn, \"RA: packet too short\\n\");\n\t\treturn;\n\t}\n\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\tif (skb->ndisc_nodetype == NDISC_NODETYPE_HOST) {\n\t\tND_PRINTK(2, warn, \"RA: from host or unauthorized router\\n\");\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t *\tset the RA_RECV flag in the interface\n\t */\n\n\tin6_dev = __in6_dev_get(skb->dev);\n\tif (in6_dev == NULL) {\n\t\tND_PRINTK(0, err, \"RA: can't find inet6 device for %s\\n\",\n\t\t\t  skb->dev->name);\n\t\treturn;\n\t}\n\n\tif (!ndisc_parse_options(opt, optlen, &ndopts)) {\n\t\tND_PRINTK(2, warn, \"RA: invalid ND options\\n\");\n\t\treturn;\n\t}\n\n\tif (!ipv6_accept_ra(in6_dev)) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, did not accept ra for dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto skip_linkparms;\n\t}\n\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\t/* skip link-specific parameters from interior routers */\n\tif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, nodetype is NODEFAULT, dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto skip_linkparms;\n\t}\n#endif\n\n\tif (in6_dev->if_flags & IF_RS_SENT) {\n\t\t/*\n\t\t *\tflag that an RA was received after an RS was sent\n\t\t *\tout on this interface.\n\t\t */\n\t\tin6_dev->if_flags |= IF_RA_RCVD;\n\t}\n\n\t/*\n\t * Remember the managed/otherconf flags from most recently\n\t * received RA message (RFC 2462) -- yoshfuji\n\t */\n\tin6_dev->if_flags = (in6_dev->if_flags & ~(IF_RA_MANAGED |\n\t\t\t\tIF_RA_OTHERCONF)) |\n\t\t\t\t(ra_msg->icmph.icmp6_addrconf_managed ?\n\t\t\t\t\tIF_RA_MANAGED : 0) |\n\t\t\t\t(ra_msg->icmph.icmp6_addrconf_other ?\n\t\t\t\t\tIF_RA_OTHERCONF : 0);\n\n\tif (!in6_dev->cnf.accept_ra_defrtr) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, defrtr is false for dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto skip_defrtr;\n\t}\n\n\t/* Do not accept RA with source-addr found on local machine unless\n\t * accept_ra_from_local is set to true.\n\t */\n\tif (!in6_dev->cnf.accept_ra_from_local &&\n\t    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,\n\t\t\t  NULL, 0)) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA from local address detected on dev: %s: default router ignored\\n\",\n\t\t\t  skb->dev->name);\n\t\tgoto skip_defrtr;\n\t}\n\n\tlifetime = ntohs(ra_msg->icmph.icmp6_rt_lifetime);\n\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tpref = ra_msg->icmph.icmp6_router_pref;\n\t/* 10b is handled as if it were 00b (medium) */\n\tif (pref == ICMPV6_ROUTER_PREF_INVALID ||\n\t    !in6_dev->cnf.accept_ra_rtr_pref)\n\t\tpref = ICMPV6_ROUTER_PREF_MEDIUM;\n#endif\n\n\trt = rt6_get_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev);\n\n\tif (rt) {\n\t\tneigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);\n\t\tif (!neigh) {\n\t\t\tND_PRINTK(0, err,\n\t\t\t\t  \"RA: %s got default router without neighbour\\n\",\n\t\t\t\t  __func__);\n\t\t\tip6_rt_put(rt);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (rt && lifetime == 0) {\n\t\tip6_del_rt(rt);\n\t\trt = NULL;\n\t}\n\n\tND_PRINTK(3, info, \"RA: rt: %p  lifetime: %d, for dev: %s\\n\",\n\t\t  rt, lifetime, skb->dev->name);\n\tif (rt == NULL && lifetime) {\n\t\tND_PRINTK(3, info, \"RA: adding default router\\n\");\n\n\t\trt = rt6_add_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev, pref);\n\t\tif (rt == NULL) {\n\t\t\tND_PRINTK(0, err,\n\t\t\t\t  \"RA: %s failed to add default route\\n\",\n\t\t\t\t  __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tneigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);\n\t\tif (neigh == NULL) {\n\t\t\tND_PRINTK(0, err,\n\t\t\t\t  \"RA: %s got default router without neighbour\\n\",\n\t\t\t\t  __func__);\n\t\t\tip6_rt_put(rt);\n\t\t\treturn;\n\t\t}\n\t\tneigh->flags |= NTF_ROUTER;\n\t} else if (rt) {\n\t\trt->rt6i_flags = (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);\n\t}\n\n \tif (rt)\n \t\trt6_set_expires(rt, jiffies + (HZ * lifetime));\n \tif (ra_msg->icmph.icmp6_hop_limit) {\n\t\tin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\n \t\tif (rt)\n \t\t\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT,\n \t\t\t\t       ra_msg->icmph.icmp6_hop_limit);\n\t}\n\nskip_defrtr:\n\n\t/*\n\t *\tUpdate Reachable Time and Retrans Timer\n\t */\n\n\tif (in6_dev->nd_parms) {\n\t\tunsigned long rtime = ntohl(ra_msg->retrans_timer);\n\n\t\tif (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/HZ) {\n\t\t\trtime = (rtime*HZ)/1000;\n\t\t\tif (rtime < HZ/10)\n\t\t\t\trtime = HZ/10;\n\t\t\tNEIGH_VAR_SET(in6_dev->nd_parms, RETRANS_TIME, rtime);\n\t\t\tin6_dev->tstamp = jiffies;\n\t\t\tinet6_ifinfo_notify(RTM_NEWLINK, in6_dev);\n\t\t}\n\n\t\trtime = ntohl(ra_msg->reachable_time);\n\t\tif (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/(3*HZ)) {\n\t\t\trtime = (rtime*HZ)/1000;\n\n\t\t\tif (rtime < HZ/10)\n\t\t\t\trtime = HZ/10;\n\n\t\t\tif (rtime != NEIGH_VAR(in6_dev->nd_parms, BASE_REACHABLE_TIME)) {\n\t\t\t\tNEIGH_VAR_SET(in6_dev->nd_parms,\n\t\t\t\t\t      BASE_REACHABLE_TIME, rtime);\n\t\t\t\tNEIGH_VAR_SET(in6_dev->nd_parms,\n\t\t\t\t\t      GC_STALETIME, 3 * rtime);\n\t\t\t\tin6_dev->nd_parms->reachable_time = neigh_rand_reach_time(rtime);\n\t\t\t\tin6_dev->tstamp = jiffies;\n\t\t\t\tinet6_ifinfo_notify(RTM_NEWLINK, in6_dev);\n\t\t\t}\n\t\t}\n\t}\n\nskip_linkparms:\n\n\t/*\n\t *\tProcess options.\n\t */\n\n\tif (!neigh)\n\t\tneigh = __neigh_lookup(&nd_tbl, &ipv6_hdr(skb)->saddr,\n\t\t\t\t       skb->dev, 1);\n\tif (neigh) {\n\t\tu8 *lladdr = NULL;\n\t\tif (ndopts.nd_opts_src_lladdr) {\n\t\t\tlladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr,\n\t\t\t\t\t\t     skb->dev);\n\t\t\tif (!lladdr) {\n\t\t\t\tND_PRINTK(2, warn,\n\t\t\t\t\t  \"RA: invalid link-layer address length\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tneigh_update(neigh, lladdr, NUD_STALE,\n\t\t\t     NEIGH_UPDATE_F_WEAK_OVERRIDE|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE_ISROUTER|\n\t\t\t     NEIGH_UPDATE_F_ISROUTER);\n\t}\n\n\tif (!ipv6_accept_ra(in6_dev)) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, accept_ra is false for dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\tif (!in6_dev->cnf.accept_ra_from_local &&\n\t    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,\n\t\t\t  NULL, 0)) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA from local address detected on dev: %s: router info ignored.\\n\",\n\t\t\t  skb->dev->name);\n\t\tgoto skip_routeinfo;\n\t}\n\n\tif (in6_dev->cnf.accept_ra_rtr_pref && ndopts.nd_opts_ri) {\n\t\tstruct nd_opt_hdr *p;\n\t\tfor (p = ndopts.nd_opts_ri;\n\t\t     p;\n\t\t     p = ndisc_next_option(p, ndopts.nd_opts_ri_end)) {\n\t\t\tstruct route_info *ri = (struct route_info *)p;\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\t\t\tif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT &&\n\t\t\t    ri->prefix_len == 0)\n\t\t\t\tcontinue;\n#endif\n\t\t\tif (ri->prefix_len == 0 &&\n\t\t\t    !in6_dev->cnf.accept_ra_defrtr)\n\t\t\t\tcontinue;\n\t\t\tif (ri->prefix_len > in6_dev->cnf.accept_ra_rt_info_max_plen)\n\t\t\t\tcontinue;\n\t\t\trt6_route_rcv(skb->dev, (u8 *)p, (p->nd_opt_len) << 3,\n\t\t\t\t      &ipv6_hdr(skb)->saddr);\n\t\t}\n\t}\n\nskip_routeinfo:\n#endif\n\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\t/* skip link-specific ndopts from interior routers */\n\tif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, nodetype is NODEFAULT (interior routes), dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto out;\n\t}\n#endif\n\n\tif (in6_dev->cnf.accept_ra_pinfo && ndopts.nd_opts_pi) {\n\t\tstruct nd_opt_hdr *p;\n\t\tfor (p = ndopts.nd_opts_pi;\n\t\t     p;\n\t\t     p = ndisc_next_option(p, ndopts.nd_opts_pi_end)) {\n\t\t\taddrconf_prefix_rcv(skb->dev, (u8 *)p,\n\t\t\t\t\t    (p->nd_opt_len) << 3,\n\t\t\t\t\t    ndopts.nd_opts_src_lladdr != NULL);\n\t\t}\n\t}\n\n\tif (ndopts.nd_opts_mtu && in6_dev->cnf.accept_ra_mtu) {\n\t\t__be32 n;\n\t\tu32 mtu;\n\n\t\tmemcpy(&n, ((u8 *)(ndopts.nd_opts_mtu+1))+2, sizeof(mtu));\n\t\tmtu = ntohl(n);\n\n\t\tif (mtu < IPV6_MIN_MTU || mtu > skb->dev->mtu) {\n\t\t\tND_PRINTK(2, warn, \"RA: invalid mtu: %d\\n\", mtu);\n\t\t} else if (in6_dev->cnf.mtu6 != mtu) {\n\t\t\tin6_dev->cnf.mtu6 = mtu;\n\n\t\t\tif (rt)\n\t\t\t\tdst_metric_set(&rt->dst, RTAX_MTU, mtu);\n\n\t\t\trt6_mtu_change(skb->dev, mtu);\n\t\t}\n\t}\n\n\tif (ndopts.nd_useropts) {\n\t\tstruct nd_opt_hdr *p;\n\t\tfor (p = ndopts.nd_useropts;\n\t\t     p;\n\t\t     p = ndisc_next_useropt(p, ndopts.nd_useropts_end)) {\n\t\t\tndisc_ra_useropt(skb, p);\n\t\t}\n\t}\n\n\tif (ndopts.nd_opts_tgt_lladdr || ndopts.nd_opts_rh) {\n\t\tND_PRINTK(2, warn, \"RA: invalid RA options\\n\");\n\t}\nout:\n\tip6_rt_put(rt);\n\tif (neigh)\n\t\tneigh_release(neigh);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-17"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n \tuint8_t *argb;\n \tint x, y;\n \tuint8_t *p;\n \tuint8_t *out;\n \tsize_t out_size;\n \n \tif (im == NULL) {\n\t\treturn;\n \t}\n \n \tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n \t}\n \n \tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \n \tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n \t}\n \n \tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n \t}\n \n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n\t\treturn;\n \t}\n \tp = argb;\n \tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n \tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n \tif (out_size == 0) {\n \t\tgd_error(\"gd-webp encoding failed\");\n \t\tgoto freeargb;\n \t}\n \tgdPutBuf(out, out_size, outfile);\n \tfree(out);\n \n freeargb:\n \tgdFree(argb);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-415"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n                                                float source_sample_rate) {\n   if (number_of_channels != source_number_of_channels_ ||\n       source_sample_rate != source_sample_rate_) {\n     if (!number_of_channels ||\n        number_of_channels > BaseAudioContext::MaxNumberOfChannels() ||\n        !AudioUtilities::IsValidAudioBufferSampleRate(source_sample_rate)) {\n      DLOG(ERROR) << \"setFormat(\" << number_of_channels << \", \"\n                  << source_sample_rate << \") - unhandled format change\";\n       Locker<MediaElementAudioSourceHandler> locker(*this);\n       source_number_of_channels_ = 0;\n       source_sample_rate_ = 0;\n       return;\n     }\n \n     Locker<MediaElementAudioSourceHandler> locker(*this);\n \n     source_number_of_channels_ = number_of_channels;\n     source_sample_rate_ = source_sample_rate;\n \n    if (source_sample_rate != Context()->sampleRate()) {\n      double scale_factor = source_sample_rate / Context()->sampleRate();\n      multi_channel_resampler_ = std::make_unique<MultiChannelResampler>(\n          scale_factor, number_of_channels);\n    } else {\n      multi_channel_resampler_.reset();\n    }\n\n    {\n      BaseAudioContext::GraphAutoLocker context_locker(Context());\n\n      Output(0).SetNumberOfChannels(number_of_channels);\n    }\n   }\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virConnectDomainXMLFromNative(virConnectPtr conn,\n                              const char *nativeFormat,\n                              const char *nativeConfig,\n                              unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, format=%s, config=%s, flags=%x\",\n              conn, NULLSTR(nativeFormat), NULLSTR(nativeConfig), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    virCheckNonNullArgGoto(nativeFormat, error);\n    virCheckNonNullArgGoto(nativeConfig, error);\n\n    if (conn->driver->connectDomainXMLFromNative) {\n        char *ret;\n        ret = conn->driver->connectDomainXMLFromNative(conn,\n                                                       nativeFormat,\n                                                       nativeConfig,\n                                                       flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "INST_HANDLER (las) {\t// LAS Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,|,\", d);\t\t\t\t// 0: (Z) | Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Block::Lacing Block::GetLacing() const\n{\n    const int value = int(m_flags & 0x06) >> 1;\n    return static_cast<Lacing>(value);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static journal_t *ext4_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\tBUG_ON(!ext4_has_feature_journal(sb));\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext4_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text4_msg(sb, KERN_ERR, \"no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text4_msg(sb, KERN_ERR, \"journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %lld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text4_msg(sb, KERN_ERR, \"invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = jbd2_journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"Could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int getWidth() { return w; }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PHPAPI void php_pcre_match_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *return_value,\n\tzval *subpats, int global, int use_flags, long flags, long start_offset TSRMLS_DC)\n{\n\tzval\t\t\t*result_set,\t\t/* Holds a set of subpatterns after\n\t\t\t\t\t\t\t\t\t\t   a global match */\n\t\t\t\t   **match_sets = NULL;\t/* An array of sets of matches for each\n\t\t\t\t\t\t\t\t\t\t   subpattern after a global match */\n\tpcre_extra\t\t*extra = pce->extra;/* Holds results of studying */\n\tpcre_extra\t\t extra_data;\t\t/* Used locally for exec options */\n\tint\t\t\t\t exoptions = 0;\t\t/* Execution options */\n\tint\t\t\t\t count = 0;\t\t\t/* Count of matched subpatterns */\n\tint\t\t\t\t*offsets;\t\t\t/* Array of subpattern offsets */\n\tint\t\t\t\t num_subpats;\t\t/* Number of captured subpatterns */\n\tint\t\t\t\t size_offsets;\t\t/* Size of the offsets array */\n\tint\t\t\t\t matched;\t\t\t/* Has anything matched */\n\tint\t\t\t\t g_notempty = 0;\t/* If the match should not be empty */\n\tconst char\t   **stringlist;\t\t/* Holds list of subpatterns */\n\tchar \t\t   **subpat_names;\t\t/* Array for named subpatterns */\n\tint\t\t\t\t i, rc;\n\tint\t\t\t\t subpats_order;\t\t/* Order of subpattern matches */\n\tint\t\t\t\t offset_capture;    /* Capture match offsets: yes/no */\n\n\t/* Overwrite the passed-in value for subpatterns with an empty array. */\n\tif (subpats != NULL) {\n\t\tzval_dtor(subpats);\n\t\tarray_init(subpats);\n\t}\n\n\tsubpats_order = global ? PREG_PATTERN_ORDER : 0;\n\n\tif (use_flags) {\n\t\toffset_capture = flags & PREG_OFFSET_CAPTURE;\n\n\t\t/*\n\t\t * subpats_order is pre-set to pattern mode so we change it only if\n\t\t * necessary.\n\t\t */\n\t\tif (flags & 0xff) {\n\t\t\tsubpats_order = flags & 0xff;\n\t\t}\n\t\tif ((global && (subpats_order < PREG_PATTERN_ORDER || subpats_order > PREG_SET_ORDER)) ||\n\t\t\t(!global && subpats_order != 0)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid flags specified\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\toffset_capture = 0;\n\t}\n\n\t/* Negative offset counts from the end of the string. */\n\tif (start_offset < 0) {\n\t\tstart_offset = subject_len + start_offset;\n\t\tif (start_offset < 0) {\n\t\t\tstart_offset = 0;\n\t\t}\n\t}\n\n\tif (extra == NULL) {\n\t\textra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;\n\t\textra = &extra_data;\n\t}\n\textra->match_limit = PCRE_G(backtrack_limit);\n\textra->match_limit_recursion = PCRE_G(recursion_limit);\n\n\t/* Calculate the size of the offsets array, and allocate memory for it. */\n\trc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &num_subpats);\n\tif (rc < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Internal pcre_fullinfo() error %d\", rc);\n\t\tRETURN_FALSE;\n\t}\n\tnum_subpats++;\n\tsize_offsets = num_subpats * 3;\n\n\t/*\n\t * Build a mapping from subpattern numbers to their names. We will always\n\t * allocate the table, even though there may be no named subpatterns. This\n\t * avoids somewhat more complicated logic in the inner loops.\n\t */\n\tsubpat_names = make_subpats_table(num_subpats, pce TSRMLS_CC);\n\tif (!subpat_names) {\n\t\tRETURN_FALSE;\n        }\n \n        offsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);\n        /* Allocate match sets array and initialize the values. */\n        if (global && subpats && subpats_order == PREG_PATTERN_ORDER) {\n                match_sets = (zval **)safe_emalloc(num_subpats, sizeof(zval *), 0);\n\t\tfor (i=0; i<num_subpats; i++) {\n\t\t\tALLOC_ZVAL(match_sets[i]);\n\t\t\tarray_init(match_sets[i]);\n\t\t\tINIT_PZVAL(match_sets[i]);\n\t\t}\n\t}\n\n\tmatched = 0;\n\tPCRE_G(error_code) = PHP_PCRE_NO_ERROR;\n\t\n\tdo {\n\t\t/* Execute the regular expression. */\n\t\tcount = pcre_exec(pce->re, extra, subject, subject_len, start_offset,\n\t\t\t\t\t\t  exoptions|g_notempty, offsets, size_offsets);\n\n\t\t/* the string was already proved to be valid UTF-8 */\n\t\texoptions |= PCRE_NO_UTF8_CHECK;\n\n\t\t/* Check for too many substrings condition. */\n\t\tif (count == 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Matched, but too many substrings\");\n\t\t\tcount = size_offsets/3;\n\t\t}\n\n\t\t/* If something has matched */\n\t\tif (count > 0) {\n\t\t\tmatched++;\n\n\t\t\t/* If subpatterns array has been passed, fill it in with values. */\n\t\t\tif (subpats != NULL) {\n\t\t\t\t/* Try to get the list of substrings and display a warning if failed. */\n\t\t\t\tif (pcre_get_substring_list(subject, offsets, count, &stringlist) < 0) {\n\t\t\t\t\tefree(subpat_names);\n\t\t\t\t\tefree(offsets);\n\t\t\t\t\tif (match_sets) efree(match_sets);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Get subpatterns list failed\");\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (global) {\t/* global pattern matching */\n\t\t\t\t\tif (subpats && subpats_order == PREG_PATTERN_ORDER) {\n\t\t\t\t\t\t/* For each subpattern, insert it into the appropriate array. */\n\t\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\t\tif (offset_capture) {\n\t\t\t\t\t\t\t\tadd_offset_pair(match_sets[i], (char *)stringlist[i],\n\t\t\t\t\t\t\t\t\t\t\t\toffsets[(i<<1)+1] - offsets[i<<1], offsets[i<<1], NULL);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tadd_next_index_stringl(match_sets[i], (char *)stringlist[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   offsets[(i<<1)+1] - offsets[i<<1], 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If the number of captured subpatterns on this run is\n\t\t\t\t\t\t * less than the total possible number, pad the result\n\t\t\t\t\t\t * arrays with empty strings.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (count < num_subpats) {\n\t\t\t\t\t\t\tfor (; i < num_subpats; i++) {\n\t\t\t\t\t\t\t\tadd_next_index_string(match_sets[i], \"\", 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Allocate the result set array */\n\t\t\t\t\t\tALLOC_ZVAL(result_set);\n\t\t\t\t\t\tarray_init(result_set);\n\t\t\t\t\t\tINIT_PZVAL(result_set);\n\t\t\t\t\t\t\n\t\t\t\t\t\t/* Add all the subpatterns to it */\n\t\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\t\tif (offset_capture) {\n\t\t\t\t\t\t\t\tadd_offset_pair(result_set, (char *)stringlist[i],\n\t\t\t\t\t\t\t\t\t\t\t\toffsets[(i<<1)+1] - offsets[i<<1], offsets[i<<1], subpat_names[i]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (subpat_names[i]) {\n\t\t\t\t\t\t\t\t\tadd_assoc_stringl(result_set, subpat_names[i], (char *)stringlist[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   offsets[(i<<1)+1] - offsets[i<<1], 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tadd_next_index_stringl(result_set, (char *)stringlist[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   offsets[(i<<1)+1] - offsets[i<<1], 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* And add it to the output array */\n\t\t\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(subpats), &result_set, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t} else {\t\t\t/* single pattern matching */\n\t\t\t\t\t/* For each subpattern, insert it into the subpatterns array. */\n\t\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t\tif (offset_capture) {\n\t\t\t\t\t\t\tadd_offset_pair(subpats, (char *)stringlist[i],\n\t\t\t\t\t\t\t\t\t\t\toffsets[(i<<1)+1] - offsets[i<<1],\n\t\t\t\t\t\t\t\t\t\t\toffsets[i<<1], subpat_names[i]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (subpat_names[i]) {\n\t\t\t\t\t\t\t\tadd_assoc_stringl(subpats, subpat_names[i], (char *)stringlist[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  offsets[(i<<1)+1] - offsets[i<<1], 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tadd_next_index_stringl(subpats, (char *)stringlist[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   offsets[(i<<1)+1] - offsets[i<<1], 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpcre_free((void *) stringlist);\n\t\t\t}\n\t\t} else if (count == PCRE_ERROR_NOMATCH) {\n\t\t\t/* If we previously set PCRE_NOTEMPTY after a null match,\n\t\t\t   this is not necessarily the end. We need to advance\n\t\t\t   the start offset, and continue. Fudge the offset values\n\t\t\t   to achieve this, unless we're already at the end of the string. */\n\t\t\tif (g_notempty != 0 && start_offset < subject_len) {\n\t\t\t\toffsets[0] = start_offset;\n\t\t\t\toffsets[1] = start_offset + 1;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tpcre_handle_exec_error(count TSRMLS_CC);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t/* If we have matched an empty string, mimic what Perl's /g options does.\n\t\t   This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try\n\t\t   the match again at the same point. If this fails (picked up above) we\n\t\t   advance to the next character. */\n\t\tg_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;\n\t\t\n\t\t/* Advance to the position right after the last full match */\n\t\tstart_offset = offsets[1];\n\t} while (global);\n\n\t/* Add the match sets to the output array and clean up */\n\tif (global && subpats && subpats_order == PREG_PATTERN_ORDER) {\n\t\tfor (i = 0; i < num_subpats; i++) {\n\t\t\tif (subpat_names[i]) {\n\t\t\t\tzend_hash_update(Z_ARRVAL_P(subpats), subpat_names[i],\n\t\t\t\t\t\t\t\t strlen(subpat_names[i])+1, &match_sets[i], sizeof(zval *), NULL);\n\t\t\t\tZ_ADDREF_P(match_sets[i]);\n\t\t\t}\n\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(subpats), &match_sets[i], sizeof(zval *), NULL);\n\t\t}\n\t\tefree(match_sets);\n\t}\n\t\n\tefree(offsets);\n\tefree(subpat_names);\n\n\t/* Did we encounter an error? */\n\tif (PCRE_G(error_code) == PHP_PCRE_NO_ERROR) {\n\t\tRETVAL_LONG(matched);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "line_perp(PG_FUNCTION_ARGS)\n{\n\tLINE\t   *l1 = PG_GETARG_LINE_P(0);\n\tLINE\t   *l2 = PG_GETARG_LINE_P(1);\n\n\tif (FPzero(l1->A))\n\t\tPG_RETURN_BOOL(FPzero(l2->B));\n\telse if (FPzero(l1->B))\n\t\tPG_RETURN_BOOL(FPzero(l2->A));\n\n\tPG_RETURN_BOOL(FPeq(((l1->A * l2->B) / (l1->B * l2->A)), -1.0));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void rds_recv_incoming(struct rds_connection *conn, __be32 saddr, __be32 daddr,\n\t\t       struct rds_incoming *inc, gfp_t gfp)\n{\n\tstruct rds_sock *rs = NULL;\n\tstruct sock *sk;\n\tunsigned long flags;\n\n\tinc->i_conn = conn;\n\tinc->i_rx_jiffies = jiffies;\n\n\trdsdebug(\"conn %p next %llu inc %p seq %llu len %u sport %u dport %u \"\n\t\t \"flags 0x%x rx_jiffies %lu\\n\", conn,\n\t\t (unsigned long long)conn->c_next_rx_seq,\n\t\t inc,\n\t\t (unsigned long long)be64_to_cpu(inc->i_hdr.h_sequence),\n\t\t be32_to_cpu(inc->i_hdr.h_len),\n\t\t be16_to_cpu(inc->i_hdr.h_sport),\n\t\t be16_to_cpu(inc->i_hdr.h_dport),\n\t\t inc->i_hdr.h_flags,\n\t\t inc->i_rx_jiffies);\n\n\t/*\n\t * Sequence numbers should only increase.  Messages get their\n\t * sequence number as they're queued in a sending conn.  They\n\t * can be dropped, though, if the sending socket is closed before\n\t * they hit the wire.  So sequence numbers can skip forward\n\t * under normal operation.  They can also drop back in the conn\n\t * failover case as previously sent messages are resent down the\n\t * new instance of a conn.  We drop those, otherwise we have\n\t * to assume that the next valid seq does not come after a\n\t * hole in the fragment stream.\n\t *\n\t * The headers don't give us a way to realize if fragments of\n\t * a message have been dropped.  We assume that frags that arrive\n\t * to a flow are part of the current message on the flow that is\n\t * being reassembled.  This means that senders can't drop messages\n\t * from the sending conn until all their frags are sent.\n\t *\n\t * XXX we could spend more on the wire to get more robust failure\n\t * detection, arguably worth it to avoid data corruption.\n\t */\n\tif (be64_to_cpu(inc->i_hdr.h_sequence) < conn->c_next_rx_seq &&\n\t    (inc->i_hdr.h_flags & RDS_FLAG_RETRANSMITTED)) {\n\t\trds_stats_inc(s_recv_drop_old_seq);\n\t\tgoto out;\n\t}\n\tconn->c_next_rx_seq = be64_to_cpu(inc->i_hdr.h_sequence) + 1;\n\n\tif (rds_sysctl_ping_enable && inc->i_hdr.h_dport == 0) {\n\t\trds_stats_inc(s_recv_ping);\n\t\trds_send_pong(conn, inc->i_hdr.h_sport);\n\t\tgoto out;\n\t}\n\n\trs = rds_find_bound(daddr, inc->i_hdr.h_dport);\n\tif (!rs) {\n\t\trds_stats_inc(s_recv_drop_no_sock);\n\t\tgoto out;\n\t}\n\n\t/* Process extension headers */\n\trds_recv_incoming_exthdrs(inc, rs);\n\n\t/* We can be racing with rds_release() which marks the socket dead. */\n\tsk = rds_rs_to_sk(rs);\n\n\t/* serialize with rds_release -> sock_orphan */\n\twrite_lock_irqsave(&rs->rs_recv_lock, flags);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\trdsdebug(\"adding inc %p to rs %p's recv queue\\n\", inc, rs);\n\t\trds_stats_inc(s_recv_queued);\n\t\trds_recv_rcvbuf_delta(rs, sk, inc->i_conn->c_lcong,\n\t\t\t\t      be32_to_cpu(inc->i_hdr.h_len),\n\t\t\t\t      inc->i_hdr.h_dport);\n\t\trds_inc_addref(inc);\n\t\tlist_add_tail(&inc->i_item, &rs->rs_recv_queue);\n\t\t__rds_wake_sk_sleep(sk);\n\t} else {\n\t\trds_stats_inc(s_recv_drop_dead_sock);\n\t}\n\twrite_unlock_irqrestore(&rs->rs_recv_lock, flags);\n\nout:\n\tif (rs)\n\t\trds_sock_put(rs);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t SampleTable::setCompositionTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n size_t numEntries = U32_AT(&header[4]);\n\n if (data_size != (numEntries + 1) * 8) {\n return ERROR_MALFORMED;\n\n     }\n \n     mNumCompositionTimeDeltaEntries = numEntries;\n    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n\n    mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n\n if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n < (ssize_t)numEntries * 8) {\n delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n return ERROR_IO;\n }\n\n for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n return OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "trap_name_resolved(\n\tint\t\t\trescode,\n\tint\t\t\tgai_errno,\n\tvoid *\t\t\tcontext,\n\tconst char *\t\tname,\n\tconst char *\t\tservice,\n\tconst struct addrinfo *\thints,\n\tconst struct addrinfo *\tres\n\t)\n{\n\tsettrap_parms *pstp;\n\tstruct interface *localaddr;\n\tsockaddr_u peeraddr;\n\n\tpstp = context;\n\tif (rescode) {\n\t\tmsyslog(LOG_ERR,\n\t\t\t\"giving up resolving trap host %s: %s (%d)\",\n\t\t\tname, gai_strerror(rescode), rescode);\n\t\tfree(pstp);\n\t\treturn;\n\t}\n\tNTP_INSIST(sizeof(peeraddr) >= res->ai_addrlen);\n\tmemset(&peeraddr, 0, sizeof(peeraddr));\n\tmemcpy(&peeraddr, res->ai_addr, res->ai_addrlen);\n\tlocaladdr = NULL;\n\tif (pstp->ifaddr_nonnull)\n\t\tlocaladdr = findinterface(&pstp->ifaddr);\n\tif (NULL == localaddr)\n\t\tlocaladdr = ANY_INTERFACE_CHOOSE(&peeraddr);\n\tif (!ctlsettrap(&peeraddr, localaddr, 0, NTP_VERSION))\n\t\tmsyslog(LOG_ERR, \"set trap %s -> %s failed.\",\n\t\t\tlatoa(localaddr), stoa(&peeraddr));\n\tfree(pstp);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int pix_fmt_match(enum AVPixelFormat pix_fmt, int components,\n                         int bpc, uint32_t log2_chroma_wh, int pal8)\n{\n    int match = 1;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n\n    if (desc->nb_components != components) {\n        return 0;\n    }\n\n    switch (components) {\n    case 4:\n        match = match && desc->comp[3].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >> 14 & 3) == 0 &&\n                         (log2_chroma_wh >> 12 & 3) == 0;\n    case 3:\n        match = match && desc->comp[2].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >> 10 & 3) == desc->log2_chroma_w &&\n                         (log2_chroma_wh >>  8 & 3) == desc->log2_chroma_h;\n    case 2:\n        match = match && desc->comp[1].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >>  6 & 3) == desc->log2_chroma_w &&\n                         (log2_chroma_wh >>  4 & 3) == desc->log2_chroma_h;\n\n    case 1:\n        match = match && desc->comp[0].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >>  2 & 3) == 0 &&\n                         (log2_chroma_wh       & 3) == 0 &&\n                         (desc->flags & AV_PIX_FMT_FLAG_PAL) == pal8 * AV_PIX_FMT_FLAG_PAL;\n    }\n    return match;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Location::SetLocation(const String& url,\n                           LocalDOMWindow* current_window,\n                           LocalDOMWindow* entered_window,\n                           ExceptionState* exception_state,\n                           SetLocationPolicy set_location_policy) {\n  if (!IsAttached())\n    return;\n\n  if (!current_window->GetFrame())\n    return;\n\n  Document* entered_document = entered_window->document();\n  if (!entered_document)\n    return;\n\n  KURL completed_url = entered_document->CompleteURL(url);\n  if (completed_url.IsNull())\n    return;\n\n  if (!current_window->GetFrame()->CanNavigate(*dom_window_->GetFrame(),\n                                               completed_url)) {\n    if (exception_state) {\n      exception_state->ThrowSecurityError(\n          \"The current window does not have permission to navigate the target \"\n          \"frame to '\" +\n          url + \"'.\");\n    }\n    return;\n  }\n  if (exception_state && !completed_url.IsValid()) {\n    exception_state->ThrowDOMException(DOMExceptionCode::kSyntaxError,\n                                       \"'\" + url + \"' is not a valid URL.\");\n    return;\n  }\n\n   if (dom_window_->IsInsecureScriptAccess(*current_window, completed_url))\n     return;\n \n   V8DOMActivityLogger* activity_logger =\n       V8DOMActivityLogger::CurrentActivityLoggerIfIsolatedWorld();\n   if (activity_logger) {\n    Vector<String> argv;\n    argv.push_back(\"LocalDOMWindow\");\n    argv.push_back(\"url\");\n    argv.push_back(entered_document->Url());\n    argv.push_back(completed_url);\n    activity_logger->LogEvent(\"blinkSetAttribute\", argv.size(), argv.data());\n  }\n  WebFrameLoadType frame_load_type = WebFrameLoadType::kStandard;\n  if (set_location_policy == SetLocationPolicy::kReplaceThisFrame)\n    frame_load_type = WebFrameLoadType::kReplaceCurrentItem;\n  dom_window_->GetFrame()->ScheduleNavigation(*current_window->document(),\n                                              completed_url, frame_load_type,\n                                              UserGestureStatus::kNone);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "need_pre_notify(gpointer key, gpointer value, gpointer user_data)\n{\n    cib_client_t *client = value;\n\n    if (client->pre_notify) {\n        gboolean *needed = user_data;\n\n        *needed = TRUE;\n    }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline unsigned int fold_hash(unsigned long hash)\n{\n\thash += hash >> (8*sizeof(int));\n\treturn hash;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-59"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void UiSceneCreator::CreateUrlBar() {\n  auto scaler = base::MakeUnique<ScaledDepthAdjuster>(kUrlBarDistance);\n  scaler->SetName(kUrlBarDmmRoot);\n  scene_->AddUiElement(k2dBrowsingForeground, std::move(scaler));\n\n  base::RepeatingCallback<void()> url_click_callback;\n  if (base::FeatureList::IsEnabled(features::kVrBrowserKeyboard)) {\n    url_click_callback = base::BindRepeating(\n        [](Model* m, UiBrowserInterface* browser) {\n          m->omnibox_input_active = true;\n        },\n        base::Unretained(model_), base::Unretained(browser_));\n  } else {\n    url_click_callback = base::BindRepeating([] {});\n  }\n\n  auto url_bar = base::MakeUnique<UrlBar>(\n      512,\n      base::BindRepeating(&UiBrowserInterface::NavigateBack,\n                          base::Unretained(browser_)),\n      url_click_callback,\n      base::BindRepeating(&UiBrowserInterface::OnUnsupportedMode,\n                          base::Unretained(browser_)));\n  url_bar->SetName(kUrlBar);\n  url_bar->SetDrawPhase(kPhaseForeground);\n  url_bar->SetTranslate(0, kUrlBarVerticalOffsetDMM, 0);\n  url_bar->SetRotate(1, 0, 0, kUrlBarRotationRad);\n  url_bar->SetSize(kUrlBarWidthDMM, kUrlBarHeightDMM);\n  url_bar->AddBinding(VR_BIND_FUNC(bool, Model, model_, fullscreen == false,\n                                   UiElement, url_bar.get(), SetVisible));\n  url_bar->AddBinding(VR_BIND_FUNC(ToolbarState, Model, model_, toolbar_state,\n                                   UrlBar, url_bar.get(), SetToolbarState));\n  url_bar->AddBinding(VR_BIND_FUNC(UrlBarColors, Model, model_,\n                                   color_scheme().url_bar, UrlBar,\n                                   url_bar.get(), SetColors));\n  url_bar->AddBinding(VR_BIND_FUNC(bool, Model, model_, can_navigate_back,\n                                   UrlBar, url_bar.get(),\n                                   SetHistoryButtonsEnabled));\n  BindColor(model_, url_bar.get(), &ColorScheme::element_background,\n            &TexturedElement::SetBackgroundColor);\n  scene_->AddUiElement(kUrlBarDmmRoot, std::move(url_bar));\n\n  auto indicator_bg = base::MakeUnique<Rect>();\n  indicator_bg->SetName(kLoadingIndicator);\n  indicator_bg->SetDrawPhase(kPhaseForeground);\n  indicator_bg->SetTranslate(0, kLoadingIndicatorVerticalOffsetDMM, 0);\n  indicator_bg->SetSize(kLoadingIndicatorWidthDMM, kLoadingIndicatorHeightDMM);\n  indicator_bg->set_y_anchoring(TOP);\n  indicator_bg->SetTransitionedProperties({OPACITY});\n  indicator_bg->set_corner_radius(kLoadingIndicatorHeightDMM * 0.5f);\n  indicator_bg->AddBinding(VR_BIND_FUNC(bool, Model, model_, loading, Rect,\n                                        indicator_bg.get(), SetVisible));\n  BindColor(model_, indicator_bg.get(),\n            &ColorScheme::loading_indicator_background, &Rect::SetColor);\n\n  scene_->AddUiElement(kUrlBar, std::move(indicator_bg));\n\n  auto indicator_fg = base::MakeUnique<Rect>();\n  indicator_fg->SetDrawPhase(kPhaseForeground);\n  indicator_fg->SetName(kLoadingIndicatorForeground);\n  indicator_fg->set_x_anchoring(LEFT);\n  indicator_fg->set_corner_radius(kLoadingIndicatorHeightDMM * 0.5f);\n  indicator_fg->set_hit_testable(false);\n  BindColor(model_, indicator_fg.get(),\n            &ColorScheme::loading_indicator_foreground, &Rect::SetColor);\n  indicator_fg->AddBinding(base::MakeUnique<Binding<float>>(\n      base::Bind([](Model* m) { return m->load_progress; },\n                 base::Unretained(model_)),\n      base::Bind(\n          [](Rect* r, const float& value) {\n            r->SetSize(kLoadingIndicatorWidthDMM * value,\n                       kLoadingIndicatorHeightDMM);\n            r->SetTranslate(kLoadingIndicatorWidthDMM * value * 0.5f, 0.0f,\n                            0.001f);\n          },\n          base::Unretained(indicator_fg.get()))));\n  scene_->AddUiElement(kLoadingIndicator, std::move(indicator_fg));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val)\n {\n\tulonglong tmp;\n \tif (jas_iccgetuint(in, 4, &tmp))\n \t\treturn -1;\n\t*val = (tmp & 0x80000000) ? (-JAS_CAST(longlong, (((~tmp) &\n\t  0x7fffffff) + 1))) : JAS_CAST(longlong, tmp);\n \treturn 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int build_polexpire(struct sk_buff *skb, struct xfrm_policy *xp,\n\t\t\t   int dir, const struct km_event *c)\n{\n\tstruct xfrm_user_polexpire *upe;\n\tint hard = c->data.hard;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_POLEXPIRE, sizeof(*upe), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tupe = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, &upe->pol, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tupe->hard = !!hard;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void *m_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\n\tp->cached_mount = seq_list_next(v, &p->ns->list, pos);\n\tp->cached_index = *pos;\n\treturn p->cached_mount;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n \t\t\tgoto out;\n \t\t}\n \t}\n \tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n \n \tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n {\n\tstruct desc_struct *desc;\n \tshort sel;\n \n \tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t/*\n\t\t * Base is simply the segment selector shifted 4\n\t\t * bits to the right.\n\t\t */\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\t/*\n\t\t * Only FS or GS will have a base address, the rest of\n\t\t * the segments' bases are forced to 0.\n\t\t */\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\t/*\n\t\t\t * swapgs was called at the kernel entry point. Thus,\n\t\t\t * MSR_KERNEL_GS_BASE will have the user-space GS base.\n\t\t\t */\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\t/* In protected mode the segment selector cannot be null. */\n \tif (!sel)\n \t\treturn -1L;\n \n\tdesc = get_desc(sel);\n\tif (!desc)\n \t\treturn -1L;\n \n\treturn get_desc_base(desc);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n {\n \tloff_t offset;\n \tint error;\n \n \t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n \n \tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n \t\treturn -EINVAL;\n \n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n \t\t\treturn -EINVAL;\n \t}\n \n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n \toffset = (loff_t)(start - vma->vm_start)\n \t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n \n\t/* filesystem's fallocate may need to take i_mutex */\n \tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n \t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n \t\t\t\toffset, end - start);\n \tdown_read(&current->mm->mmap_sem);\n \treturn error;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void checkSecurityForNodeReadonlyDocumentAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    ExceptionState exceptionState(ExceptionState::GetterContext, \"checkSecurityForNodeReadonlyDocumentAttribute\", \"TestObjectPython\", info.Holder(), info.GetIsolate());\n    if (!BindingSecurity::shouldAllowAccessToNode(info.GetIsolate(), imp->checkSecurityForNodeReadonlyDocumentAttribute(), exceptionState)) {\n        v8SetReturnValueNull(info);\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    v8SetReturnValueFast(info, WTF::getPtr(imp->checkSecurityForNodeReadonlyDocumentAttribute()), imp);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n {\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n \tstruct hw_perf_event fake_event = event->hw;\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n \n \tif (is_software_event(event))\n \t\treturn 1;\n \n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;\n \n \tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n \t\treturn 1;\n \n \treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n\n\n     /* first of all, compute the scanline offset */\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += ( map->rows - 1 ) * map->pitch;\n \n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n\n\n      if ( coverage )\n      {\n        /* For small-spans it is faster to do it by ourselves than\n         * calling `memset'.  This is mainly due to the cost of the\n         * function call.\n         */\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n\n\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PHP_FUNCTION(imagefilledarc)\n{\n\tzval *IM;\n\tlong cx, cy, w, h, ST, E, col, style;\n\tgdImagePtr im;\n\tint e, st;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllllllll\", &IM, &cx, &cy, &w, &h, &ST, &E, &col, &style) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\te = E;\n\tif (e < 0) {\n\t\te %= 360;\n\t}\n\n\tst = ST;\n\tif (st < 0) {\n\t\tst %= 360;\n\t}\n\n\tgdImageFilledArc(im, cx, cy, w, h, st, e, col, style);\n\n\tRETURN_TRUE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "struct bio *bio_clone_bioset(struct bio *bio_src, gfp_t gfp_mask,\n\t\t\t     struct bio_set *bs)\n{\n\tstruct bvec_iter iter;\n\tstruct bio_vec bv;\n\tstruct bio *bio;\n\n\t/*\n\t * Pre immutable biovecs, __bio_clone() used to just do a memcpy from\n\t * bio_src->bi_io_vec to bio->bi_io_vec.\n\t *\n\t * We can't do that anymore, because:\n\t *\n\t *  - The point of cloning the biovec is to produce a bio with a biovec\n\t *    the caller can modify: bi_idx and bi_bvec_done should be 0.\n\t *\n\t *  - The original bio could've had more than BIO_MAX_PAGES biovecs; if\n\t *    we tried to clone the whole thing bio_alloc_bioset() would fail.\n\t *    But the clone should succeed as long as the number of biovecs we\n\t *    actually need to allocate is fewer than BIO_MAX_PAGES.\n\t *\n\t *  - Lastly, bi_vcnt should not be looked at or relied upon by code\n\t *    that does not own the bio - reason being drivers don't use it for\n\t *    iterating over the biovec anymore, so expecting it to be kept up\n\t *    to date (i.e. for clones that share the parent biovec) is just\n\t *    asking for trouble and would force extra work on\n\t *    __bio_clone_fast() anyways.\n\t */\n\n\tbio = bio_alloc_bioset(gfp_mask, bio_segments(bio_src), bs);\n\tif (!bio)\n\t\treturn NULL;\n\tbio->bi_disk\t\t= bio_src->bi_disk;\n\tbio->bi_opf\t\t= bio_src->bi_opf;\n\tbio->bi_write_hint\t= bio_src->bi_write_hint;\n\tbio->bi_iter.bi_sector\t= bio_src->bi_iter.bi_sector;\n\tbio->bi_iter.bi_size\t= bio_src->bi_iter.bi_size;\n\n\tswitch (bio_op(bio)) {\n\tcase REQ_OP_DISCARD:\n\tcase REQ_OP_SECURE_ERASE:\n\tcase REQ_OP_WRITE_ZEROES:\n\t\tbreak;\n\tcase REQ_OP_WRITE_SAME:\n\t\tbio->bi_io_vec[bio->bi_vcnt++] = bio_src->bi_io_vec[0];\n\t\tbreak;\n\tdefault:\n\t\tbio_for_each_segment(bv, bio_src, iter)\n\t\t\tbio->bi_io_vec[bio->bi_vcnt++] = bv;\n\t\tbreak;\n\t}\n\n\tif (bio_integrity(bio_src)) {\n\t\tint ret;\n\n\t\tret = bio_integrity_clone(bio, bio_src, gfp_mask);\n\t\tif (ret < 0) {\n\t\t\tbio_put(bio);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbio_clone_blkcg_association(bio, bio_src);\n\n\treturn bio;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-772"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int labvalidate(i_ctx_t *i_ctx_p, ref *space, float *values, int num_comps)\n{\n    os_ptr op = osp;\n    int i;\n\n    if (num_comps < 3)\n        return_error(gs_error_stackunderflow);\n    op -= 2;\n    for (i=0;i<3;i++) {\n        if (!r_has_type(op, t_integer) && !r_has_type(op, t_real))\n            return_error(gs_error_typecheck);\n        op++;\n    }\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-704"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void bta_hh_co_open(UINT8 dev_handle, UINT8 sub_class, tBTA_HH_ATTR_MASK attr_mask,\n                    UINT8 app_id)\n{\n    UINT32 i;\n btif_hh_device_t *p_dev = NULL;\n\n if (dev_handle == BTA_HH_INVALID_HANDLE) {\n        APPL_TRACE_WARNING(\"%s: Oops, dev_handle (%d) is invalid...\",\n                           __FUNCTION__, dev_handle);\n return;\n }\n\n for (i = 0; i < BTIF_HH_MAX_HID; i++) {\n        p_dev = &btif_hh_cb.devices[i];\n if (p_dev->dev_status != BTHH_CONN_STATE_UNKNOWN &&\n            p_dev->dev_handle == dev_handle) {\n            APPL_TRACE_WARNING(\"%s: Found an existing device with the same handle \"\n \"dev_status = %d\",__FUNCTION__,\n                                                                p_dev->dev_status);\n            APPL_TRACE_WARNING(\"%s:     bd_addr = [%02X:%02X:%02X:%02X:%02X:]\", __FUNCTION__,\n                 p_dev->bd_addr.address[0], p_dev->bd_addr.address[1], p_dev->bd_addr.address[2],\n                 p_dev->bd_addr.address[3], p_dev->bd_addr.address[4]);\n                 APPL_TRACE_WARNING(\"%s:     attr_mask = 0x%04x, sub_class = 0x%02x, app_id = %d\",\n\n                                   __FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);\n \n             if(p_dev->fd<0) {\n                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);\n                 if (p_dev->fd < 0){\n                     APPL_TRACE_ERROR(\"%s: Error: failed to open uhid, err:%s\",\n                                                                     __FUNCTION__,strerror(errno));\n return;\n }else\n                    APPL_TRACE_DEBUG(\"%s: uhid fd = %d\", __FUNCTION__, p_dev->fd);\n }\n\n            p_dev->hh_keep_polling = 1;\n            p_dev->hh_poll_thread_id = create_thread(btif_hh_poll_event_thread, p_dev);\n break;\n }\n        p_dev = NULL;\n }\n\n if (p_dev == NULL) {\n for (i = 0; i < BTIF_HH_MAX_HID; i++) {\n if (btif_hh_cb.devices[i].dev_status == BTHH_CONN_STATE_UNKNOWN) {\n                p_dev = &btif_hh_cb.devices[i];\n                p_dev->dev_handle = dev_handle;\n                p_dev->attr_mask  = attr_mask;\n                p_dev->sub_class  = sub_class;\n                p_dev->app_id     = app_id;\n                p_dev->local_vup  = FALSE;\n\n \n                 btif_hh_cb.device_num++;\n                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);\n                 if (p_dev->fd < 0){\n                     APPL_TRACE_ERROR(\"%s: Error: failed to open uhid, err:%s\",\n                                                                     __FUNCTION__,strerror(errno));\n return;\n }else{\n                    APPL_TRACE_DEBUG(\"%s: uhid fd = %d\", __FUNCTION__, p_dev->fd);\n                    p_dev->hh_keep_polling = 1;\n                    p_dev->hh_poll_thread_id = create_thread(btif_hh_poll_event_thread, p_dev);\n }\n\n\n break;\n }\n }\n }\n\n if (p_dev == NULL) {\n        APPL_TRACE_ERROR(\"%s: Error: too many HID devices are connected\", __FUNCTION__);\n return;\n }\n\n    p_dev->dev_status = BTHH_CONN_STATE_CONNECTED;\n    APPL_TRACE_DEBUG(\"%s: Return device status %d\", __FUNCTION__, p_dev->dev_status);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void MediaControlVolumeSliderElement::defaultEventHandler(Event* event) {\n  if (event->isMouseEvent() &&\n      toMouseEvent(event)->button() !=\n          static_cast<short>(WebPointerProperties::Button::Left))\n    return;\n   if (!isConnected() || !document().isActive())\n     return;\n \n   MediaControlInputElement::defaultEventHandler(event);\n \n  if (event->type() == EventTypeNames::mouseover ||\n      event->type() == EventTypeNames::mouseout ||\n      event->type() == EventTypeNames::mousemove)\n    return;\n   if (event->type() == EventTypeNames::mousedown)\n     Platform::current()->recordAction(\n         UserMetricsAction(\"Media.Controls.VolumeChangeBegin\"));\n\n  if (event->type() == EventTypeNames::mouseup)\n     Platform::current()->recordAction(\n         UserMetricsAction(\"Media.Controls.VolumeChangeEnd\"));\n \n  double volume = value().toDouble();\n  mediaElement().setVolume(volume);\n  mediaElement().setMuted(false);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int recv_stream(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *m, size_t buf_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tipc_port *tport = tipc_sk_port(sk);\n\tstruct sk_buff *buf;\n\tstruct tipc_msg *msg;\n\tlong timeout;\n\tunsigned int sz;\n\tint sz_to_copy, target, needed;\n\tint sz_copied = 0;\n\tu32 err;\n\tint res = 0;\n\n\t/* Catch invalid receive attempts */\n\tif (unlikely(!buf_len))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (unlikely((sock->state == SS_UNCONNECTED))) {\n\t\tres = -ENOTCONN;\n \t\tgoto exit;\n \t}\n \n\t/* will be updated in set_orig_addr() if needed */\n\tm->msg_namelen = 0;\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n \nrestart:\n\t/* Look for a message in receive queue; wait if necessary */\n\twhile (skb_queue_empty(&sk->sk_receive_queue)) {\n\t\tif (sock->state == SS_DISCONNECTING) {\n\t\t\tres = -ENOTCONN;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (timeout <= 0L) {\n\t\t\tres = timeout ? timeout : -EWOULDBLOCK;\n\t\t\tgoto exit;\n\t\t}\n\t\trelease_sock(sk);\n\t\ttimeout = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t\t\t   tipc_rx_ready(sock),\n\t\t\t\t\t\t\t   timeout);\n\t\tlock_sock(sk);\n\t}\n\n\t/* Look at first message in receive queue */\n\tbuf = skb_peek(&sk->sk_receive_queue);\n\tmsg = buf_msg(buf);\n\tsz = msg_data_sz(msg);\n\terr = msg_errcode(msg);\n\n\t/* Discard an empty non-errored message & try again */\n\tif ((!sz) && (!err)) {\n\t\tadvance_rx_queue(sk);\n\t\tgoto restart;\n\t}\n\n\t/* Optionally capture sender's address & ancillary data of first msg */\n\tif (sz_copied == 0) {\n\t\tset_orig_addr(m, msg);\n\t\tres = anc_data_recv(m, msg, tport);\n\t\tif (res)\n\t\t\tgoto exit;\n\t}\n\n\t/* Capture message data (if valid) & compute return value (always) */\n\tif (!err) {\n\t\tu32 offset = (u32)(unsigned long)(TIPC_SKB_CB(buf)->handle);\n\n\t\tsz -= offset;\n\t\tneeded = (buf_len - sz_copied);\n\t\tsz_to_copy = (sz <= needed) ? sz : needed;\n\n\t\tres = skb_copy_datagram_iovec(buf, msg_hdr_sz(msg) + offset,\n\t\t\t\t\t      m->msg_iov, sz_to_copy);\n\t\tif (res)\n\t\t\tgoto exit;\n\n\t\tsz_copied += sz_to_copy;\n\n\t\tif (sz_to_copy < sz) {\n\t\t\tif (!(flags & MSG_PEEK))\n\t\t\t\tTIPC_SKB_CB(buf)->handle =\n\t\t\t\t(void *)(unsigned long)(offset + sz_to_copy);\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tif (sz_copied != 0)\n\t\t\tgoto exit; /* can't add error msg to valid data */\n\n\t\tif ((err == TIPC_CONN_SHUTDOWN) || m->msg_control)\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -ECONNRESET;\n\t}\n\n\t/* Consume received message (optional) */\n\tif (likely(!(flags & MSG_PEEK))) {\n\t\tif (unlikely(++tport->conn_unacked >= TIPC_FLOW_CONTROL_WIN))\n\t\t\ttipc_acknowledge(tport->ref, tport->conn_unacked);\n\t\tadvance_rx_queue(sk);\n\t}\n\n\t/* Loop around if more data is required */\n\tif ((sz_copied < buf_len) &&\t/* didn't get all requested data */\n\t    (!skb_queue_empty(&sk->sk_receive_queue) ||\n\t    (sz_copied < target)) &&\t/* and more is ready or required */\n\t    (!(flags & MSG_PEEK)) &&\t/* and aren't just peeking at data */\n\t    (!err))\t\t\t/* and haven't reached a FIN */\n\t\tgoto restart;\n\nexit:\n\trelease_sock(sk);\n\treturn sz_copied ? sz_copied : res;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Chapters::Display::Clear()\n{\n    delete[] m_string;\n    m_string = NULL;\n    delete[] m_language;\n    m_language = NULL;\n    delete[] m_country;\n    m_country = NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static unsigned int br_nf_pre_routing_ipv6(unsigned int hook,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   const struct net_device *in,\n\t\t\t\t\t   const struct net_device *out,\n\t\t\t\t\t   int (*okfn)(struct sk_buff *))\n{\n\tstruct ipv6hdr *hdr;\n\tu32 pkt_len;\n\n\tif (skb->len < sizeof(struct ipv6hdr))\n\t\treturn NF_DROP;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\treturn NF_DROP;\n\n\thdr = ipv6_hdr(skb);\n\n\tif (hdr->version != 6)\n\t\treturn NF_DROP;\n\n\tpkt_len = ntohs(hdr->payload_len);\n\n\tif (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {\n\t\tif (pkt_len + sizeof(struct ipv6hdr) > skb->len)\n\t\t\treturn NF_DROP;\n\t\tif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\n\t\t\treturn NF_DROP;\n\t}\n\tif (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))\n\t\treturn NF_DROP;\n\n\tnf_bridge_put(skb->nf_bridge);\n\tif (!nf_bridge_alloc(skb))\n\t\treturn NF_DROP;\n\tif (!setup_pre_routing(skb))\n\t\treturn NF_DROP;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tNF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,\n\t\tbr_nf_pre_routing_finish_ipv6);\n\n\treturn NF_STOLEN;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "pvscsi_command_complete(SCSIRequest *req, uint32_t status, size_t resid)\n{\n    PVSCSIRequest *pvscsi_req = req->hba_private;\n    PVSCSIState *s;\n\n    if (!pvscsi_req) {\n        trace_pvscsi_command_complete_not_found(req->tag);\n        return;\n    }\n    s = pvscsi_req->dev;\n\n    if (resid) {\n        /* Short transfer.  */\n        trace_pvscsi_command_complete_data_run();\n        pvscsi_req->cmp.hostStatus = BTSTAT_DATARUN;\n    }\n\n    pvscsi_req->cmp.scsiStatus = status;\n    if (pvscsi_req->cmp.scsiStatus == CHECK_CONDITION) {\n        uint8_t sense[SCSI_SENSE_BUF_SIZE];\n        int sense_len =\n            scsi_req_get_sense(pvscsi_req->sreq, sense, sizeof(sense));\n\n        trace_pvscsi_command_complete_sense_len(sense_len);\n        pvscsi_write_sense(pvscsi_req, sense, sense_len);\n    }\n    qemu_sglist_destroy(&pvscsi_req->sgl);\n    pvscsi_complete_request(s, pvscsi_req);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n \tif(!file) return 0;\n \tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n \t}\n\tretval = (int)tmpretval;\n \tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n \t}\n\topenmpt_free_string(str);\n\treturn retval;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-120"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n \t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n \tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n \t\t   EXT4_DESC_PER_BLOCK(sb);\n \tsbi->s_group_desc = ext4_kvmalloc(db_count *\n \t\t\t\t\t  sizeof(struct buffer_head *),\n \t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,\n\t\togg_int32_t **in,int *nonzero,int ch){\n \n   int i,j,k,s,used=0;\n   codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;\n  codebook *phrasebook=ci->book_param+info->groupbook;\n int samples_per_partition=info->grouping;\n int partitions_per_word=phrasebook->dim;\n int pcmend=ci->blocksizes[vd->W];\n\n if(info->type<2){\n int max=pcmend>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       for(i=0;i<ch;i++)\n\tif(nonzero[i])\n\t  in[used++]=in[i];\n       ch=used;\n \n       if(used){\n \n\tchar **partword=(char **)alloca(ch*sizeof(*partword));\n\tfor(j=0;j<ch;j++)\n\t  partword[j]=(char *)alloca(partwords*partitions_per_word*\n\t\t\t\t     sizeof(*partword[j]));\n \n\tfor(s=0;s<info->stages;s++){\n \n\t  for(i=0;i<partvals;){\n\t    if(s==0){\n\t      /* fetch the partition word for each channel */\n \n\t      partword[0][i+partitions_per_word-1]=1;\n\t      for(k=partitions_per_word-2;k>=0;k--)\n\t\tpartword[0][i+k]=partword[0][i+k+1]*info->partitions;\n \n\t      for(j=1;j<ch;j++)\n\t\tfor(k=partitions_per_word-1;k>=0;k--)\n\t\t  partword[j][i+k]=partword[j-1][i+k];\n \n\t      for(j=0;j<ch;j++){\n\t\tint temp=vorbis_book_decode(phrasebook,&vd->opb);\n\t\tif(temp==-1)goto eopbreak;\n \n\t\t/* this can be done quickly in assembly due to the quotient\n\t\t   always being at most six bits */\n\t\tfor(k=0;k<partitions_per_word;k++){\n\t\t  ogg_uint32_t div=partword[j][i+k];\n\t\t  partword[j][i+k]=temp/div;\n\t\t  temp-=partword[j][i+k]*div;\n\t\t}\n \n\t      }\n\t    }\n \n\t    /* now we decode residual values for the partitions */\n\t    for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n\t      for(j=0;j<ch;j++){\n\t\tlong offset=info->begin+i*samples_per_partition;\n\t\tif(info->stagemasks[(int)partword[j][i]]&(1<<s)){\n\t\t  codebook *stagebook=ci->book_param+\n\t\t    info->stagebooks[(partword[j][i]<<3)+s];\n\t\t  if(info->type){\n\t\t    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t       samples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }else{\n\t\t    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t\tsamples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }\n\t\t}\n\t      }\n\t  }\n\t}\n       }\n     }\n   }else{\n int max=(pcmend*ch)>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       char *partword=\n\t(char *)alloca(partwords*partitions_per_word*sizeof(*partword));\n       int beginoff=info->begin/ch;\n \n       for(i=0;i<ch;i++)if(nonzero[i])break;\n if(i==ch)return(0); /* no nonzero vectors */\n\n      samples_per_partition/=ch;\n\n for(s=0;s<info->stages;s++){\n for(i=0;i<partvals;){\n\n if(s==0){\n int temp;\n\t    partword[i+partitions_per_word-1]=1;\n for(k=partitions_per_word-2;k>=0;k--)\n\t      partword[i+k]=partword[i+k+1]*info->partitions;\n\n /* fetch the partition word */\n\t    temp=vorbis_book_decode(phrasebook,&vd->opb);\n if(temp==-1)goto eopbreak;\n\n /* this can be done quickly in assembly due to the quotient\n\t       always being at most six bits */\n for(k=0;k<partitions_per_word;k++){\n ogg_uint32_t div=partword[i+k];\n\t      partword[i+k]=temp/div;\n\t      temp-=partword[i+k]*div;\n }\n }\n\n /* now we decode residual values for the partitions */\n for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n if(info->stagemasks[(int)partword[i]]&(1<<s)){\n\t      codebook *stagebook=ci->book_param+\n\t\tinfo->stagebooks[(partword[i]<<3)+s];\n if(vorbis_book_decodevv_add(stagebook,in,\n\t\t\t\t\t  i*samples_per_partition+beginoff,ch,\n &vd->opb,\n\t\t\t\t\t  samples_per_partition,-8)==-1)\n goto eopbreak;\n }\n }\n }\n }\n }\n eopbreak:\n\n return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int sm_adaptive_routing(p_fm_config_conx_hdlt hdl, fm_mgr_type_t mgr, int argc, char *argv[]) {\n\tfm_mgr_config_errno_t\tres;\n\tfm_msg_ret_code_t\t\tret_code;\n\tuint32_t\t\t\t\tenable=0;\n\n\tif (argc == 1) {\n\t\tenable = atol(argv[0]);\n\t\tif((res = fm_mgr_simple_query(hdl, FM_ACT_GET, FM_DT_SM_SET_ADAPTIVE_ROUTING, mgr, sizeof(enable), (void*)&enable, &ret_code)) != FM_CONF_OK)\n\t\t{\n\t\t\tfprintf(stderr, \"sm_adaptive_routing: Failed to retrieve data: \\n\"\n\t\t       \t\"\\tError:(%d) %s \\n\\tRet code:(%d) %s\\n\",\n\t\t       \tres, fm_mgr_get_error_str(res),ret_code,\n\t\t       \tfm_mgr_get_resp_error_str(ret_code));\n\t\t} else {\n\t\t\tprintf(\"Successfully sent SM Adaptive Routing control to local SM instance\\n\");\n    \t}\n\n\t} else if (argc == 0) {\n\t\tif((res = fm_mgr_simple_query(hdl, FM_ACT_GET, FM_DT_SM_GET_ADAPTIVE_ROUTING, mgr, sizeof(enable), (void*)&enable, &ret_code)) != FM_CONF_OK)\n\t\t{\n\t\t\tfprintf(stderr, \"sm_adaptive_routing: Failed to retrieve data: \\n\"\n\t\t       \t\"\\tError:(%d) %s \\n\\tRet code:(%d) %s\\n\",\n\t\t       \tres, fm_mgr_get_error_str(res),ret_code,\n\t\t       \tfm_mgr_get_resp_error_str(ret_code));\n\t\t} else {\n\t\t\tprintf(\"SM Adaptive Routing is %s\\n\", enable ? \"enabled\" : \"disabled\");\n\t\t}\n\t}\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GraphicsContext::setPlatformShouldAntialias(bool enable)\n{\n    if (paintingDisabled())\n        return;\n\n    platformContext()->setUseAntialiasing(enable);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-19"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void DesktopWindowTreeHostX11::Show(ui::WindowShowState show_state,\n                                    const gfx::Rect& restore_bounds) {\n  if (compositor())\n    SetVisible(true);\n\n  if (!window_mapped_in_client_ || IsMinimized())\n    MapWindow(show_state);\n\n  switch (show_state) {\n    case ui::SHOW_STATE_MAXIMIZED:\n      Maximize();\n      if (!restore_bounds.IsEmpty()) {\n        restored_bounds_in_pixels_ = ToPixelRect(restore_bounds);\n      }\n\n      break;\n    case ui::SHOW_STATE_MINIMIZED:\n      Minimize();\n      break;\n    case ui::SHOW_STATE_FULLSCREEN:\n      SetFullscreen(true);\n      break;\n    default:\n      break;\n  }\n\n  native_widget_delegate_->AsWidget()->SetInitialFocus(show_state);\n\n  content_window()->Show();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "struct sctp_chunk *sctp_make_auth(const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_hmac *hmac_desc;\n\tstruct sctp_authhdr auth_hdr;\n\t__u8 *hmac;\n\n\t/* Get the first hmac that the peer told us to use */\n\thmac_desc = sctp_auth_asoc_get_hmac(asoc);\n\tif (unlikely(!hmac_desc))\n\t\treturn NULL;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_AUTH, 0,\n\t\t\thmac_desc->hmac_len + sizeof(sctp_authhdr_t));\n\tif (!retval)\n\t\treturn NULL;\n\n\tauth_hdr.hmac_id = htons(hmac_desc->hmac_id);\n\tauth_hdr.shkey_id = htons(asoc->active_key_id);\n\n\tretval->subh.auth_hdr = sctp_addto_chunk(retval, sizeof(sctp_authhdr_t),\n\t\t\t\t\t\t&auth_hdr);\n\n\thmac = skb_put(retval->skb, hmac_desc->hmac_len);\n\tmemset(hmac, 0, hmac_desc->hmac_len);\n\n\t/* Adjust the chunk header to include the empty MAC */\n\tretval->chunk_hdr->length =\n\t\thtons(ntohs(retval->chunk_hdr->length) + hmac_desc->hmac_len);\n\tretval->chunk_end = skb_tail_pointer(retval->skb);\n\n\treturn retval;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,\n                            int total_subobj_len, int offset)\n{\n    int hexdump = FALSE;\n    int subobj_type, subobj_len;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n    } bw;\n\n    while (total_subobj_len > 0 && hexdump == FALSE ) {\n\tsubobj_type = EXTRACT_8BITS(obj_tptr + offset);\n\tsubobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1);\n\tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n\t\ttok2str(lmp_data_link_subobj,\n\t\t\t\"Unknown\",\n\t\t\tsubobj_type),\n\t\t\tsubobj_type,\n\t\t\tsubobj_len));\n\tif (subobj_len < 4) {\n\t    ND_PRINT((ndo, \" (too short)\"));\n\t    break;\n\t}\n\tif ((subobj_len % 4) != 0) {\n\t    ND_PRINT((ndo, \" (not a multiple of 4)\"));\n\t    break;\n\t}\n\tif (total_subobj_len < subobj_len) {\n\t    ND_PRINT((ndo, \" (goes past the end of the object)\"));\n\t    break;\n\t}\n\tswitch(subobj_type) {\n\tcase INT_SWITCHING_TYPE_SUBOBJ:\n\t    ND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n\t\ttok2str(gmpls_switch_cap_values,\n\t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)));\n\t    ND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n\t\ttok2str(gmpls_encoding_values,\n \t\t\t\"Unknown\",\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)),\n \t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)));\n \t    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n \t    ND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n                 bw.f*8/1000000));\n\t    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n\t    ND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n                bw.f*8/1000000));\n\t    break;\n\tcase WAVELENGTH_SUBOBJ:\n\t    ND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n\t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n\t    break;\n\tdefault:\n\t    /* Any Unknown Subobject ==> Exit loop */\n\t    hexdump=TRUE;\n\t    break;\n\t}\n\ttotal_subobj_len-=subobj_len;\n \toffset+=subobj_len;\n     }\n     return (hexdump);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BrowserWindowGtk::TabDetachedAt(TabContents* contents, int index) {\n  if (index == browser_->active_index()) {\n    infobar_container_->ChangeTabContents(NULL);\n    UpdateDevToolsForContents(NULL);\n  }\n  contents_container_->DetachTab(contents);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\treturn kvmppc_core_pending_dec(vcpu);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void __init devinet_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < IN4_ADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&inet_addr_lst[i]);\n\n\tregister_pernet_subsys(&devinet_ops);\n\n\tregister_gifconf(PF_INET, inet_gifconf);\n\tregister_netdevice_notifier(&ip_netdev_notifier);\n\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\n\n\trtnl_af_register(&inet_af_ops);\n\n\trtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL, NULL);\n\trtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL, NULL);\n\trtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr, NULL);\n\trtnl_register(PF_INET, RTM_GETNETCONF, inet_netconf_get_devconf,\n\t\t      inet_netconf_dump_devconf, NULL);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "BaseShadow::log_except(const char *msg)\n{\n\tShadowExceptionEvent event;\n        bool exception_already_logged = false;\n \n        if(!msg) msg = \"\";\n       sprintf(event.message, msg);\n \n        if ( BaseShadow::myshadow_ptr ) {\n                BaseShadow *shadow = BaseShadow::myshadow_ptr;\n\n\t\tevent.recvd_bytes = shadow->bytesSent();\n\t\tevent.sent_bytes = shadow->bytesReceived();\n\t\texception_already_logged = shadow->exception_already_logged;\n\n\t\tif (shadow->began_execution) {\n\t\t\tevent.began_execution = TRUE;\n\t\t}\n\n\t} else {\n\t\tevent.recvd_bytes = 0.0;\n\t\tevent.sent_bytes = 0.0;\n\t}\n\n\tif (!exception_already_logged && !uLog.writeEventNoFsync (&event,NULL))\n\t{\n\t\t::dprintf (D_ALWAYS, \"Unable to log ULOG_SHADOW_EXCEPTION event\\n\");\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-134"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline int hpel_motion(MpegEncContext *s,\n                              uint8_t *dest, uint8_t *src,\n                              int src_x, int src_y,\n                              op_pixels_func *pix_op,\n                              int motion_x, int motion_y)\n{\n    int dxy = 0;\n    int emu = 0;\n\n    src_x += motion_x >> 1;\n    src_y += motion_y >> 1;\n\n    /* WARNING: do no forget half pels */\n    src_x = av_clip(src_x, -16, s->width); // FIXME unneeded for emu?\n    if (src_x != s->width)\n        dxy |= motion_x & 1;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y != s->height)\n         dxy |= (motion_y & 1) << 1;\n     src += src_y * s->linesize + src_x;\n \n    if (s->unrestricted_mv) {\n        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                     s->linesize, s->linesize,\n                                     9, 9,\n                                     src_x, src_y, s->h_edge_pos,\n                                     s->v_edge_pos);\n            src = s->sc.edge_emu_buffer;\n            emu = 1;\n        }\n     }\n     pix_op[dxy](dest, src, s->linesize, 8);\n     return emu;\n    }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ProcPseudoramiXGetScreenCount(ClientPtr client)\n{\n    REQUEST(xPanoramiXGetScreenCountReq);\n    WindowPtr pWin;\n    xPanoramiXGetScreenCountReply rep;\n    register int rc;\n\n    TRACE;\n\n    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);\n    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n    if (rc != Success)\n        return rc;\n\n    rep.type = X_Reply;\n    rep.length = 0;\n    rep.sequenceNumber = client->sequence;\n    rep.ScreenCount = pseudoramiXNumScreens;\n    rep.window = stuff->window;\n    if (client->swapped) {\n        swaps(&rep.sequenceNumber);\n        swapl(&rep.length);\n        swapl(&rep.window);\n    }\n    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply),&rep);\n    return Success;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\t  struct cifs_sb_info *cifs_sb)\n{\n\tif (pvolume_info->rsize > CIFSMaxBufSize) {\n\t\tcERROR(1, \"rsize %d too large, using MaxBufSize\",\n\t\t\tpvolume_info->rsize);\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\t} else if ((pvolume_info->rsize) &&\n\t\t\t(pvolume_info->rsize <= CIFSMaxBufSize))\n\t\tcifs_sb->rsize = pvolume_info->rsize;\n\telse /* default */\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\n\tif (pvolume_info->wsize > PAGEVEC_SIZE * PAGE_CACHE_SIZE) {\n\t\tcERROR(1, \"wsize %d too large, using 4096 instead\",\n\t\t\t  pvolume_info->wsize);\n\t\tcifs_sb->wsize = 4096;\n\t} else if (pvolume_info->wsize)\n\t\tcifs_sb->wsize = pvolume_info->wsize;\n\telse\n\t\tcifs_sb->wsize = min_t(const int,\n\t\t\t\t\tPAGEVEC_SIZE * PAGE_CACHE_SIZE,\n\t\t\t\t\t127*1024);\n\t\t/* old default of CIFSMaxBufSize was too small now\n\t\t   that SMB Write2 can send multiple pages in kvec.\n\t\t   RFC1001 does not describe what happens when frame\n\t\t   bigger than 128K is sent so use that as max in\n\t\t   conjunction with 52K kvec constraint on arch with 4K\n\t\t   page size  */\n\n\tif (cifs_sb->rsize < 2048) {\n\t\tcifs_sb->rsize = 2048;\n\t\t/* Windows ME may prefer this */\n\t\tcFYI(1, \"readsize set to minimum: 2048\");\n\t}\n\t/* calculate prepath */\n\tcifs_sb->prepath = pvolume_info->prepath;\n\tif (cifs_sb->prepath) {\n\t\tcifs_sb->prepathlen = strlen(cifs_sb->prepath);\n\t\t/* we can not convert the / to \\ in the path\n\t\tseparators in the prefixpath yet because we do not\n\t\tknow (until reset_cifs_unix_caps is called later)\n\t\twhether POSIX PATH CAP is available. We normalize\n\t\tthe / to \\ after reset_cifs_unix_caps is called */\n\t\tpvolume_info->prepath = NULL;\n\t} else\n\t\tcifs_sb->prepathlen = 0;\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcFYI(1, \"file mode: 0x%x  dir mode: 0x%x\",\n\t\tcifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->direct_io) {\n\t\tcFYI(1, \"mounting share using direct i/o\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcERROR(1, \"mount option dynperm ignored if cifsacl \"\n\t\t\t   \"mount option supported\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void NaClListener::OnMsgStart(const nacl::NaClStartParams& params) {\n  struct NaClChromeMainArgs *args = NaClChromeMainArgsCreate();\n  if (args == NULL) {\n    LOG(ERROR) << \"NaClChromeMainArgsCreate() failed\";\n     return;\n   }\n \n  if (params.enable_ipc_proxy) {\n    IPC::ChannelHandle channel_handle =\n        IPC::Channel::GenerateVerifiedChannelID(\"nacl\");\n    scoped_refptr<NaClIPCAdapter> ipc_adapter(new NaClIPCAdapter(\n        channel_handle, io_thread_.message_loop_proxy()));\n    args->initial_ipc_desc = ipc_adapter.get()->MakeNaClDesc();\n#if defined(OS_POSIX)\n    channel_handle.socket = base::FileDescriptor(\n        ipc_adapter.get()->TakeClientFileDescriptor(), true);\n#endif\n    if (!Send(new NaClProcessHostMsg_PpapiChannelCreated(channel_handle)))\n      LOG(ERROR) << \"Failed to send IPC channel handle to renderer.\";\n  }\n   std::vector<nacl::FileDescriptor> handles = params.handles;\n \n #if defined(OS_LINUX) || defined(OS_MACOSX)\n  args->urandom_fd = dup(base::GetUrandomFD());\n  if (args->urandom_fd < 0) {\n    LOG(ERROR) << \"Failed to dup() the urandom FD\";\n    return;\n  }\n  args->create_memory_object_func = CreateMemoryObject;\n# if defined(OS_MACOSX)\n  CHECK(handles.size() >= 1);\n  g_shm_fd = nacl::ToNativeHandle(handles[handles.size() - 1]);\n  handles.pop_back();\n# endif\n#endif\n\n  CHECK(handles.size() >= 1);\n  NaClHandle irt_handle = nacl::ToNativeHandle(handles[handles.size() - 1]);\n  handles.pop_back();\n\n#if defined(OS_WIN)\n  args->irt_fd = _open_osfhandle(reinterpret_cast<intptr_t>(irt_handle),\n                                 _O_RDONLY | _O_BINARY);\n  if (args->irt_fd < 0) {\n    LOG(ERROR) << \"_open_osfhandle() failed\";\n    return;\n  }\n#else\n  args->irt_fd = irt_handle;\n#endif\n\n  if (params.validation_cache_enabled) {\n    CHECK_EQ(params.validation_cache_key.length(), (size_t) 64);\n    args->validation_cache = CreateValidationCache(\n        new BrowserValidationDBProxy(this), params.validation_cache_key,\n        params.version);\n  }\n\n  CHECK(handles.size() == 1);\n  args->imc_bootstrap_handle = nacl::ToNativeHandle(handles[0]);\n  args->enable_exception_handling = params.enable_exception_handling;\n  args->enable_debug_stub = params.enable_debug_stub;\n#if defined(OS_WIN)\n  args->broker_duplicate_handle_func = BrokerDuplicateHandle;\n  args->attach_debug_exception_handler_func = AttachDebugExceptionHandler;\n#endif\n  NaClChromeMainStart(args);\n  NOTREACHED();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "fr_print(netdissect_options *ndo,\n         register const u_char *p, u_int length)\n{\n\tint ret;\n\tuint16_t extracted_ethertype;\n\tu_int dlci;\n\tu_int addr_len;\n\tuint16_t nlpid;\n\tu_int hdr_len;\n\tuint8_t flags[4];\n\n\tret = parse_q922_addr(ndo, p, &dlci, &addr_len, flags, length);\n\tif (ret == -1)\n\t\tgoto trunc;\n\tif (ret == 0) {\n\t\tND_PRINT((ndo, \"Q.922, invalid address\"));\n\t\treturn 0;\n\t}\n\n\tND_TCHECK(p[addr_len]);\n\tif (length < addr_len + 1)\n\t\tgoto trunc;\n\n\tif (p[addr_len] != LLC_UI && dlci != 0) {\n                /*\n                 * Let's figure out if we have Cisco-style encapsulation,\n                 * with an Ethernet type (Cisco HDLC type?) following the\n                 * address.\n                 */\n\t\tif (!ND_TTEST2(p[addr_len], 2) || length < addr_len + 2) {\n                        /* no Ethertype */\n                        ND_PRINT((ndo, \"UI %02x! \", p[addr_len]));\n                } else {\n                        extracted_ethertype = EXTRACT_16BITS(p+addr_len);\n\n                        if (ndo->ndo_eflag)\n                                fr_hdr_print(ndo, length, addr_len, dlci,\n                                    flags, extracted_ethertype);\n\n                        if (ethertype_print(ndo, extracted_ethertype,\n                                            p+addr_len+ETHERTYPE_LEN,\n                                            length-addr_len-ETHERTYPE_LEN,\n                                            ndo->ndo_snapend-p-addr_len-ETHERTYPE_LEN,\n                                            NULL, NULL) == 0)\n                                /* ether_type not known, probably it wasn't one */\n                                ND_PRINT((ndo, \"UI %02x! \", p[addr_len]));\n                        else\n                                return addr_len + 2;\n                }\n        }\n\n\tND_TCHECK(p[addr_len+1]);\n\tif (length < addr_len + 2)\n\t\tgoto trunc;\n\n\tif (p[addr_len + 1] == 0) {\n\t\t/*\n\t\t * Assume a pad byte after the control (UI) byte.\n\t\t * A pad byte should only be used with 3-byte Q.922.\n\t\t */\n\t\tif (addr_len != 3)\n\t\t\tND_PRINT((ndo, \"Pad! \"));\n\t\thdr_len = addr_len + 1 /* UI */ + 1 /* pad */ + 1 /* NLPID */;\n\t} else {\n\t\t/*\n\t\t * Not a pad byte.\n\t\t * A pad byte should be used with 3-byte Q.922.\n\t\t */\n\t\tif (addr_len == 3)\n\t\t\tND_PRINT((ndo, \"No pad! \"));\n\t\thdr_len = addr_len + 1 /* UI */ + 1 /* NLPID */;\n\t}\n\n        ND_TCHECK(p[hdr_len - 1]);\n\tif (length < hdr_len)\n\t\tgoto trunc;\n\tnlpid = p[hdr_len - 1];\n\n\tif (ndo->ndo_eflag)\n\t\tfr_hdr_print(ndo, length, addr_len, dlci, flags, nlpid);\n\tp += hdr_len;\n\tlength -= hdr_len;\n\n\tswitch (nlpid) {\n\tcase NLPID_IP:\n\t        ip_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\n \tcase NLPID_CLNP:\n \tcase NLPID_ESIS:\n \tcase NLPID_ISIS:\n\t\tisoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1); /* OSI printers need the NLPID field */\n \t\tbreak;\n \n \tcase NLPID_SNAP:\n\t\tif (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {\n\t\t\t/* ether_type not known, print raw packet */\n                        if (!ndo->ndo_eflag)\n                            fr_hdr_print(ndo, length + hdr_len, hdr_len,\n                                         dlci, flags, nlpid);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p - hdr_len, length + hdr_len);\n\t\t}\n\t\tbreak;\n\n        case NLPID_Q933:\n\t\tq933_print(ndo, p, length);\n\t\tbreak;\n\n        case NLPID_MFR:\n                frf15_print(ndo, p, length);\n                break;\n\n        case NLPID_PPP:\n                ppp_print(ndo, p, length);\n                break;\n\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n                    fr_hdr_print(ndo, length + hdr_len, addr_len,\n\t\t\t\t     dlci, flags, nlpid);\n\t\tif (!ndo->ndo_xflag)\n\t\t\tND_DEFAULTPRINT(p, length);\n\t}\n\n\treturn hdr_len;\n\n trunc:\n        ND_PRINT((ndo, \"[|fr]\"));\n        return 0;\n\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n\n    /* DA filter.  */\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n     }\n \n     D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n \n     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    /* If c_rx_pingpong was set flip buffers.  */\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void FaviconSource::SendDefaultResponse(int request_id) {\n  if (!default_favicon_.get()) {\n    default_favicon_ =\n        ResourceBundle::GetSharedInstance().LoadDataResourceBytes(\n            IDR_DEFAULT_FAVICON);\n   }\n \n  SendResponse(request_id, default_favicon_);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "EncodedJSValue JSC_HOST_CALL jsTestActiveDOMObjectPrototypeFunctionPostMessage(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestActiveDOMObject::s_info))\n        return throwVMTypeError(exec);\n    JSTestActiveDOMObject* castedThis = jsCast<JSTestActiveDOMObject*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestActiveDOMObject::s_info);\n     TestActiveDOMObject* impl = static_cast<TestActiveDOMObject*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     const String& message(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->postMessage(message);\n    return JSValue::encode(jsUndefined());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n \tint err = 0;\n \n \ttu = file->private_data;\n\tmutex_lock(&tu->tread_sem);\n \tif (tu->timeri) {\n \t\tsnd_timer_close(tu->timeri);\n \t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n \t}\n \n       __err:\n      \tmutex_unlock(&tu->tread_sem);\n \treturn err;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool asn1_read_BOOLEAN_context(struct asn1_data *data, bool *v, int context)\n {\n        uint8_t tmp = 0;\n       asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(context));\n       asn1_read_uint8(data, &tmp);\n        if (tmp == 0xFF) {\n                *v = true;\n       } else {\n               *v = false;\n        }\n       asn1_end_tag(data);\n       return !data->has_error;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int hid_match_report(struct hid_device *hid, struct hid_report *report)\n{\n\tconst struct hid_report_id *id = hid->driver->report_table;\n\n\tif (!id) /* NULL means all */\n\t\treturn 1;\n\n\tfor (; id->report_type != HID_TERMINATOR; id++)\n\t\tif (id->report_type == HID_ANY_ID ||\n\t\t\t\tid->report_type == report->type)\n\t\t\treturn 1;\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "DWORD WtsSessionProcessDelegate::GetExitCode() {\n  if (!core_)\n    return CONTROL_C_EXIT;\n \n  return core_->GetExitCode();\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ChunkedUploadDataStream::~ChunkedUploadDataStream() {\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-311"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void MaybeRestoreConnections() {\n    if (IBusConnectionsAreAlive()) {\n      return;\n    }\n    MaybeCreateIBus();\n     MaybeRestoreIBusConfig();\n     if (IBusConnectionsAreAlive()) {\n       ConnectPanelServiceSignals();\n      if (connection_change_handler_) {\n        LOG(INFO) << \"Notifying Chrome that IBus is ready.\";\n        connection_change_handler_(language_library_, true);\n      }\n     }\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ValueChunk::SetValue( std::string value, bool optionalNUL /* = false */ )\n{\n\tthis->newValue.assign( value );\n\tif ( (! optionalNUL) || ((value.size() & 1) == 1) ) {\n\t\tthis->newValue.append( 1, '\\0' ); // append zero termination as explicit part of string\n\t}\n\tthis->newSize = this->newValue.size() + 8;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void HTMLCanvasElement::SetSurfaceSize(const IntSize& size) {\n  size_ = size;\n  did_fail_to_create_resource_provider_ = false;\n  DiscardResourceProvider();\n  if (Is2d() && context_->isContextLost())\n    context_->DidSetSurfaceSize();\n  if (frame_dispatcher_)\n    frame_dispatcher_->Reshape(size_);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "const CuePoint* Cues::GetFirst() const\n{\n    if (m_cue_points == NULL)\n        return NULL;\n    if (m_count == 0)\n        return NULL;\n \n #if 0\n     LoadCuePoint();  //init cues\n\n const size_t count = m_count + m_preload_count;\n\n if (count == 0) //weird\n\n         return NULL;\n #endif\n \n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n \n    CuePoint* const pCP = pp[0];\n    assert(pCP);\n    assert(pCP->GetTimeCode() >= 0);\n \n    return pCP;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SPL_METHOD(MultipleIterator, current)\n{\n\tspl_SplObjectStorage        *intern;\n\tintern = Z_SPLOBJSTORAGE_P(getThis());\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_multiple_iterator_get_all(intern, SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT, return_value);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadTTFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MaxTextExtent],\n    *text;\n\n  const char\n    *Text = (char *)\n      \"abcdefghijklmnopqrstuvwxyz\\n\"\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n\"\n      \"0123456789.:,;(*!?}^)#${%^&-+@\\n\";\n\n  const TypeInfo\n    *type_info;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelPacket\n    background_color;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  image->columns=800;\n  image->rows=480;\n  type_info=GetTypeInfo(image_info->filename,exception);\n  if ((type_info != (const TypeInfo *) NULL) &&\n      (type_info->glyphs != (char *) NULL))\n    (void) CopyMagickString(image->filename,type_info->glyphs,MaxTextExtent);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   /*\n     Color canvas with background color\n   */\n  background_color=image_info->background_color;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n      *q++=background_color;\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n  (void) CopyMagickString(image->magick,image_info->magick,MaxTextExtent);\n  (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);\n  /*\n    Prepare drawing commands\n  */\n  y=20;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->font=AcquireString(image->filename);\n  ConcatenateString(&draw_info->primitive,\"push graphic-context\\n\");\n  (void) FormatLocaleString(buffer,MaxTextExtent,\" viewbox 0 0 %.20g %.20g\\n\",\n    (double) image->columns,(double) image->rows);\n  ConcatenateString(&draw_info->primitive,buffer);\n  ConcatenateString(&draw_info->primitive,\" font-size 18\\n\");\n  (void) FormatLocaleString(buffer,MaxTextExtent,\" text 10,%.20g '\",(double) y);\n  ConcatenateString(&draw_info->primitive,buffer);\n  text=EscapeString(Text,'\"');\n  ConcatenateString(&draw_info->primitive,text);\n  text=DestroyString(text);\n  (void) FormatLocaleString(buffer,MaxTextExtent,\"'\\n\");\n  ConcatenateString(&draw_info->primitive,buffer);\n  y+=20*(ssize_t) MultilineCensus((char *) Text)+20;\n  for (i=12; i <= 72; i+=6)\n  {\n    y+=i+12;\n    ConcatenateString(&draw_info->primitive,\" font-size 18\\n\");\n    (void) FormatLocaleString(buffer,MaxTextExtent,\" text 10,%.20g '%.20g'\\n\",\n      (double) y,(double) i);\n    ConcatenateString(&draw_info->primitive,buffer);\n    (void) FormatLocaleString(buffer,MaxTextExtent,\" font-size %.20g\\n\",\n      (double) i);\n    ConcatenateString(&draw_info->primitive,buffer);\n    (void) FormatLocaleString(buffer,MaxTextExtent,\" text 50,%.20g \"\n      \"'That which does not destroy me, only makes me stronger.'\\n\",(double) y);\n    ConcatenateString(&draw_info->primitive,buffer);\n    if (i >= 24)\n      i+=6;\n  }\n  ConcatenateString(&draw_info->primitive,\"pop graphic-context\");\n  (void) DrawImage(image,draw_info);\n  /*\n    Relinquish resources.\n  */\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PHP_FUNCTION(openssl_seal)\n{\n\tzval *pubkeys, *pubkey, *sealdata, *ekeys, *iv = NULL;\n\tHashTable *pubkeysht;\n\tEVP_PKEY **pkeys;\n\tzend_resource ** key_resources;\t/* so we know what to cleanup */\n\tint i, len1, len2, *eksl, nkeys, iv_len;\n\tunsigned char iv_buf[EVP_MAX_IV_LENGTH + 1], *buf = NULL, **eks;\n\tchar * data;\n\tsize_t data_len;\n\tchar *method =NULL;\n\tsize_t method_len = 0;\n\tconst EVP_CIPHER *cipher;\n\tEVP_CIPHER_CTX *ctx;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/z/a/|sz/\", &data, &data_len,\n\t\t\t\t&sealdata, &ekeys, &pubkeys, &method, &method_len, &iv) == FAILURE) {\n\t\treturn;\n\t}\n\tpubkeysht = Z_ARRVAL_P(pubkeys);\n\tnkeys = pubkeysht ? zend_hash_num_elements(pubkeysht) : 0;\n\tif (!nkeys) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Fourth argument to openssl_seal() must be a non-empty array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(data_len, data);\n\n\tif (method) {\n\t\tcipher = EVP_get_cipherbyname(method);\n\t\tif (!cipher) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Unknown signature algorithm.\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tcipher = EVP_rc4();\n\t}\n\n\tiv_len = EVP_CIPHER_iv_length(cipher);\n\tif (!iv && iv_len > 0) {\n\t\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\t\"Cipher algorithm requires an IV to be supplied as a sixth parameter\");\n\t\tRETURN_FALSE;\n\t}\n\n\tpkeys = safe_emalloc(nkeys, sizeof(*pkeys), 0);\n\teksl = safe_emalloc(nkeys, sizeof(*eksl), 0);\n\teks = safe_emalloc(nkeys, sizeof(*eks), 0);\n\tmemset(eks, 0, sizeof(*eks) * nkeys);\n\tkey_resources = safe_emalloc(nkeys, sizeof(zend_resource*), 0);\n\tmemset(key_resources, 0, sizeof(zend_resource*) * nkeys);\n\tmemset(pkeys, 0, sizeof(*pkeys) * nkeys);\n\n\t/* get the public keys we are using to seal this data */\n\ti = 0;\n\tZEND_HASH_FOREACH_VAL(pubkeysht, pubkey) {\n\t\tpkeys[i] = php_openssl_evp_from_zval(pubkey, 1, NULL, 0, 0, &key_resources[i]);\n\t\tif (pkeys[i] == NULL) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"not a public key (%dth member of pubkeys)\", i+1);\n\t\t\tRETVAL_FALSE;\n\t\t\tgoto clean_exit;\n\t\t}\n\t\teks[i] = emalloc(EVP_PKEY_size(pkeys[i]) + 1);\n\t\ti++;\n\t} ZEND_HASH_FOREACH_END();\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL || !EVP_EncryptInit(ctx,cipher,NULL,NULL)) {\n\t\tEVP_CIPHER_CTX_free(ctx);\n\t\tRETVAL_FALSE;\n\t\tgoto clean_exit;\n\t}\n\n\t/* allocate one byte extra to make room for \\0 */\n        buf = emalloc(data_len + EVP_CIPHER_CTX_block_size(ctx));\n        EVP_CIPHER_CTX_cleanup(ctx);\n \n       if (!EVP_SealInit(ctx, cipher, eks, eksl, &iv_buf[0], pkeys, nkeys) ||\n                        !EVP_SealUpdate(ctx, buf, &len1, (unsigned char *)data, (int)data_len) ||\n                        !EVP_SealFinal(ctx, buf + len1, &len2)) {\n                RETVAL_FALSE;\n\t\tefree(buf);\n\t\tEVP_CIPHER_CTX_free(ctx);\n\t\tgoto clean_exit;\n\t}\n\n\tif (len1 + len2 > 0) {\n\t\tzval_dtor(sealdata);\n\t\tZVAL_NEW_STR(sealdata, zend_string_init((char*)buf, len1 + len2, 0));\n\t\tefree(buf);\n\n\t\tzval_dtor(ekeys);\n\t\tarray_init(ekeys);\n\t\tfor (i=0; i<nkeys; i++) {\n\t\t\teks[i][eksl[i]] = '\\0';\n\t\t\tadd_next_index_stringl(ekeys, (const char*)eks[i], eksl[i]);\n\t\t\tefree(eks[i]);\n\t\t\teks[i] = NULL;\n\t\t}\n\n\t\tif (iv) {\n\t\t\tzval_dtor(iv);\n\t\t\tiv_buf[iv_len] = '\\0';\n\t\t\tZVAL_NEW_STR(iv, zend_string_init((char*)iv_buf, iv_len, 0));\n\t\t}\n\t} else {\n\t\tefree(buf);\n\t}\n\tRETVAL_LONG(len1 + len2);\n\tEVP_CIPHER_CTX_free(ctx);\n\nclean_exit:\n\tfor (i=0; i<nkeys; i++) {\n\t\tif (key_resources[i] == NULL && pkeys[i] != NULL) {\n\t\t\tEVP_PKEY_free(pkeys[i]);\n\t\t}\n\t\tif (eks[i]) {\n\t\t\tefree(eks[i]);\n\t\t}\n\t}\n\tefree(eks);\n\tefree(eksl);\n\tefree(pkeys);\n\tefree(key_resources);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-754"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void MediaStreamDispatcherHost::DoOpenDevice(\n    int32_t page_request_id,\n    const std::string& device_id,\n    blink::MediaStreamType type,\n    OpenDeviceCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(false /* success */, std::string(),\n                            blink::MediaStreamDevice());\n    return;\n   }\n \n   media_stream_manager_->OpenDevice(\n      render_process_id_, render_frame_id_, page_request_id, requester_id_,\n       device_id, type, std::move(salt_and_origin), std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int compat_packet_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct packet_sock *po = pkt_sk(sock->sk);\n\n\tif (level != SOL_PACKET)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname == PACKET_FANOUT_DATA &&\n\t    po->fanout && po->fanout->type == PACKET_FANOUT_CBPF) {\n\t\toptval = (char __user *)get_compat_bpf_fprog(optval);\n\t\tif (!optval)\n\t\t\treturn -EFAULT;\n\t\toptlen = sizeof(struct sock_fprog);\n\t}\n\n\treturn packet_setsockopt(sock, level, optname, optval, optlen);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void seed_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\n{\n\tconst struct seed_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst __be32 *src = (const __be32 *)in;\n\t__be32 *dst = (__be32 *)out;\n\tu32 x1, x2, x3, x4, t0, t1;\n\tconst u32 *ks = ctx->keysched;\n\n\tx1 = be32_to_cpu(src[0]);\n\tx2 = be32_to_cpu(src[1]);\n\tx3 = be32_to_cpu(src[2]);\n\tx4 = be32_to_cpu(src[3]);\n\n\tOP(x1, x2, x3, x4, 30);\n\tOP(x3, x4, x1, x2, 28);\n\tOP(x1, x2, x3, x4, 26);\n\tOP(x3, x4, x1, x2, 24);\n\tOP(x1, x2, x3, x4, 22);\n\tOP(x3, x4, x1, x2, 20);\n\tOP(x1, x2, x3, x4, 18);\n\tOP(x3, x4, x1, x2, 16);\n\tOP(x1, x2, x3, x4, 14);\n\tOP(x3, x4, x1, x2, 12);\n\tOP(x1, x2, x3, x4, 10);\n\tOP(x3, x4, x1, x2, 8);\n\tOP(x1, x2, x3, x4, 6);\n\tOP(x3, x4, x1, x2, 4);\n\tOP(x1, x2, x3, x4, 2);\n\tOP(x3, x4, x1, x2, 0);\n\n\tdst[0] = cpu_to_be32(x3);\n\tdst[1] = cpu_to_be32(x4);\n\tdst[2] = cpu_to_be32(x1);\n\tdst[3] = cpu_to_be32(x2);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n\t\t\t\t\t    struct page **hpage)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint progress = 0;\n\n\tVM_BUG_ON(!pages);\n\tVM_BUG_ON(!spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_scan.mm_slot)\n\t\tmm_slot = khugepaged_scan.mm_slot;\n\telse {\n\t\tmm_slot = list_entry(khugepaged_scan.mm_head.next,\n\t\t\t\t     struct mm_slot, mm_node);\n\t\tkhugepaged_scan.address = 0;\n\t\tkhugepaged_scan.mm_slot = mm_slot;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmm = mm_slot->mm;\n\tdown_read(&mm->mmap_sem);\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\tvma = NULL;\n\telse\n\t\tvma = find_vma(mm, khugepaged_scan.address);\n\n\tprogress++;\n\tfor (; vma; vma = vma->vm_next) {\n\t\tunsigned long hstart, hend;\n\n\t\tcond_resched();\n\t\tif (unlikely(khugepaged_test_exit(mm))) {\n\t\t\tprogress++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((!(vma->vm_flags & VM_HUGEPAGE) &&\n\t\t     !khugepaged_always()) ||\n\t\t    (vma->vm_flags & VM_NOHUGEPAGE)) {\n\t\tskip:\n \t\t\tprogress++;\n \t\t\tcontinue;\n \t\t}\n\t\t/* VM_PFNMAP vmas may have vm_ops null but vm_file set */\n\t\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n \t\t\tgoto skip;\n \t\tif (is_vma_temporary_stack(vma))\n \t\t\tgoto skip;\n\t\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n \n \t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n \t\thend = vma->vm_end & HPAGE_PMD_MASK;\n\t\tif (hstart >= hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address > hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address < hstart)\n\t\t\tkhugepaged_scan.address = hstart;\n\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n\n\t\twhile (khugepaged_scan.address < hend) {\n\t\t\tint ret;\n\t\t\tcond_resched();\n\t\t\tif (unlikely(khugepaged_test_exit(mm)))\n\t\t\t\tgoto breakouterloop;\n\n\t\t\tVM_BUG_ON(khugepaged_scan.address < hstart ||\n\t\t\t\t  khugepaged_scan.address + HPAGE_PMD_SIZE >\n\t\t\t\t  hend);\n\t\t\tret = khugepaged_scan_pmd(mm, vma,\n\t\t\t\t\t\t  khugepaged_scan.address,\n\t\t\t\t\t\t  hpage);\n\t\t\t/* move to next address */\n\t\t\tkhugepaged_scan.address += HPAGE_PMD_SIZE;\n\t\t\tprogress += HPAGE_PMD_NR;\n\t\t\tif (ret)\n\t\t\t\t/* we released mmap_sem so break loop */\n\t\t\t\tgoto breakouterloop_mmap_sem;\n\t\t\tif (progress >= pages)\n\t\t\t\tgoto breakouterloop;\n\t\t}\n\t}\nbreakouterloop:\n\tup_read(&mm->mmap_sem); /* exit_mmap will destroy ptes after this */\nbreakouterloop_mmap_sem:\n\n\tspin_lock(&khugepaged_mm_lock);\n\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n\t/*\n\t * Release the current mm_slot if this mm is about to die, or\n\t * if we scanned all vmas of this mm.\n\t */\n\tif (khugepaged_test_exit(mm) || !vma) {\n\t\t/*\n\t\t * Make sure that if mm_users is reaching zero while\n\t\t * khugepaged runs here, khugepaged_exit will find\n\t\t * mm_slot not pointing to the exiting mm.\n\t\t */\n\t\tif (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {\n\t\t\tkhugepaged_scan.mm_slot = list_entry(\n\t\t\t\tmm_slot->mm_node.next,\n\t\t\t\tstruct mm_slot, mm_node);\n\t\t\tkhugepaged_scan.address = 0;\n\t\t} else {\n\t\t\tkhugepaged_scan.mm_slot = NULL;\n\t\t\tkhugepaged_full_scans++;\n\t\t}\n\n\t\tcollect_mm_slot(mm_slot);\n\t}\n\n\treturn progress;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OMX_ERRORTYPE SoftMP3::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioMp3:\n {\n\n             OMX_AUDIO_PARAM_MP3TYPE *mp3Params =\n                 (OMX_AUDIO_PARAM_MP3TYPE *)params;\n \n             if (mp3Params->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mp3Params->nChannels = mNumChannels;\n            mp3Params->nBitRate = 0 /* unknown */;\n            mp3Params->nSampleRate = mSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "page_cgroup_zoneinfo(struct mem_cgroup *memcg, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tint zid = page_zonenum(page);\n\n\treturn mem_cgroup_zoneinfo(memcg, nid, zid);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "size_t GraphicBuffer::getFdCount() const {\n return handle ? handle->numFds : 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long Cluster::Load(long long& pos, long& len) const\n{\n    assert(m_pSegment);\n    assert(m_pos >= m_element_start);\n \n    if (m_timecode >= 0)  //at least partially loaded\n        return 0;\n \n    assert(m_pos == m_element_start);\n    assert(m_element_size < 0);\n \n    IMkvReader* const pReader = m_pSegment->m_pReader;\n \n    long long total, avail;\n \n    const int status = pReader->Length(&total, &avail);\n \n    if (status < 0)  //error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n    assert((total < 0) || (m_pos <= total));  //TODO: verify this\n \n    pos = m_pos;\n \n    long long cluster_size = -1;\n    {\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error or underflow\n            return static_cast<long>(result);\n        if (result > 0)  //underflow (weird)\n            return E_BUFFER_NOT_FULL;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id_ = ReadUInt(pReader, pos, len);\n        if (id_ < 0)  //error\n            return static_cast<long>(id_);\n        if (id_ != 0x0F43B675)  //Cluster ID\n            return E_FILE_FORMAT_INVALID;\n        pos += len;  //consume id\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return static_cast<long>(cluster_size);\n        if (size == 0)\n            return E_FILE_FORMAT_INVALID;  //TODO: verify this\n        pos += len;  //consume length of size of element\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size != unknown_size)\n            cluster_size = size;\n     }\n \n//// pos points to start of payload\n \n #if 0\n     len = static_cast<long>(size_);\n\n if (cluster_stop > avail)\n\n         return E_BUFFER_NOT_FULL;\n #endif\n \n    long long timecode = -1;\n    long long new_pos = -1;\n    bool bBlock = false;\n \n    long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;\n \n    for (;;)\n    {\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            break;\n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0) //error\n            return static_cast<long>(id);\n        if (id == 0)\n            return E_FILE_FORMAT_INVALID;\n        if (id == 0x0F43B675)  //Cluster ID\n            break;\n        if (id == 0x0C53BB6B)  //Cues ID\n            break;\n        pos += len;  //consume ID field\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return static_cast<long>(size);\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n        pos += len;  //consume size field\n        if ((cluster_stop >= 0) && (pos > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (size == 0)  //weird\n            continue;\n        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (id == 0x67)  //TimeCode ID\n        {\n            len = static_cast<long>(size);\n            if ((pos + size) > avail)\n                return E_BUFFER_NOT_FULL;\n            timecode = UnserializeUInt(pReader, pos, size);\n            if (timecode < 0)  //error (or underflow)\n                return static_cast<long>(timecode);\n            new_pos = pos + size;\n            if (bBlock)\n                break;\n        }\n        else if (id == 0x20)  //BlockGroup ID\n        {\n            bBlock = true;\n            break;\n        }\n        else if (id == 0x23)  //SimpleBlock ID\n        {\n            bBlock = true;\n            break;\n        }\n        pos += size;  //consume payload\n        assert((cluster_stop < 0) || (pos <= cluster_stop));\n    }\n    assert((cluster_stop < 0) || (pos <= cluster_stop));\n    if (timecode < 0)  //no timecode found\n        return E_FILE_FORMAT_INVALID;\n    if (!bBlock)\n        return E_FILE_FORMAT_INVALID;\n    m_pos = new_pos;  //designates position just beyond timecode payload\n    m_timecode = timecode;  // m_timecode >= 0 means we're partially loaded\n    if (cluster_size >= 0)\n        m_element_size = cluster_stop - m_element_start;\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GLES2Implementation::StencilThenCoverFillPathInstancedCHROMIUM(\n    GLsizei num_paths,\n    GLenum path_name_type,\n    const GLvoid* paths,\n    GLuint path_base,\n    GLenum fill_mode,\n    GLuint mask,\n    GLenum cover_mode,\n    GLenum transform_type,\n    const GLfloat* transform_values) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\n      \"[\" << GetLogPrefix() << \"] glStencilThenCoverFillPathInstancedCHROMIUM(\"\n          << num_paths << \", \" << path_name_type << \", \" << paths << \", \"\n          << path_base << \", \" << cover_mode << \", \" << fill_mode << \", \"\n          << mask << \", \" << transform_type << \", \" << transform_values << \")\");\n\n  ScopedTransferBufferPtr buffer(helper_, transfer_buffer_);\n  uint32_t paths_shm_id = 0;\n  uint32_t paths_offset = 0;\n  uint32_t transforms_shm_id = 0;\n  uint32_t transforms_offset = 0;\n  if (!PrepareInstancedPathCommand(\n          \"glStencilThenCoverFillPathInstancedCHROMIUM\", num_paths,\n          path_name_type, paths, transform_type, transform_values, &buffer,\n          &paths_shm_id, &paths_offset, &transforms_shm_id,\n          &transforms_offset)) {\n    return;\n  }\n\n  helper_->StencilThenCoverFillPathInstancedCHROMIUM(\n      num_paths, path_name_type, paths_shm_id, paths_offset, path_base,\n      fill_mode, mask, cover_mode, transform_type, transforms_shm_id,\n      transforms_offset);\n\n  CheckGLError();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ChunkedUploadDataStream::AppendData(\n    const char* data, int data_len, bool is_done) {\n  DCHECK(!all_data_appended_);\n  DCHECK(data_len > 0 || is_done);\n   if (data_len > 0) {\n     DCHECK(data);\n     upload_data_.push_back(\n        base::MakeUnique<std::vector<char>>(data, data + data_len));\n   }\n   all_data_appended_ = is_done;\n \n  if (!read_buffer_.get())\n    return;\n\n  int result = ReadChunk(read_buffer_.get(), read_buffer_len_);\n  DCHECK_GE(result, 0);\n  read_buffer_ = NULL;\n  read_buffer_len_ = 0;\n  OnReadCompleted(result);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-311"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void perWorldAttributeAttributeSetterForMainWorld(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_VOID(TestObject*, cppValue, V8TestObject::toNativeWithTypeCheck(info.GetIsolate(), jsValue));\n    imp->setPerWorldAttribute(WTF::getPtr(cppValue));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void btif_hl_init(void){\n    BTIF_TRACE_DEBUG(\"%s\", __FUNCTION__);\n    memset(p_btif_hl_cb, 0, sizeof(btif_hl_cb_t));\n    btif_hl_init_next_app_id();\n    btif_hl_init_next_channel_id();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "METHODDEF(JDIMENSION)\nget_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PPM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = *bufferptr++;\n      JSAMPLE g = *bufferptr++;\n      JSAMPLE b = *bufferptr++;\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = rescale[UCH(*bufferptr++)];\n      JSAMPLE g = rescale[UCH(*bufferptr++)];\n      JSAMPLE b = rescale[UCH(*bufferptr++)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void WebResourceService::StartFetch() {\n  ScheduleFetch(cache_update_delay_ms_);\n\n  prefs_->SetString(last_update_time_pref_name_,\n                    base::DoubleToString(base::Time::Now().ToDoubleT()));\n\n  if (in_fetch_)\n    return;\n  in_fetch_ = true;\n\n  GURL web_resource_server =\n      application_locale_.empty()\n          ? web_resource_server_\n          : google_util::AppendGoogleLocaleParam(web_resource_server_,\n                                                 application_locale_);\n\n   DVLOG(1) << \"WebResourceService StartFetch \" << web_resource_server;\n   url_fetcher_ =\n       net::URLFetcher::Create(web_resource_server, net::URLFetcher::GET, this);\n   url_fetcher_->SetLoadFlags(net::LOAD_DISABLE_CACHE |\n                             net::LOAD_DO_NOT_SEND_COOKIES |\n                             net::LOAD_DO_NOT_SAVE_COOKIES);\n  url_fetcher_->SetRequestContext(request_context_.get());\n  url_fetcher_->Start();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate(\n    content::ResourceContext* resource_context) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(resource_context);\n  if (!io_data->safe_browsing_enabled()->GetValue())\n    return nullptr;\n\n  if (safe_browsing_service_ && !safe_browsing_url_checker_delegate_) {\n    safe_browsing_url_checker_delegate_ =\n        base::MakeRefCounted<safe_browsing::UrlCheckerDelegateImpl>(\n            safe_browsing_service_->database_manager(),\n            safe_browsing_service_->ui_manager());\n  }\n\n  return safe_browsing_url_checker_delegate_.get();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "error::Error GLES2DecoderPassthroughImpl::DoGenRenderbuffers(\n    GLsizei n,\n    volatile GLuint* renderbuffers) {\n  return GenHelper(n, renderbuffers, &resources_->renderbuffer_id_map,\n                   [this](GLsizei n, GLuint* renderbuffers) {\n                     api()->glGenRenderbuffersEXTFn(n, renderbuffers);\n                   });\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "media::interfaces::ServiceFactory* RenderFrameImpl::GetMediaServiceFactory() {\n   if (!media_service_factory_) {\n    mojo::InterfacePtr<mojo::Shell> shell_ptr;\n    GetServiceRegistry()->ConnectToRemoteService(mojo::GetProxy(&shell_ptr));\n    mojo::ServiceProviderPtr service_provider;\n    mojo::URLRequestPtr request(mojo::URLRequest::New());\n    request->url = mojo::String::From(\"mojo:media\");\n    shell_ptr->ConnectToApplication(request.Pass(), GetProxy(&service_provider),\n                                    nullptr, nullptr);\n     mojo::ConnectToService(service_provider.get(), &media_service_factory_);\n     media_service_factory_.set_connection_error_handler(\n         base::Bind(&RenderFrameImpl::OnMediaServiceFactoryConnectionError,\n                    base::Unretained(this)));\n  }\n\n  return media_service_factory_.get();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\n \t/* Restore final destination back after routing done */\n \tfl6.daddr = sk->sk_v6_daddr;\n \n\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n \trcu_read_unlock();\n \treturn res;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void unix_inflight(struct file *fp)\n {\n \tstruct sock *s = unix_get_socket(fp);\n \n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n \t\t}\n \t\tunix_tot_inflight++;\n \t}\n\tfp->f_cred->user->unix_inflight++;\n \tspin_unlock(&unix_gc_lock);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Browser::CanGoBack() const {\n  return GetSelectedTabContentsWrapper()->controller().CanGoBack();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kNGroupsOffset = 12;\n const size_t kFirstGroupOffset = 16;\n const size_t kGroupSize = 12;\n const size_t kStartCharCodeOffset = 0;\n const size_t kEndCharCodeOffset = 4;\n const size_t kMaxNGroups = 0xfffffff0 / kGroupSize; // protection against overflow\n if (kFirstGroupOffset > size) {\n return false;\n\n     }\n     uint32_t nGroups = readU32(data, kNGroupsOffset);\n     if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {\n         return false;\n     }\n     for (uint32_t i = 0; i < nGroups; i++) {\n uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n\n         uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n         if (end < start) {\n             return false;\n         }\n         addRange(coverage, start, end + 1);  // file is inclusive, vector is exclusive\n }\n return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n {\n \tint ret = 0;\n \tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n \tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n \n \tresp.qp_tab_size = hr_dev->caps.num_qps;\n\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\n\treturn &context->ibucontext;\n\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\n\nerror_fail_uar_alloc:\n\tkfree(context);\n\n\treturn ERR_PTR(ret);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-665"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n\n\n    offset_start = offset;\n\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n         /* XXX - set reasonable default values for all components\n            that are not filled in by this function */\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;\n\n    /* version 1 refers to the Basic Audio Device specification,\n       version 2 is the Audio Device class specification, see above */\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n\n    return offset-offset_start;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void fdct16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct16x16_c(in, out, stride);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SelectionInDOMTree ConvertToSelectionInDOMTree(\n    const SelectionInFlatTree& selection_in_flat_tree) {\n  return SelectionInDOMTree::Builder()\n      .SetAffinity(selection_in_flat_tree.Affinity())\n       .SetBaseAndExtent(ToPositionInDOMTree(selection_in_flat_tree.Base()),\n                         ToPositionInDOMTree(selection_in_flat_tree.Extent()))\n       .SetIsDirectional(selection_in_flat_tree.IsDirectional())\n      .SetIsHandleVisible(selection_in_flat_tree.IsHandleVisible())\n       .Build();\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int getnum (lua_State *L, const char **fmt, int df) {\n   if (!isdigit(**fmt))  /* no number? */\n     return df;  /* return default value */\n   else {\n     int a = 0;\n     do {\n      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \"integral size overflow\");\n       a = a*10 + *((*fmt)++) - '0';\n     } while (isdigit(**fmt));\n     return a;\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int rd_build_device_space(struct rd_dev *rd_dev)\n {\n\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n \tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n \t\t\t\tsizeof(struct scatterlist));\n\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n\tif (rd_dev->rd_page_count <= 0) {\n\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n\t\t\trd_dev->rd_page_count);\n\t\treturn -EINVAL;\n\t}\n\t/* Don't need backing pages for NULLIO */\n\tif (rd_dev->rd_flags & RDF_NULLIO)\n\t\treturn 0;\n\ttotal_sg_needed = rd_dev->rd_page_count;\n\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n\tif (!sg_table) {\n\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n\t\t\t\" scatterlist tables\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trd_dev->sg_table_array = sg_table;\n\trd_dev->sg_table_count = sg_tables;\n \n \twhile (total_sg_needed) {\n \t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tsg_init_table(sg, sg_per_table);\n\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n \t\t\t}\n \t\t\tsg_assign_page(&sg[j], pg);\n \t\t\tsg[j].length = PAGE_SIZE;\n \t\t}\n \n \t\tpage_offset += sg_per_table;\n \t\ttotal_sg_needed -= sg_per_table;\n \t}\n \n \tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"\n\t\t\" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\trd_dev->sg_table_count);\n \n \treturn 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "InputImeEventRouterFactory::InputImeEventRouterFactory() {\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void WallpaperManager::OnDefaultWallpaperDecoded(\n     const base::FilePath& path,\n     const wallpaper::WallpaperLayout layout,\n     std::unique_ptr<user_manager::UserImage>* result_out,\n     MovableOnDestroyCallbackHolder on_finish,\n     std::unique_ptr<user_manager::UserImage> user_image) {\n  if (user_image->image().isNull()) {\n    LOG(ERROR) << \"Failed to decode default wallpaper. \";\n    return;\n   }\n \n   *result_out = std::move(user_image);\n  WallpaperInfo info(path.value(), layout, wallpaper::DEFAULT,\n                     base::Time::Now().LocalMidnight());\n  SetWallpaper((*result_out)->image(), info);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Resource::RemoveFinishObserver(ResourceFinishObserver* client) {\n  CHECK(!is_add_remove_client_prohibited_);\n\n  finish_observers_.erase(client);\n  DidRemoveClientOrObserver();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long long Cluster::GetLastTime() const\n{\n    const BlockEntry* pEntry;\n    const long status = GetLast(pEntry);\n    if (status < 0)  //error\n        return status;\n    if (pEntry == NULL)  //empty cluster\n        return GetTime();\n    const Block* const pBlock = pEntry->GetBlock();\n    assert(pBlock);\n    return pBlock->GetTime(this);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "LockScreenMediaControlsView::LockScreenMediaControlsView(\n    service_manager::Connector* connector,\n    const Callbacks& callbacks)\n    : connector_(connector),\n      hide_controls_timer_(new base::OneShotTimer()),\n      media_controls_enabled_(callbacks.media_controls_enabled),\n      hide_media_controls_(callbacks.hide_media_controls),\n      show_media_controls_(callbacks.show_media_controls) {\n  DCHECK(callbacks.media_controls_enabled);\n  DCHECK(callbacks.hide_media_controls);\n  DCHECK(callbacks.show_media_controls);\n\n  Shell::Get()->media_controller()->SetMediaControlsDismissed(false);\n\n  middle_spacing_ = std::make_unique<NonAccessibleView>();\n  middle_spacing_->set_owned_by_client();\n\n  set_notify_enter_exit_on_child(true);\n \n   contents_view_ = AddChildView(std::make_unique<views::View>());\n   contents_view_->SetLayoutManager(std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kVertical));\n   contents_view_->SetBackground(views::CreateRoundedRectBackground(\n       kMediaControlsBackground, kMediaControlsCornerRadius));\n \n   contents_view_->SetPaintToLayer();  // Needed for opacity animation.\n   contents_view_->layer()->SetFillsBoundsOpaquely(false);\n \n  auto close_button_row = std::make_unique<NonAccessibleView>();\n  views::GridLayout* close_button_layout =\n      close_button_row->SetLayoutManager(std::make_unique<views::GridLayout>());\n  views::ColumnSet* columns = close_button_layout->AddColumnSet(0);\n  columns->AddPaddingColumn(0, kCloseButtonOffset);\n  columns->AddColumn(views::GridLayout::CENTER, views::GridLayout::CENTER, 0,\n                     views::GridLayout::USE_PREF, 0, 0);\n  close_button_layout->StartRowWithPadding(\n      0, 0, 0, 5 /* padding between close button and top of view */);\n  auto close_button = CreateVectorImageButton(this);\n  SetImageFromVectorIcon(close_button.get(), vector_icons::kCloseRoundedIcon,\n                         kCloseButtonIconSize, gfx::kGoogleGrey700);\n  close_button->SetPreferredSize(kCloseButtonSize);\n  close_button->SetFocusBehavior(View::FocusBehavior::ALWAYS);\n  base::string16 close_button_label(\n      l10n_util::GetStringUTF16(IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_CLOSE));\n  close_button->SetAccessibleName(close_button_label);\n  close_button_ = close_button_layout->AddView(std::move(close_button));\n  close_button_->SetVisible(false);\n  contents_view_->AddChildView(std::move(close_button_row));\n  header_row_ =\n      contents_view_->AddChildView(std::make_unique<MediaControlsHeaderView>());\n \n   auto session_artwork = std::make_unique<views::ImageView>();\n  session_artwork->SetPreferredSize(\n      gfx::Size(kArtworkViewWidth, kArtworkViewHeight));\n  session_artwork->SetBorder(views::CreateEmptyBorder(kArtworkInsets));\n   session_artwork_ = contents_view_->AddChildView(std::move(session_artwork));\n \n   progress_ = contents_view_->AddChildView(\n      std::make_unique<media_message_center::MediaControlsProgressView>(\n          base::BindRepeating(&LockScreenMediaControlsView::SeekTo,\n                              base::Unretained(this))));\n\n  auto button_row = std::make_unique<NonAccessibleView>();\n  auto* button_row_layout =\n      button_row->SetLayoutManager(std::make_unique<views::BoxLayout>(\n          views::BoxLayout::Orientation::kHorizontal, kButtonRowInsets,\n          kMediaButtonRowSeparator));\n  button_row_layout->set_cross_axis_alignment(\n      views::BoxLayout::CrossAxisAlignment::kCenter);\n  button_row_layout->set_main_axis_alignment(\n      views::BoxLayout::MainAxisAlignment::kCenter);\n  button_row->SetPreferredSize(kMediaControlsButtonRowSize);\n  button_row_ = contents_view_->AddChildView(std::move(button_row));\n\n  CreateMediaButton(\n      kChangeTrackIconSize, MediaSessionAction::kPreviousTrack,\n      l10n_util::GetStringUTF16(\n          IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_PREVIOUS_TRACK));\n\n  CreateMediaButton(\n      kSeekingIconsSize, MediaSessionAction::kSeekBackward,\n      l10n_util::GetStringUTF16(\n          IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_SEEK_BACKWARD));\n\n  auto play_pause_button = views::CreateVectorToggleImageButton(this);\n  play_pause_button->set_tag(static_cast<int>(MediaSessionAction::kPause));\n  play_pause_button->SetPreferredSize(kMediaButtonSize);\n  play_pause_button->SetFocusBehavior(views::View::FocusBehavior::ALWAYS);\n  play_pause_button->SetTooltipText(l10n_util::GetStringUTF16(\n      IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_PAUSE));\n  play_pause_button->SetToggledTooltipText(l10n_util::GetStringUTF16(\n      IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_PLAY));\n  play_pause_button_ = button_row_->AddChildView(std::move(play_pause_button));\n\n  views::SetImageFromVectorIcon(\n      play_pause_button_,\n      GetVectorIconForMediaAction(MediaSessionAction::kPause),\n      kPlayPauseIconSize, kMediaButtonColor);\n  views::SetToggledImageFromVectorIcon(\n      play_pause_button_,\n      GetVectorIconForMediaAction(MediaSessionAction::kPlay),\n      kPlayPauseIconSize, kMediaButtonColor);\n\n  CreateMediaButton(\n      kSeekingIconsSize, MediaSessionAction::kSeekForward,\n      l10n_util::GetStringUTF16(\n          IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_SEEK_FORWARD));\n\n  CreateMediaButton(kChangeTrackIconSize, MediaSessionAction::kNextTrack,\n                    l10n_util::GetStringUTF16(\n                        IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_NEXT_TRACK));\n\n  MediaSessionMetadataChanged(base::nullopt);\n  MediaSessionPositionChanged(base::nullopt);\n  MediaControllerImageChanged(\n      media_session::mojom::MediaSessionImageType::kSourceIcon, SkBitmap());\n  SetArtwork(base::nullopt);\n\n  if (!connector_)\n    return;\n\n  mojo::Remote<media_session::mojom::MediaControllerManager>\n      controller_manager_remote;\n  connector_->Connect(media_session::mojom::kServiceName,\n                      controller_manager_remote.BindNewPipeAndPassReceiver());\n  controller_manager_remote->CreateActiveMediaController(\n      media_controller_remote_.BindNewPipeAndPassReceiver());\n\n  media_controller_remote_->AddObserver(\n      observer_receiver_.BindNewPipeAndPassRemote());\n\n  media_controller_remote_->ObserveImages(\n      media_session::mojom::MediaSessionImageType::kArtwork,\n      kMinimumArtworkSize, kDesiredArtworkSize,\n      artwork_observer_receiver_.BindNewPipeAndPassRemote());\n\n  media_controller_remote_->ObserveImages(\n      media_session::mojom::MediaSessionImageType::kSourceIcon,\n      kMinimumIconSize, kDesiredIconSize,\n      icon_observer_receiver_.BindNewPipeAndPassRemote());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n\tif (addr_len)\n\t\t*addr_len = sizeof(sa);\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n\tif (msg->msg_name != NULL)\n\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n \n out:\n \tskb_free_datagram(sk, skb);\n\nout_nofree:\n\treturn rval;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int nl80211_send_scan_msg(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t u32 pid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\t/* ignore errors and send incomplete event anyway */\n\tnl80211_add_scan_req(msg, rdev);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int nlm_async_call(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static InputMethodStatusConnection* GetInstance() {\n    return Singleton<InputMethodStatusConnection,\n        LeakySingletonTraits<InputMethodStatusConnection> >::get();\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void _dns_result_srv(struct dns_ctx *ctx, struct dns_rr_srv *result, void *data) {\n    dnsquery_t query = data;\n    assert(query != NULL);\n    query->query = NULL;\n\n    if (ctx != NULL && result == NULL) {\n        log_debug(ZONE, \"dns failure for %s@%p: SRV %s (%d)\", query->name, query,\n            query->s2s->lookup_srv[query->srv_i], dns_status(ctx));\n    } else if (result != NULL) {\n        int i;\n\n        log_debug(ZONE, \"dns response for %s@%p: SRV %s %d (%d)\", query->name, query,\n            result->dnssrv_qname, result->dnssrv_nrr, result->dnssrv_ttl);\n\n        for (i = 0; i < result->dnssrv_nrr; i++) {\n            if (strlen(result->dnssrv_srv[i].name) > 0\n                    && result->dnssrv_srv[i].port > 0\n                    && result->dnssrv_srv[i].port < 65536) {\n                log_debug(ZONE, \"dns response for %s@%p: SRV %s[%d] %s/%d (%d/%d)\", query->name,\n                    query, result->dnssrv_qname, i,\n                    result->dnssrv_srv[i].name, result->dnssrv_srv[i].port,\n                    result->dnssrv_srv[i].priority, result->dnssrv_srv[i].weight);\n\n                _dns_add_host(query, result->dnssrv_srv[i].name,\n                    result->dnssrv_srv[i].port, result->dnssrv_srv[i].priority,\n                    result->dnssrv_srv[i].weight, result->dnssrv_ttl);\n            }\n        }\n\n        free(result);\n    }\n\n    /* check next SRV service name */\n    query->srv_i++;\n    if (query->srv_i < query->s2s->lookup_nsrv) {\n        log_debug(ZONE, \"dns request for %s@%p: SRV %s\", query->name, query,\n            query->s2s->lookup_srv[query->srv_i]);\n\n        query->query = dns_submit_srv(NULL, query->name, query->s2s->lookup_srv[query->srv_i], \"tcp\",\n            DNS_NOSRCH, _dns_result_srv, query);\n\n        /* if submit failed, call ourselves with a NULL result */\n        if (query->query == NULL)\n            _dns_result_srv(ctx, NULL, query);\n    } else {\n        /* no more SRV records to check, resolve hosts */\n        if (xhash_count(query->hosts) > 0) {\n            _dns_result_a(NULL, NULL, query);\n\n        /* no SRV records returned, resolve hostname */\n        } else {\n            query->cur_host = strdup(query->name);\n            query->cur_port = 5269;\n            query->cur_prio = 0;\n            query->cur_weight = 0;\n            query->cur_expiry = 0;\n            if (query->s2s->resolve_aaaa) {\n                log_debug(ZONE, \"dns request for %s@%p: AAAA %s\", query->name, query, query->name);\n\n                query->query = dns_submit_a6(NULL, query->name,\n                    DNS_NOSRCH, _dns_result_aaaa, query);\n\n                /* if submit failed, call ourselves with a NULL result */\n                if (query->query == NULL)\n                    _dns_result_aaaa(ctx, NULL, query);\n            } else {\n                log_debug(ZONE, \"dns request for %s@%p: A %s\", query->name, query, query->name);\n\n                query->query = dns_submit_a4(NULL, query->name,\n                    DNS_NOSRCH, _dns_result_a, query);\n\n                /* if submit failed, call ourselves with a NULL result */\n                if (query->query == NULL)\n                    _dns_result_a(ctx, NULL, query);\n            }\n        }\n    }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "LocalFrame* GetLocalParentFrame(WebLocalFrameImpl* frame) {\n  WebFrame* parent = frame->Parent();\n  if (!parent || !parent->IsWebLocalFrame())\n    return nullptr;\n\n  return ToWebLocalFrameImpl(parent)->GetFrame();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static struct sock *__llc_lookup_established(struct llc_sap *sap,\n\t\t\t\t\t     struct llc_addr *daddr,\n\t\t\t\t\t     struct llc_addr *laddr)\n{\n\tstruct sock *rc;\n\tstruct hlist_nulls_node *node;\n\tint slot = llc_sk_laddr_hashfn(sap, laddr);\n\tstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\n\n\trcu_read_lock();\nagain:\n\tsk_nulls_for_each_rcu(rc, node, laddr_hb) {\n\t\tif (llc_estab_match(sap, daddr, laddr, rc)) {\n\t\t\t/* Extra checks required by SLAB_DESTROY_BY_RCU */\n\t\t\tif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\n\t\t\t\tgoto again;\n\t\t\tif (unlikely(llc_sk(rc)->sap != sap ||\n\t\t\t\t     !llc_estab_match(sap, daddr, laddr, rc))) {\n\t\t\t\tsock_put(rc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t}\n\trc = NULL;\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (unlikely(get_nulls_value(node) != slot))\n\t\tgoto again;\nfound:\n\trcu_read_unlock();\n\treturn rc;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n {\n \tstruct flakey_c *fc = ti->private;\n \n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n \t__be32 spi;\n \n \tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "crm_recv_remote_msg(void *session, gboolean encrypted)\n {\n    char *reply = NULL;\n     xmlNode *xml = NULL;\n \n     if (encrypted) {\n #ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n #else\n         CRM_ASSERT(encrypted == FALSE);\n #endif\n     } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n     }\n     if (reply == NULL || strlen(reply) == 0) {\n         crm_trace(\"Empty reply\");\n \n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", reply);\n         }\n     }\n \n    free(reply);\n    return xml;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OVS_REQUIRES(ofproto_mutex)\n{\n     const struct rule_actions *actions = rule_get_actions(rule);\n \n     /* A rule may not be reinserted. */\n    ovs_assert(rule->state == RULE_INITIALIZED);\n \n     if (rule->hard_timeout || rule->idle_timeout) {\n         ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n\n    rule->state = RULE_INSERTED;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-617"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void uipc_close_locked(tUIPC_CH_ID ch_id)\n{\n if (uipc_main.ch[ch_id].srvfd == UIPC_DISCONNECTED)\n {\n        BTIF_TRACE_EVENT(\"CHANNEL %d ALREADY CLOSED\", ch_id);\n return;\n }\n\n /* schedule close on this channel */\n    uipc_main.ch[ch_id].task_evt_flags |= UIPC_TASK_FLAG_DISCONNECT_CHAN;\n    uipc_wakeup_locked();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %d\", conn, skb->len);\n\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be)\n{\n    static const enum AVCodecID map[AV_SAMPLE_FMT_NB][2] = {\n        [AV_SAMPLE_FMT_U8  ] = { AV_CODEC_ID_PCM_U8,    AV_CODEC_ID_PCM_U8    },\n        [AV_SAMPLE_FMT_S16 ] = { AV_CODEC_ID_PCM_S16LE, AV_CODEC_ID_PCM_S16BE },\n        [AV_SAMPLE_FMT_S32 ] = { AV_CODEC_ID_PCM_S32LE, AV_CODEC_ID_PCM_S32BE },\n        [AV_SAMPLE_FMT_FLT ] = { AV_CODEC_ID_PCM_F32LE, AV_CODEC_ID_PCM_F32BE },\n        [AV_SAMPLE_FMT_DBL ] = { AV_CODEC_ID_PCM_F64LE, AV_CODEC_ID_PCM_F64BE },\n        [AV_SAMPLE_FMT_U8P ] = { AV_CODEC_ID_PCM_U8,    AV_CODEC_ID_PCM_U8    },\n        [AV_SAMPLE_FMT_S16P] = { AV_CODEC_ID_PCM_S16LE, AV_CODEC_ID_PCM_S16BE },\n        [AV_SAMPLE_FMT_S32P] = { AV_CODEC_ID_PCM_S32LE, AV_CODEC_ID_PCM_S32BE },\n        [AV_SAMPLE_FMT_S64P] = { AV_CODEC_ID_PCM_S64LE, AV_CODEC_ID_PCM_S64BE },\n        [AV_SAMPLE_FMT_FLTP] = { AV_CODEC_ID_PCM_F32LE, AV_CODEC_ID_PCM_F32BE },\n        [AV_SAMPLE_FMT_DBLP] = { AV_CODEC_ID_PCM_F64LE, AV_CODEC_ID_PCM_F64BE },\n    };\n    if (fmt < 0 || fmt >= AV_SAMPLE_FMT_NB)\n        return AV_CODEC_ID_NONE;\n    if (be < 0 || be > 1)\n        be = AV_NE(1, 0);\n    return map[fmt][be];\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "const GURL& DownloadItemImpl::GetOriginalUrl() const {\n  return url_chain_.front();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RenderBox::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)\n{\n    bool oldHorizontalWritingMode = isHorizontalWritingMode();\n\n    RenderBoxModelObject::styleDidChange(diff, oldStyle);\n\n    RenderStyle* newStyle = style();\n    if (needsLayout() && oldStyle) {\n        RenderBlock::removePercentHeightDescendantIfNeeded(this);\n\n        if (isOutOfFlowPositioned() && newStyle->hasStaticBlockPosition(isHorizontalWritingMode()) && oldStyle->marginBefore() != newStyle->marginBefore()\n            && parent() && !parent()->normalChildNeedsLayout())\n            parent()->setChildNeedsLayout();\n    }\n\n    if (RenderBlock::hasPercentHeightContainerMap() && firstChild()\n        && oldHorizontalWritingMode != isHorizontalWritingMode())\n        RenderBlock::clearPercentHeightDescendantsFrom(this);\n\n    if (hasOverflowClip() && oldStyle && newStyle && oldStyle->effectiveZoom() != newStyle->effectiveZoom() && layer()) {\n        if (int left = layer()->scrollableArea()->scrollXOffset()) {\n            left = (left / oldStyle->effectiveZoom()) * newStyle->effectiveZoom();\n            layer()->scrollableArea()->scrollToXOffset(left);\n        }\n        if (int top = layer()->scrollableArea()->scrollYOffset()) {\n            top = (top / oldStyle->effectiveZoom()) * newStyle->effectiveZoom();\n            layer()->scrollableArea()->scrollToYOffset(top);\n        }\n     }\n \n    if (diff == StyleDifferenceRepaint || diff == StyleDifferenceRepaintLayer) {\n         RenderObject* parentToInvalidate = parent();\n         for (unsigned i = 0; i < backgroundObscurationTestMaxDepth && parentToInvalidate; ++i) {\n             parentToInvalidate->invalidateBackgroundObscurationStatus();\n            parentToInvalidate = parentToInvalidate->parent();\n        }\n    }\n\n    if (isDocumentElement() || isBody())\n        document().view()->recalculateScrollbarOverlayStyle();\n\n    updateShapeOutsideInfoAfterStyleChange(*style(), oldStyle);\n    updateGridPositionAfterStyleChange(oldStyle);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int batadv_frag_size_limit(void)\n{\n\tint limit = BATADV_FRAG_MAX_FRAG_SIZE;\n\n\tlimit -= sizeof(struct batadv_frag_packet);\n\tlimit *= BATADV_FRAG_MAX_FRAGMENTS;\n\n\treturn limit;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PassRefPtr<DocumentFragment> createFragmentFromMarkup(Document* document, const String& markup, const String& baseURL, FragmentScriptingPermission scriptingPermission)\n {\n     RefPtr<HTMLBodyElement> fakeBody = HTMLBodyElement::create(document);\n    RefPtr<DocumentFragment> fragment =  Range::createDocumentFragmentForElement(markup, fakeBody.get(), scriptingPermission);\n \n     if (fragment && !baseURL.isEmpty() && baseURL != blankURL() && baseURL != document->baseURL())\n         completeURLs(fragment.get(), baseURL);\n\n    return fragment.release();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n{\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int ret, i, link_down;\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n\n    ret = virtio_load(vdev, f);\n    if (ret) {\n        return ret;\n    }\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n    n->vqs[0].tx_waiting = qemu_get_be32(f);\n\n    virtio_net_set_mrg_rx_bufs(n, qemu_get_be32(f));\n\n    if (version_id >= 3)\n        n->status = qemu_get_be16(f);\n\n    if (version_id >= 4) {\n        if (version_id < 8) {\n            n->promisc = qemu_get_be32(f);\n            n->allmulti = qemu_get_be32(f);\n        } else {\n            n->promisc = qemu_get_byte(f);\n            n->allmulti = qemu_get_byte(f);\n        }\n    }\n\n    if (version_id >= 5) {\n        n->mac_table.in_use = qemu_get_be32(f);\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n         if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n             qemu_get_buffer(f, n->mac_table.macs,\n                             n->mac_table.in_use * ETH_ALEN);\n        } else if (n->mac_table.in_use) {\n            uint8_t *buf = g_malloc0(n->mac_table.in_use);\n            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);\n            g_free(buf);\n             n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;\n             n->mac_table.in_use = 0;\n         }\n            error_report(\"virtio-net: saved image requires vnet_hdr=on\");\n            return -1;\n        }\n    }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadMTVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    columns,\n    rows;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read MTV image.\n  */\n  (void) ReadBlobString(image,buffer);\n  count=(ssize_t) sscanf(buffer,\"%lu %lu\\n\",&columns,&rows);\n  if (count <= 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Initialize image structure.\n    */\n    image->columns=columns;\n    image->rows=rows;\n    image->depth=8;\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     /*\n       Convert MTV raster image to pixel packets.\n     */\n    pixels=(unsigned char *) AcquireQuantumMemory((size_t) image->columns,\n      3UL*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=(ssize_t) ReadBlob(image,(size_t) (3*image->columns),pixels);\n      if (count != (ssize_t) (3*image->columns))\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelRed(q,ScaleCharToQuantum(*p++));\n        SetPixelGreen(q,ScaleCharToQuantum(*p++));\n        SetPixelBlue(q,ScaleCharToQuantum(*p++));\n        SetPixelOpacity(q,OpaqueOpacity);\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    *buffer='\\0';\n    (void) ReadBlobString(image,buffer);\n    count=(ssize_t) sscanf(buffer,\"%lu %lu\\n\",&columns,&rows);\n    if (count > 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count > 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static HB_Error  Load_BaseArray( HB_BaseArray*  ba,\n\t\t\t\t HB_UShort       num_classes,\n\t\t\t\t HB_Stream       stream )\n{\n  HB_Error  error;\n\n  HB_UShort       m, n, count;\n  HB_UInt         cur_offset, new_offset, base_offset;\n\n  HB_BaseRecord  *br;\n  HB_Anchor      *ban, *bans;\n\n\n  base_offset = FILE_Pos();\n\n  if ( ACCESS_Frame( 2L ) )\n    return error;\n\n  count = ba->BaseCount = GET_UShort();\n\n  FORGET_Frame();\n\n  ba->BaseRecord = NULL;\n\n  if ( ALLOC_ARRAY( ba->BaseRecord, count, HB_BaseRecord ) )\n    return error;\n\n  br = ba->BaseRecord;\n\n  bans = NULL;\n\n  if ( ALLOC_ARRAY( bans, count * num_classes, HB_Anchor ) )\n    goto Fail;\n\n  for ( m = 0; m < count; m++ )\n  {\n    br[m].BaseAnchor = NULL;\n\n    ban = br[m].BaseAnchor = bans + m * num_classes;\n\n    for ( n = 0; n < num_classes; n++ )\n    {\n      if ( ACCESS_Frame( 2L ) )\n\tgoto Fail;\n\n      new_offset = GET_UShort() + base_offset;\n\n      FORGET_Frame();\n\n      if (new_offset == base_offset) {\n\t/* XXX\n\t * Doulos SIL Regular is buggy and has zero offsets here.\n\t * Skip it\n\t */\n\tban[n].PosFormat = 0;\n\tcontinue;\n      }\n\n      cur_offset = FILE_Pos();\n      if ( FILE_Seek( new_offset ) ||\n\t   ( error = Load_Anchor( &ban[n], stream ) ) != HB_Err_Ok )\n\tgoto Fail;\n      (void)FILE_Seek( cur_offset );\n    }\n  }\n\n  return HB_Err_Ok;\n\nFail:\n  FREE( bans );\n  FREE( br );\n  return error;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n\n  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */\n  if (size > 12 * len)\n    /* 11 is not a bug, the initial offset happens only once. */\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n\n                    /* As a heuristic, prefer memchr to seeking by\n                       delta1 when the latter doesn't advance much.  */\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                     if (! tp)\n                       return -1;\n                     tp++;\n                   }\n               }\n           }\n      big_advance:;\n      }\n\n  /* Now we have only a few characters left to search.  We\n     carefully avoid ever producing an out-of-bounds pointer. */\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n\n  return -1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "GF_Err stvi_dump(GF_Box *a, FILE * trace)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) a;\n\tgf_isom_box_dump_start(a, \"StereoVideoBox\", trace);\n\n\tfprintf(trace, \"single_view_allowed=\\\"%d\\\" stereo_scheme=\\\"%d\\\" \", ptr->single_view_allowed, ptr->stereo_scheme);\n\tdump_data_attribute(trace, \"stereo_indication_type\", ptr->stereo_indication_type, ptr->sit_len);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"StereoVideoBox\", a, trace);\n\treturn GF_OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "DesktopWindowTreeHostX11::DesktopWindowTreeHostX11(\n    internal::NativeWidgetDelegate* native_widget_delegate,\n    DesktopNativeWidgetAura* desktop_native_widget_aura)\n    : xdisplay_(gfx::GetXDisplay()),\n      x_root_window_(DefaultRootWindow(xdisplay_)),\n      native_widget_delegate_(native_widget_delegate),\n      desktop_native_widget_aura_(desktop_native_widget_aura) {}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n \n \tmemset(&addr, 0, sizeof(addr));\n \taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n \taddr.sin_port = htons(port);\n \n \taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void sapi_cgi_log_message(char *message TSRMLS_DC)\n{\n\tif (fcgi_is_fastcgi() && CGIG(fcgi_logging)) {\n\t\tfcgi_request *request;\n\n\t\trequest = (fcgi_request*) SG(server_context);\n\t\tif (request) {\n\t\t\tint len = strlen(message);\n\t\t\tchar *buf = malloc(len+2);\n\n\t\t\tmemcpy(buf, message, len);\n\t\t\tmemcpy(buf + len, \"\\n\", sizeof(\"\\n\"));\n\t\t\tfcgi_write(request, FCGI_STDERR, buf, len+1);\n\t\t\tfree(buf);\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s\\n\", message);\n\t\t}\n\t\t/* ignore return code */\n\t} else {\n\t\tfprintf(stderr, \"%s\\n\", message);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Com_WriteConfigToFile( const char *filename ) {\n\tfileHandle_t\tf;\n\n\tf = FS_FOpenFileWrite( filename );\n\tif ( !f ) {\n\t\tCom_Printf (\"Couldn't write %s.\\n\", filename );\n\t\treturn;\n\t}\n\n\tFS_Printf (f, \"// generated by quake, do not modify\\n\");\n\tKey_WriteBindings (f);\n\tCvar_WriteVariables (f);\n\tFS_FCloseFile( f );\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-269"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "authentic_process_fci(struct sc_card *card, struct sc_file *file,\n\t\t const unsigned char *buf, size_t buflen)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tsize_t taglen;\n\tint rv;\n\tunsigned ii;\n\tconst unsigned char *tag = NULL;\n\tunsigned char ops_DF[8] = {\n\t\tSC_AC_OP_CREATE, SC_AC_OP_DELETE, SC_AC_OP_CRYPTO, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n\t};\n\tunsigned char ops_EF[8] = {\n\t\tSC_AC_OP_READ, SC_AC_OP_DELETE, SC_AC_OP_UPDATE, SC_AC_OP_RESIZE, 0xFF, 0xFF, 0xFF, 0xFF\n\t};\n\n\tLOG_FUNC_CALLED(ctx);\n\n\ttag = sc_asn1_find_tag(card->ctx,  buf, buflen, 0x6F, &taglen);\n\tif (tag != NULL) {\n\t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);\n\t\tbuf = tag;\n\t\tbuflen = taglen;\n\t}\n\n\ttag = sc_asn1_find_tag(card->ctx,  buf, buflen, 0x62, &taglen);\n\tif (tag != NULL) {\n\t\tsc_log(ctx, \"  FCP length %\"SC_FORMAT_LEN_SIZE_T\"u\", taglen);\n\t\tbuf = tag;\n\t\tbuflen = taglen;\n\t}\n\n\trv = iso_ops->process_fci(card, file, buf, buflen);\n\tLOG_TEST_RET(ctx, rv, \"ISO parse FCI failed\");\n\n\tif (!file->sec_attr_len)   {\n\t\tsc_log_hex(ctx, \"ACLs not found in data\", buf, buflen);\n\t\tsc_log(ctx, \"Path:%s; Type:%X; PathType:%X\", sc_print_path(&file->path), file->type, file->path.type);\n\t\tif (file->path.type == SC_PATH_TYPE_DF_NAME || file->type == SC_FILE_TYPE_DF)   {\n\t\t\tfile->type = SC_FILE_TYPE_DF;\n\t\t}\n\t\telse   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"ACLs tag missing\");\n\t\t}\n \t}\n \n \tsc_log_hex(ctx, \"ACL data\", file->sec_attr, file->sec_attr_len);\n\tfor (ii = 0; ii < file->sec_attr_len / 2; ii++)  {\n \t\tunsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];\n \t\tunsigned char acl = *(file->sec_attr + ii*2);\n \t\tunsigned char cred_id = *(file->sec_attr + ii*2 + 1);\n\t\tunsigned sc = acl * 0x100 + cred_id;\n\n\t\tsc_log(ctx, \"ACL(%i) op 0x%X, acl %X:%X\", ii, op, acl, cred_id);\n\t\tif (op == 0xFF)\n\t\t\t;\n\t\telse if (!acl && !cred_id)\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NONE, 0);\n\t\telse if (acl == 0xFF)\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);\n\t\telse if (acl & AUTHENTIC_AC_SM_MASK)\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_SCB, sc);\n\t\telse if (cred_id)\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_CHV, cred_id);\n\t\telse\n\t\t\tsc_file_add_acl_entry(file, op, SC_AC_NEVER, 0);\n\t}\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    /* First step: count keys into table. No other way to do it with the\n      * Lua API, we need to iterate a first time. Note that an alternative\n      * would be to do a single run, and then hack the buffer to insert the\n      * map opcodes for message pack. Too hackish for this lib. */\n     lua_pushnil(L);\n     while(lua_next(L,-2)) {\n         lua_pop(L,1); /* remove value, keep key for next iteration. */\n        len++;\n    }\n\n    /* Step two: actually encoding of the map. */\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pushvalue(L,-2); /* Stack: ... key value key */\n        mp_encode_lua_type(L,buf,level+1); /* encode key */\n        mp_encode_lua_type(L,buf,level+1); /* encode val */\n    }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n \tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n \tstruct search_domain *dom;\n \n \tfor (dom = state->head; dom; dom = dom->next) {\n \t\tif (!n--) {\n \t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL; /* unreachable; stops warnings in some compilers. */\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void dev_load(struct net *net, const char *name)\n {\n \tstruct net_device *dev;\n \n \trcu_read_lock();\n \tdev = dev_get_by_name_rcu(net, name);\n \trcu_read_unlock();\n \n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "isis_print_mt_capability_subtlv(netdissect_options *ndo,\n                                const uint8_t *tptr, int len)\n{\n  int stlv_type, stlv_len, tmp;\n \n   while (len > 2)\n   {\n     stlv_type = *(tptr++);\n     stlv_len  = *(tptr++);\n \n    /* first lets see if we know the subTLVs name*/\n    ND_PRINT((ndo, \"\\n\\t      %s subTLV #%u, length: %u\",\n               tok2str(isis_mt_capability_subtlv_values, \"unknown\", stlv_type),\n               stlv_type,\n               stlv_len));\n \n     len = len - 2;\n \n     switch (stlv_type)\n     {\n       case ISIS_SUBTLV_SPB_INSTANCE:\n          ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN);\n \n           ND_PRINT((ndo, \"\\n\\t        CIST Root-ID: %08x\", EXTRACT_32BITS(tptr)));\n           tptr = tptr+4;\n          ND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tptr)));\n          tptr = tptr+4;\n          ND_PRINT((ndo, \", Path Cost: %08x\", EXTRACT_32BITS(tptr)));\n          tptr = tptr+4;\n          ND_PRINT((ndo, \", Prio: %d\", EXTRACT_16BITS(tptr)));\n          tptr = tptr + 2;\n          ND_PRINT((ndo, \"\\n\\t        RES: %d\",\n                    EXTRACT_16BITS(tptr) >> 5));\n          ND_PRINT((ndo, \", V: %d\",\n                    (EXTRACT_16BITS(tptr) >> 4) & 0x0001));\n          ND_PRINT((ndo, \", SPSource-ID: %d\",\n                    (EXTRACT_32BITS(tptr) & 0x000fffff)));\n          tptr = tptr+4;\n          ND_PRINT((ndo, \", No of Trees: %x\", *(tptr)));\n\n           tmp = *(tptr++);\n \n           len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;\n \n           while (tmp)\n           {\n            ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN);\n \n             ND_PRINT((ndo, \"\\n\\t         U:%d, M:%d, A:%d, RES:%d\",\n                       *(tptr) >> 7, (*(tptr) >> 6) & 0x01,\n                      (*(tptr) >> 5) & 0x01, (*(tptr) & 0x1f)));\n\n            tptr++;\n\n            ND_PRINT((ndo, \", ECT: %08x\", EXTRACT_32BITS(tptr)));\n\n            tptr = tptr + 4;\n\n            ND_PRINT((ndo, \", BVID: %d, SPVID: %d\",\n                      (EXTRACT_24BITS(tptr) >> 12) & 0x000fff,\n                      EXTRACT_24BITS(tptr) & 0x000fff));\n \n             tptr = tptr + 3;\n             len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;\n             tmp--;\n           }\n \n           break;\n \n       case ISIS_SUBTLV_SPBM_SI:\n          ND_TCHECK2(*tptr, 8);\n \n           ND_PRINT((ndo, \"\\n\\t        BMAC: %08x\", EXTRACT_32BITS(tptr)));\n           tptr = tptr+4;\n          ND_PRINT((ndo, \"%04x\", EXTRACT_16BITS(tptr)));\n          tptr = tptr+2;\n\n          ND_PRINT((ndo, \", RES: %d, VID: %d\", EXTRACT_16BITS(tptr) >> 12,\n                    (EXTRACT_16BITS(tptr)) & 0x0fff));\n\n          tptr = tptr+2;\n          len = len - 8;\n          stlv_len = stlv_len - 8;\n\n          while (stlv_len >= 4) {\n            ND_TCHECK2(*tptr, 4);\n            ND_PRINT((ndo, \"\\n\\t        T: %d, R: %d, RES: %d, ISID: %d\",\n                    (EXTRACT_32BITS(tptr) >> 31),\n                    (EXTRACT_32BITS(tptr) >> 30) & 0x01,\n                    (EXTRACT_32BITS(tptr) >> 24) & 0x03f,\n                    (EXTRACT_32BITS(tptr)) & 0x0ffffff));\n\n            tptr = tptr + 4;\n            len = len - 4;\n            stlv_len = stlv_len - 4;\n          }\n\n        break;\n\n       default:\n         break;\n     }\n   }\n   return 0;\n \n  trunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return(1);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static struct nft_table *nf_tables_table_lookup(const struct nft_af_info *afi,\n\t\t\t\t\t\tconst struct nlattr *nla)\n{\n\tstruct nft_table *table;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttable = nft_table_lookup(afi, nla);\n\tif (table != NULL)\n\t\treturn table;\n\n\treturn ERR_PTR(-ENOENT);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-19"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tloff_t size;\n\tunsigned long len;\n\tint ret;\n\tstruct file *file = vma->vm_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\thandle_t *handle;\n\tget_block_t *get_block;\n\tint retries = 0;\n \n \tsb_start_pagefault(inode->i_sb);\n \tfile_update_time(vma->vm_file);\n \t/* Delalloc case is easy... */\n \tif (test_opt(inode->i_sb, DELALLOC) &&\n \t    !ext4_should_journal_data(inode) &&\n\t    !ext4_nonda_switch(inode->i_sb)) {\n\t\tdo {\n\t\t\tret = block_page_mkwrite(vma, vmf,\n\t\t\t\t\t\t   ext4_da_get_block_prep);\n\t\t} while (ret == -ENOSPC &&\n\t\t       ext4_should_retry_alloc(inode->i_sb, &retries));\n\t\tgoto out_ret;\n\t}\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\t/* Page got truncated from under us? */\n\tif (page->mapping != mapping || page_offset(page) > size) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\t/*\n\t * Return if we have all the buffers mapped. This avoids the need to do\n\t * journal_start/journal_stop which can block and take a long time\n\t */\n\tif (page_has_buffers(page)) {\n\t\tif (!ext4_walk_page_buffers(NULL, page_buffers(page),\n\t\t\t\t\t    0, len, NULL,\n\t\t\t\t\t    ext4_bh_unmapped)) {\n\t\t\t/* Wait so that we don't change page under IO */\n\t\t\twait_for_stable_page(page);\n\t\t\tret = VM_FAULT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunlock_page(page);\n\t/* OK, we need to fill the hole... */\n\tif (ext4_should_dioread_nolock(inode))\n\t\tget_block = ext4_get_block_write;\n\telse\n\t\tget_block = ext4_get_block;\nretry_alloc:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\tret = block_page_mkwrite(vma, vmf, get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tif (ext4_walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\t  PAGE_CACHE_SIZE, NULL, do_journal_get_write_access)) {\n\t\t\tunlock_page(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\text4_journal_stop(handle);\n\t\t\tgoto out;\n\t\t}\n\t\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\t}\n\text4_journal_stop(handle);\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry_alloc;\n out_ret:\n \tret = block_page_mkwrite_return(ret);\n out:\n \tsb_end_pagefault(inode->i_sb);\n \treturn ret;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ResourceFetcher::decrementRequestCount(const Resource* res)\n{\n    if (res->ignoreForRequestCount())\n        return;\n\n    --m_requestCount;\n    ASSERT(m_requestCount > -1);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Camera3Device::notifyError(const camera3_error_msg_t &msg,\n NotificationListener *listener) {\n\n static const ICameraDeviceCallbacks::CameraErrorCode\n            halErrorMap[CAMERA3_MSG_NUM_ERRORS] = {\n ICameraDeviceCallbacks::ERROR_CAMERA_INVALID_ERROR,\n ICameraDeviceCallbacks::ERROR_CAMERA_DEVICE,\n ICameraDeviceCallbacks::ERROR_CAMERA_REQUEST,\n ICameraDeviceCallbacks::ERROR_CAMERA_RESULT,\n ICameraDeviceCallbacks::ERROR_CAMERA_BUFFER\n };\n\n ICameraDeviceCallbacks::CameraErrorCode errorCode =\n ((msg.error_code >= 0) &&\n (msg.error_code < CAMERA3_MSG_NUM_ERRORS)) ?\n            halErrorMap[msg.error_code] :\n ICameraDeviceCallbacks::ERROR_CAMERA_INVALID_ERROR;\n\n int streamId = 0;\n if (msg.error_stream != NULL) {\n Camera3Stream *stream =\n Camera3Stream::cast(msg.error_stream);\n        streamId = stream->getId();\n }\n    ALOGV(\"Camera %d: %s: HAL error, frame %d, stream %d: %d\",\n            mId, __FUNCTION__, msg.frame_number,\n            streamId, msg.error_code);\n\n CaptureResultExtras resultExtras;\n switch (errorCode) {\n case ICameraDeviceCallbacks::ERROR_CAMERA_DEVICE:\n            SET_ERR(\"Camera HAL reported serious device error\");\n break;\n case ICameraDeviceCallbacks::ERROR_CAMERA_REQUEST:\n case ICameraDeviceCallbacks::ERROR_CAMERA_RESULT:\n case ICameraDeviceCallbacks::ERROR_CAMERA_BUFFER:\n {\n Mutex::Autolock l(mInFlightLock);\n ssize_t idx = mInFlightMap.indexOfKey(msg.frame_number);\n if (idx >= 0) {\n InFlightRequest &r = mInFlightMap.editValueAt(idx);\n                    r.requestStatus = msg.error_code;\n                    resultExtras = r.resultExtras;\n } else {\n                    resultExtras.frameNumber = msg.frame_number;\n                    ALOGE(\"Camera %d: %s: cannot find in-flight request on \"\n \"frame %\" PRId64 \" error\", mId, __FUNCTION__,\n                            resultExtras.frameNumber);\n }\n }\n if (listener != NULL) {\n                listener->notifyError(errorCode, resultExtras);\n } else {\n                ALOGE(\"Camera %d: %s: no listener available\", mId, __FUNCTION__);\n }\n break;\n default:\n            SET_ERR(\"Unknown error message from HAL: %d\", msg.error_code);\n break;\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void TaskManagerView::AddAlwaysOnTopSystemMenuItem() {\n#if defined(OS_WIN) && !defined(USE_AURA)\n  always_on_top_menu_text_ = l10n_util::GetStringUTF16(IDS_ALWAYS_ON_TOP);\n\n  HMENU system_menu = ::GetSystemMenu(GetWidget()->GetNativeWindow(), FALSE);\n  int index = ::GetMenuItemCount(system_menu) - 1;\n  if (index < 0) {\n    NOTREACHED();\n    index = 0;\n  }\n  MENUITEMINFO menu_info;\n  memset(&menu_info, 0, sizeof(MENUITEMINFO));\n  menu_info.cbSize = sizeof(MENUITEMINFO);\n  menu_info.fMask = MIIM_FTYPE;\n  menu_info.fType = MFT_SEPARATOR;\n  ::InsertMenuItem(system_menu, index, TRUE, &menu_info);\n\n  menu_info.fMask = MIIM_FTYPE | MIIM_ID | MIIM_STRING | MIIM_STATE;\n  menu_info.fType = MFT_STRING;\n  menu_info.fState = MFS_ENABLED;\n  if (is_always_on_top_)\n    menu_info.fState |= MFS_CHECKED;\n  menu_info.wID = IDC_ALWAYS_ON_TOP;\n  menu_info.dwTypeData = const_cast<wchar_t*>(always_on_top_menu_text_.c_str());\n  ::InsertMenuItem(system_menu, index, TRUE, &menu_info);\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n  const int argc,const char **argv,Image **images,ExceptionInfo *exception)\n{\n  ChannelType\n    channel;\n\n  const char\n    *option;\n\n  ImageInfo\n    *mogrify_info;\n\n  MagickStatusType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    index;\n\n  /*\n    Apply options to the image list.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image **) NULL);\n  assert((*images)->previous == (Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  if ((argc <= 0) || (*argv == (char *) NULL))\n    return(MagickTrue);\n  mogrify_info=CloneImageInfo(image_info);\n  quantize_info=AcquireQuantizeInfo(mogrify_info);\n  channel=mogrify_info->channel;\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    if (*images == (Image *) NULL)\n      break;\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=ParseCommandOption(MagickCommandOptions,MagickFalse,option);\n    count=MagickMax(count,0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    status=MogrifyImageInfo(mogrify_info,(int) count+1,argv+i,exception);\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"affinity\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                InheritException(exception,&(*images)->exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"append\",option+1) == 0)\n          {\n            Image\n              *append_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            append_image=AppendImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            if (append_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=append_image;\n            break;\n          }\n        if (LocaleCompare(\"average\",option+1) == 0)\n          {\n            Image\n              *average_image;\n\n            /*\n              Average an image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images);\n            average_image=EvaluateImages(*images,MeanEvaluateOperator,\n              exception);\n            if (average_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=average_image;\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                channel=DefaultChannels;\n                break;\n              }\n            channel=(ChannelType) ParseChannelOption(argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"clut\",option+1) == 0)\n          {\n            Image\n              *clut_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n             clut_image=RemoveFirstImageFromList(images);\n             if (clut_image == (Image *) NULL)\n               {\n                 status=MagickFalse;\n                 break;\n               }\n            (void) ClutImageChannel(image,channel,clut_image);\n            clut_image=DestroyImage(clut_image);\n            InheritException(exception,&image->exception);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"coalesce\",option+1) == 0)\n          {\n            Image\n              *coalesce_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            coalesce_image=CoalesceImages(*images,exception);\n            if (coalesce_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=coalesce_image;\n            break;\n          }\n        if (LocaleCompare(\"combine\",option+1) == 0)\n          {\n            Image\n              *combine_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            combine_image=CombineImages(*images,channel,exception);\n            if (combine_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=combine_image;\n            break;\n           }\n         if (LocaleCompare(\"compare\",option+1) == 0)\n           {\n            const char\n              *option;\n             double\n               distortion;\n \n            Image\n              *difference_image,\n              *image,\n              *reconstruct_image;\n\n            MetricType\n              metric;\n\n            /*\n              Mathematically and visually annotate the difference between an\n              image and its reconstruction.\n            */\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n             reconstruct_image=RemoveFirstImageFromList(images);\n             if (reconstruct_image == (Image *) NULL)\n               {\n                 status=MagickFalse;\n                 break;\n               }\n            metric=UndefinedMetric;\n            option=GetImageOption(image_info,\"metric\");\n            if (option != (const char *) NULL)\n              metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n                MagickFalse,option);\n            difference_image=CompareImageChannels(image,reconstruct_image,\n              channel,metric,&distortion,exception);\n            if (difference_image == (Image *) NULL)\n              break;\n            reconstruct_image=DestroyImage(reconstruct_image);\n            image=DestroyImage(image);\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=difference_image;\n            break;\n          }\n        if (LocaleCompare(\"complex\",option+1) == 0)\n          {\n            ComplexOperator\n              op;\n\n            Image\n              *complex_images;\n\n            (void) SyncImageSettings(mogrify_info,*images);\n            op=(ComplexOperator) ParseCommandOption(MagickComplexOptions,\n              MagickFalse,argv[i+1]);\n            complex_images=ComplexImages(*images,op,exception);\n            if (complex_images == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=complex_images;\n            break;\n          }\n        if (LocaleCompare(\"composite\",option+1) == 0)\n          {\n            Image\n              *mask_image,\n              *composite_image,\n              *image;\n\n            RectangleInfo\n              geometry;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n             composite_image=RemoveFirstImageFromList(images);\n             if (composite_image == (Image *) NULL)\n               {\n                 status=MagickFalse;\n                 break;\n               }\n            (void) TransformImage(&composite_image,(char *) NULL,\n              composite_image->geometry);\n            SetGeometry(composite_image,&geometry);\n            (void) ParseAbsoluteGeometry(composite_image->geometry,&geometry);\n            GravityAdjustGeometry(image->columns,image->rows,image->gravity,\n              &geometry);\n            mask_image=RemoveFirstImageFromList(images);\n            if (mask_image != (Image *) NULL)\n              {\n                if ((image->compose == DisplaceCompositeOp) ||\n                    (image->compose == DistortCompositeOp))\n                  {\n                    /*\n                      Merge Y displacement into X displacement image.\n                    */\n                    (void) CompositeImage(composite_image,CopyGreenCompositeOp,\n                      mask_image,0,0);\n                    mask_image=DestroyImage(mask_image);\n                  }\n                else\n                  {\n                    /*\n                      Set a blending mask for the composition.\n                    */\n                    if (image->mask != (Image *) NULL)\n                      image->mask=DestroyImage(image->mask);\n                    image->mask=mask_image;\n                    (void) NegateImage(image->mask,MagickFalse);\n                  }\n              }\n            (void) CompositeImageChannel(image,channel,image->compose,\n              composite_image,geometry.x,geometry.y);\n            if (mask_image != (Image *) NULL)\n              {\n                image->mask=DestroyImage(image->mask);\n                mask_image=image->mask;\n              }\n            composite_image=DestroyImage(composite_image);\n            InheritException(exception,&image->exception);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            /*\n              Copy image pixels.\n            */\n            (void) SyncImageSettings(mogrify_info,*images);\n            (void) ParsePageGeometry(*images,argv[i+2],&geometry,exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=(*images);\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,argv[i+1],&geometry,\n              exception);\n            status=CopyImagePixels(*images,source_image,&geometry,&offset,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"deconstruct\",option+1) == 0)\n          {\n            Image\n              *deconstruct_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            deconstruct_image=DeconstructImages(*images,exception);\n            if (deconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=deconstruct_image;\n            break;\n          }\n        if (LocaleCompare(\"delete\",option+1) == 0)\n          {\n            if (*option == '+')\n              DeleteImages(images,\"-1\",exception);\n            else\n              DeleteImages(images,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->dither=MagickFalse;\n                break;\n              }\n            quantize_info->dither=MagickTrue;\n            quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n              MagickDitherOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"duplicate\",option+1) == 0)\n          {\n            Image\n              *duplicate_images;\n\n            if (*option == '+')\n              duplicate_images=DuplicateImages(*images,1,\"-1\",exception);\n            else\n              {\n                const char\n                  *p;\n\n                size_t\n                  number_duplicates;\n\n                number_duplicates=(size_t) StringToLong(argv[i+1]);\n                p=strchr(argv[i+1],',');\n                if (p == (const char *) NULL)\n                  duplicate_images=DuplicateImages(*images,number_duplicates,\n                    \"-1\",exception);\n                else\n                  duplicate_images=DuplicateImages(*images,number_duplicates,p,\n                    exception);\n              }\n            AppendImageToList(images, duplicate_images);\n            (void) SyncImagesSettings(mogrify_info,*images);\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n          {\n            Image\n              *evaluate_image;\n\n            MagickEvaluateOperator\n              op;\n\n            (void) SyncImageSettings(mogrify_info,*images);\n            op=(MagickEvaluateOperator) ParseCommandOption(\n              MagickEvaluateOptions,MagickFalse,argv[i+1]);\n            evaluate_image=EvaluateImages(*images,op,exception);\n            if (evaluate_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=evaluate_image;\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"fft\",option+1) == 0)\n          {\n            Image\n              *fourier_image;\n\n            /*\n              Implements the discrete Fourier transform (DFT).\n            */\n            (void) SyncImageSettings(mogrify_info,*images);\n            fourier_image=ForwardFourierTransformImage(*images,*option == '-' ?\n              MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"flatten\",option+1) == 0)\n          {\n            Image\n              *flatten_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            flatten_image=MergeImageLayers(*images,FlattenLayer,exception);\n            if (flatten_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=flatten_image;\n            break;\n          }\n        if (LocaleCompare(\"fx\",option+1) == 0)\n          {\n            Image\n              *fx_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            fx_image=FxImageChannel(*images,channel,argv[i+1],exception);\n            if (fx_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=fx_image;\n            break;\n          }\n        break;\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"hald-clut\",option+1) == 0)\n          {\n            Image\n              *hald_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            image=RemoveFirstImageFromList(images);\n             hald_image=RemoveFirstImageFromList(images);\n             if (hald_image == (Image *) NULL)\n               {\n                 status=MagickFalse;\n                 break;\n               }\n            (void) HaldClutImageChannel(image,channel,hald_image);\n            hald_image=DestroyImage(hald_image);\n            InheritException(exception,&image->exception);\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"ift\",option+1) == 0)\n          {\n            Image\n              *fourier_image,\n              *magnitude_image,\n              *phase_image;\n\n            /*\n              Implements the inverse fourier discrete Fourier transform (DFT).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images);\n            magnitude_image=RemoveFirstImageFromList(images);\n             phase_image=RemoveFirstImageFromList(images);\n             if (phase_image == (Image *) NULL)\n               {\n                 status=MagickFalse;\n                 break;\n               }\n             fourier_image=InverseFourierTransformImage(magnitude_image,\n               phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);\n             if (fourier_image == (Image *) NULL)\n               break;\n             if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"insert\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q;\n\n            index=0;\n            if (*option != '+')\n              index=(ssize_t) StringToLong(argv[i+1]);\n            p=RemoveLastImageFromList(images);\n            if (p == (Image *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                status=MagickFalse;\n                break;\n              }\n            q=p;\n            if (index == 0)\n              PrependImageToList(images,q);\n            else\n              if (index == (ssize_t) GetImageListLength(*images))\n                AppendImageToList(images,q);\n              else\n                {\n                   q=GetImageFromList(*images,index-1);\n                   if (q == (Image *) NULL)\n                     {\n                       p=DestroyImage(p);\n                       (void) ThrowMagickException(exception,GetMagickModule(),\n                         OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                       status=MagickFalse;\n                       break;\n                     }\n                  InsertImageInList(&q,p);\n                }\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"layers\",option+1) == 0)\n          {\n            Image\n              *layers;\n\n            ImageLayerMethod\n              method;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            layers=(Image *) NULL;\n            method=(ImageLayerMethod) ParseCommandOption(MagickLayerOptions,\n              MagickFalse,argv[i+1]);\n            switch (method)\n            {\n              case CoalesceLayer:\n              {\n                layers=CoalesceImages(*images,exception);\n                break;\n              }\n              case CompareAnyLayer:\n              case CompareClearLayer:\n              case CompareOverlayLayer:\n              default:\n              {\n                layers=CompareImageLayers(*images,method,exception);\n                break;\n              }\n              case MergeLayer:\n              case FlattenLayer:\n              case MosaicLayer:\n              case TrimBoundsLayer:\n              {\n                layers=MergeImageLayers(*images,method,exception);\n                break;\n              }\n              case DisposeLayer:\n              {\n                layers=DisposeImages(*images,exception);\n                break;\n              }\n              case OptimizeImageLayer:\n              {\n                layers=OptimizeImageLayers(*images,exception);\n                break;\n              }\n              case OptimizePlusLayer:\n              {\n                layers=OptimizePlusImageLayers(*images,exception);\n                break;\n              }\n              case OptimizeTransLayer:\n              {\n                OptimizeImageTransparency(*images,exception);\n                break;\n              }\n              case RemoveDupsLayer:\n              {\n                RemoveDuplicateLayers(images,exception);\n                break;\n              }\n              case RemoveZeroLayer:\n              {\n                RemoveZeroDelayLayers(images,exception);\n                break;\n              }\n              case OptimizeLayer:\n              {\n                /*\n                  General Purpose, GIF Animation Optimizer.\n                */\n                layers=CoalesceImages(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                InheritException(exception,&layers->exception);\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=OptimizeImageLayers(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                InheritException(exception,&layers->exception);\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=(Image *) NULL;\n                OptimizeImageTransparency(*images,exception);\n                InheritException(exception,&(*images)->exception);\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                break;\n              }\n              case CompositeLayer:\n              {\n                CompositeOperator\n                  compose;\n\n                Image\n                  *source;\n\n                RectangleInfo\n                  geometry;\n\n                /*\n                  Split image sequence at the first 'NULL:' image.\n                */\n                source=(*images);\n                while (source != (Image *) NULL)\n                {\n                  source=GetNextImageInList(source);\n                  if ((source != (Image *) NULL) &&\n                      (LocaleCompare(source->magick,\"NULL\") == 0))\n                    break;\n                }\n                if (source != (Image *) NULL)\n                  {\n                    if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                        (GetNextImageInList(source) == (Image *) NULL))\n                      source=(Image *) NULL;\n                    else\n                      {\n                        /*\n                          Separate the two lists, junk the null: image.\n                        */\n                        source=SplitImageList(source->previous);\n                        DeleteImageFromList(&source);\n                      }\n                  }\n                if (source == (Image *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                    status=MagickFalse;\n                    break;\n                  }\n                /*\n                  Adjust offset with gravity and virtual canvas.\n                */\n                SetGeometry(*images,&geometry);\n                (void) ParseAbsoluteGeometry((*images)->geometry,&geometry);\n                geometry.width=source->page.width != 0 ?\n                  source->page.width : source->columns;\n                geometry.height=source->page.height != 0 ?\n                 source->page.height : source->rows;\n                GravityAdjustGeometry((*images)->page.width != 0 ?\n                  (*images)->page.width : (*images)->columns,\n                  (*images)->page.height != 0 ? (*images)->page.height :\n                  (*images)->rows,(*images)->gravity,&geometry);\n                compose=OverCompositeOp;\n                option=GetImageOption(mogrify_info,\"compose\");\n                if (option != (const char *) NULL)\n                  compose=(CompositeOperator) ParseCommandOption(\n                    MagickComposeOptions,MagickFalse,option);\n                CompositeLayers(*images,compose,source,geometry.x,geometry.y,\n                  exception);\n                source=DestroyImageList(source);\n                break;\n              }\n            }\n            if (layers == (Image *) NULL)\n              break;\n            InheritException(exception,&layers->exception);\n            *images=DestroyImageList(*images);\n            *images=layers;\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL);\n                InheritException(exception,&(*images)->exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"maximum\",option+1) == 0)\n          {\n            Image\n              *maximum_image;\n\n            /*\n              Maximum image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images);\n            maximum_image=EvaluateImages(*images,MaxEvaluateOperator,exception);\n            if (maximum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=maximum_image;\n            break;\n          }\n        if (LocaleCompare(\"minimum\",option+1) == 0)\n          {\n            Image\n              *minimum_image;\n\n            /*\n              Minimum image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images);\n            minimum_image=EvaluateImages(*images,MinEvaluateOperator,exception);\n            if (minimum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=minimum_image;\n            break;\n          }\n        if (LocaleCompare(\"morph\",option+1) == 0)\n          {\n            Image\n              *morph_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            morph_image=MorphImages(*images,StringToUnsignedLong(argv[i+1]),\n              exception);\n            if (morph_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=morph_image;\n            break;\n          }\n        if (LocaleCompare(\"mosaic\",option+1) == 0)\n          {\n            Image\n              *mosaic_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            mosaic_image=MergeImageLayers(*images,MosaicLayer,exception);\n            if (mosaic_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=mosaic_image;\n            break;\n          }\n        break;\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"poly\",option+1) == 0)\n          {\n            char\n              *args,\n              token[MaxTextExtent];\n\n            const char\n              *p;\n\n            double\n              *arguments;\n\n            Image\n              *polynomial_image;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_arguments;\n\n            /*\n              Polynomial image.\n            */\n            (void) SyncImageSettings(mogrify_info,*images);\n            args=InterpretImageProperties(mogrify_info,*images,argv[i+1]);\n            InheritException(exception,&(*images)->exception);\n            if (args == (char *) NULL)\n              break;\n            p=(char *) args;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MaxTextExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MaxTextExtent,token);\n            }\n            number_arguments=(size_t) x;\n            arguments=(double *) AcquireQuantumMemory(number_arguments,\n              sizeof(*arguments));\n            if (arguments == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*images)->filename);\n            (void) memset(arguments,0,number_arguments*\n              sizeof(*arguments));\n            p=(char *) args;\n            for (x=0; (x < (ssize_t) number_arguments) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MaxTextExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MaxTextExtent,token);\n              arguments[x]=StringToDouble(token,(char **) NULL);\n            }\n            args=DestroyString(args);\n            polynomial_image=PolynomialImageChannel(*images,channel,\n              number_arguments >> 1,arguments,exception);\n            arguments=(double *) RelinquishMagickMemory(arguments);\n            if (polynomial_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=polynomial_image;\n            break;\n          }\n        if (LocaleCompare(\"print\",option+1) == 0)\n          {\n            char\n              *string;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            string=InterpretImageProperties(mogrify_info,*images,argv[i+1]);\n            if (string == (char *) NULL)\n              break;\n            InheritException(exception,&(*images)->exception);\n            (void) FormatLocaleFile(stdout,\"%s\",string);\n            string=DestroyString(string);\n          }\n        if (LocaleCompare(\"process\",option+1) == 0)\n          {\n            char\n              **arguments;\n\n            int\n              j,\n              number_arguments;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            arguments=StringToArgv(argv[i+1],&number_arguments);\n            if (arguments == (char **) NULL)\n              break;\n            if ((argc > 1) && (strchr(arguments[1],'=') != (char *) NULL))\n              {\n                char\n                  breaker,\n                  quote,\n                  *token;\n\n                const char\n                  *arguments;\n\n                int\n                  next,\n                  status;\n\n                size_t\n                  length;\n\n                TokenInfo\n                  *token_info;\n\n                /*\n                  Support old style syntax, filter=\"-option arg\".\n                */\n                length=strlen(argv[i+1]);\n                token=(char *) NULL;\n                if (~length >= (MaxTextExtent-1))\n                  token=(char *) AcquireQuantumMemory(length+MaxTextExtent,\n                    sizeof(*token));\n                if (token == (char *) NULL)\n                  break;\n                next=0;\n                arguments=argv[i+1];\n                token_info=AcquireTokenInfo();\n                status=Tokenizer(token_info,0,token,length,arguments,\"\",\"=\",\n                  \"\\\"\",'\\0',&breaker,&next,&quote);\n                token_info=DestroyTokenInfo(token_info);\n                if (status == 0)\n                  {\n                    const char\n                      *argv;\n\n                    argv=(&(arguments[next]));\n                    (void) InvokeDynamicImageFilter(token,&(*images),1,&argv,\n                      exception);\n                  }\n                token=DestroyString(token);\n                break;\n              }\n            (void) SubstituteString(&arguments[1],\"-\",\"\");\n            (void) InvokeDynamicImageFilter(arguments[1],&(*images),\n              number_arguments-2,(const char **) arguments+2,exception);\n            for (j=0; j < number_arguments; j++)\n              arguments[j]=DestroyString(arguments[j]);\n            arguments=(char **) RelinquishMagickMemory(arguments);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"reverse\",option+1) == 0)\n          {\n            ReverseImageList(images);\n            InheritException(exception,&(*images)->exception);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"smush\",option+1) == 0)\n          {\n            Image\n              *smush_image;\n\n            ssize_t\n              offset;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            offset=(ssize_t) StringToLong(argv[i+1]);\n            smush_image=SmushImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,offset,exception);\n            if (smush_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=smush_image;\n            break;\n          }\n        if (LocaleCompare(\"swap\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q,\n              *u,\n              *v;\n\n            ssize_t\n              swap_index;\n\n            index=(-1);\n            swap_index=(-2);\n            if (*option != '+')\n              {\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                swap_index=(-1);\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                index=(ssize_t) geometry_info.rho;\n                if ((flags & SigmaValue) != 0)\n                  swap_index=(ssize_t) geometry_info.sigma;\n              }\n            p=GetImageFromList(*images,index);\n            q=GetImageFromList(*images,swap_index);\n            if ((p == (Image *) NULL) || (q == (Image *) NULL))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",(*images)->filename);\n                status=MagickFalse;\n                break;\n              }\n            if (p == q)\n              break;\n            u=CloneImage(p,0,0,MagickTrue,exception);\n            if (u == (Image *) NULL)\n              break;\n            v=CloneImage(q,0,0,MagickTrue,exception);\n            if (v == (Image *) NULL)\n              {\n                u=DestroyImage(u);\n                break;\n              }\n            ReplaceImageInList(&p,v);\n            ReplaceImageInList(&q,u);\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"write\",option+1) == 0)\n          {\n            char\n              key[MaxTextExtent];\n\n            Image\n              *write_images;\n\n            ImageInfo\n              *write_info;\n\n            (void) SyncImagesSettings(mogrify_info,*images);\n            (void) FormatLocaleString(key,MaxTextExtent,\"cache:%s\",argv[i+1]);\n            (void) DeleteImageRegistry(key);\n            write_images=(*images);\n            if (*option == '+')\n              write_images=CloneImageList(*images,exception);\n            write_info=CloneImageInfo(mogrify_info);\n            status&=WriteImages(write_info,write_images,argv[i+1],exception);\n            write_info=DestroyImageInfo(write_info);\n            if (*option == '+')\n              write_images=DestroyImageList(write_images);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    i+=count;\n  }\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  mogrify_info=DestroyImageInfo(mogrify_info);\n  status&=MogrifyImageInfo(image_info,argc,argv,exception);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void AutofillPopupBaseView::DoShow() {\n  const bool initialize_widget = !GetWidget();\n  if (initialize_widget) {\n    if (parent_widget_)\n      parent_widget_->AddObserver(this);\n\n    views::Widget* widget = new views::Widget;\n    views::Widget::InitParams params(views::Widget::InitParams::TYPE_POPUP);\n     params.delegate = this;\n     params.parent = parent_widget_ ? parent_widget_->GetNativeView()\n                                    : delegate_->container_view();\n    AddExtraInitParams(&params);\n     widget->Init(params);\n    std::unique_ptr<views::View> wrapper = CreateWrapperView();\n    if (wrapper)\n      widget->SetContentsView(wrapper.release());\n     widget->AddObserver(this);\n \n    widget->SetVisibilityAnimationTransition(views::Widget::ANIMATE_HIDE);\n\n    show_time_ = base::Time::Now();\n  }\n\n  GetWidget()->GetRootView()->SetBorder(CreateBorder());\n  DoUpdateBoundsAndRedrawPopup();\n  GetWidget()->Show();\n\n  if (initialize_widget)\n    views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MagickPathExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  pwp_image=image;\n  memset(magick,0,sizeof(magick));\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(filename);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"sfw:%s\",\n    filename);\n  for ( ; ; )\n  {\n    (void) memset(magick,0,sizeof(magick));\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n       c=ReadBlobByte(pwp_image);\n       if (c == EOF)\n         break;\n      (void) fputc(c,file);\n     }\n     (void) fclose(file);\n     if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MagickPathExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          char\n            *message;\n\n          message=GetExceptionMessage(errno);\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\n            message);\n          message=DestroyString(message);\n        }\n      (void) CloseBlob(image);\n    }\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "NetworkHandler::NetworkHandler(const std::string& host_id)\n     : DevToolsDomainHandler(Network::Metainfo::domainName),\n      process_(nullptr),\n       host_(nullptr),\n       enabled_(false),\n       host_id_(host_id),\n      bypass_service_worker_(false),\n      cache_disabled_(false),\n      weak_factory_(this) {\n  static bool have_configured_service_worker_context = false;\n  if (have_configured_service_worker_context)\n    return;\n  have_configured_service_worker_context = true;\n  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                          base::BindOnce(&ConfigureServiceWorkerContextOnIO));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void HandleCompleteLogin(const base::ListValue* args) {\n#if defined(OS_CHROMEOS)\n    oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));\n    oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(\n        oauth2_delegate_.get(), profile_->GetRequestContext()));\n    oauth2_token_fetcher_->StartExchangeFromCookies();\n#elif !defined(OS_ANDROID)\n    const base::DictionaryValue* dict = NULL;\n    string16 email;\n    string16 password;\n    if (!args->GetDictionary(0, &dict) || !dict ||\n        !dict->GetString(\"email\", &email) ||\n        !dict->GetString(\"password\", &password)) {\n      NOTREACHED();\n      return;\n    }\n\n    new OneClickSigninSyncStarter(\n        profile_, NULL, \"0\" /* session_index 0 for the default user */,\n         UTF16ToASCII(email), UTF16ToASCII(password),\n         OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,\n         true /* force_same_tab_navigation */,\n        OneClickSigninSyncStarter::NO_CONFIRMATION);\n     web_ui()->CallJavascriptFunction(\"inline.login.closeDialog\");\n #endif\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ShellContentBrowserClient::RenderProcessWillLaunch(\n    RenderProcessHost* host) {\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kExposeIpcEcho))\n    host->AddFilter(new IPCEchoMessageFilter());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool RenderThread::Send(IPC::Message* msg) {\n  bool pumping_events = false;\n  if (msg->is_sync()) {\n    if (msg->is_caller_pumping_messages()) {\n      pumping_events = true;\n    } else {\n      if ((msg->type() == ViewHostMsg_GetCookies::ID ||\n           msg->type() == ViewHostMsg_GetRawCookies::ID ||\n           msg->type() == ViewHostMsg_CookiesEnabled::ID) &&\n          content::GetContentClient()->renderer()->\n              ShouldPumpEventsDuringCookieMessage()) {\n        pumping_events = true;\n      }\n    }\n  }\n\n  bool suspend_webkit_shared_timer = true;  // default value\n  std::swap(suspend_webkit_shared_timer, suspend_webkit_shared_timer_);\n\n  bool notify_webkit_of_modal_loop = true;  // default value\n  std::swap(notify_webkit_of_modal_loop, notify_webkit_of_modal_loop_);\n\n  gfx::NativeViewId host_window = 0;\n\n  if (pumping_events) {\n    if (suspend_webkit_shared_timer)\n      webkit_client_->SuspendSharedTimer();\n\n    if (notify_webkit_of_modal_loop)\n      WebView::willEnterModalLoop();\n\n    RenderWidget* widget =\n        static_cast<RenderWidget*>(ResolveRoute(msg->routing_id()));\n    if (widget) {\n      host_window = widget->host_window();\n      PluginChannelHost::Broadcast(\n          new PluginMsg_SignalModalDialogEvent(host_window));\n    }\n  }\n\n  bool rv = ChildThread::Send(msg);\n\n  if (pumping_events) {\n    if (host_window) {\n      PluginChannelHost::Broadcast(\n          new PluginMsg_ResetModalDialogEvent(host_window));\n    }\n\n    if (notify_webkit_of_modal_loop)\n      WebView::didExitModalLoop();\n\n    if (suspend_webkit_shared_timer)\n      webkit_client_->ResumeSharedTimer();\n  }\n\n  return rv;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MagickExport void SetQuantumMinIsWhite(QuantumInfo *quantum_info,\n  const MagickBooleanType min_is_white)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->min_is_white=min_is_white;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n \tint i_size_changed = 0;\n \n \ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n \tif (ext4_has_inline_data(inode)) {\n \t\tret = ext4_write_inline_data_end(inode, pos, len,\n \t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\t/*\n\t * it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static sk_sp<SkImage> flipSkImageVertically(SkImage* input,\n                                             AlphaDisposition alphaOp) {\n  size_t width = static_cast<size_t>(input->width());\n  size_t height = static_cast<size_t>(input->height());\n   SkImageInfo info = SkImageInfo::MakeN32(input->width(), input->height(),\n                                           (alphaOp == PremultiplyAlpha)\n                                               ? kPremul_SkAlphaType\n                                               : kUnpremul_SkAlphaType);\n  size_t imageRowBytes = width * info.bytesPerPixel();\n   RefPtr<Uint8Array> imagePixels = copySkImageData(input, info);\n   if (!imagePixels)\n     return nullptr;\n  for (size_t i = 0; i < height / 2; i++) {\n    size_t topFirstElement = i * imageRowBytes;\n    size_t topLastElement = (i + 1) * imageRowBytes;\n    size_t bottomFirstElement = (height - 1 - i) * imageRowBytes;\n     std::swap_ranges(imagePixels->data() + topFirstElement,\n                      imagePixels->data() + topLastElement,\n                      imagePixels->data() + bottomFirstElement);\n  }\n  return newSkImageFromRaster(info, std::move(imagePixels), imageRowBytes);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline int check_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long addr, unsigned long end,\n\t\tconst nodemask_t *nodes, unsigned long flags,\n\t\tvoid *private)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n \t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\tif (pmd_none_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tif (check_pte_range(vma, pmd, addr, next, nodes,\n \t\t\t\t    flags, private))\n\t\t\treturn -EIO;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadDIBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  DIBInfo\n    dib_info;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  ssize_t\n    bit,\n    y;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a DIB file.\n   */\n   (void) ResetMagickMemory(&dib_info,0,sizeof(dib_info));\n   dib_info.size=ReadBlobLSBLong(image);\n  if (dib_info.size!=40)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   /*\n     Microsoft Windows 3.X DIB image file.\n  */\n  dib_info.width=(short) ReadBlobLSBLong(image);\n  dib_info.height=(short) ReadBlobLSBLong(image);\n  dib_info.planes=ReadBlobLSBShort(image);\n  dib_info.bits_per_pixel=ReadBlobLSBShort(image);\n  dib_info.compression=ReadBlobLSBLong(image);\n  dib_info.image_size=ReadBlobLSBLong(image);\n  dib_info.x_pixels=ReadBlobLSBLong(image);\n  dib_info.y_pixels=ReadBlobLSBLong(image);\n  dib_info.number_colors=ReadBlobLSBLong(image);\n  dib_info.colors_important=ReadBlobLSBLong(image);\n  if ((dib_info.compression == BI_BITFIELDS) &&\n      ((dib_info.bits_per_pixel == 16) || (dib_info.bits_per_pixel == 32)))\n    {\n      dib_info.red_mask=ReadBlobLSBLong(image);\n      dib_info.green_mask=ReadBlobLSBLong(image);\n      dib_info.blue_mask=ReadBlobLSBLong(image);\n    }\n  image->matte=dib_info.bits_per_pixel == 32 ? MagickTrue : MagickFalse;\n  image->columns=(size_t) MagickAbsoluteValue(dib_info.width);\n  image->rows=(size_t) MagickAbsoluteValue(dib_info.height);\n  image->depth=8;\n  if ((dib_info.number_colors != 0) || (dib_info.bits_per_pixel < 16))\n    {\n      size_t\n        one;\n\n      image->storage_class=PseudoClass;\n      image->colors=dib_info.number_colors;\n      one=1;\n      if (image->colors == 0)\n        image->colors=one << dib_info.bits_per_pixel;\n    }\n  if (image_info->size)\n    {\n      RectangleInfo\n        geometry;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseAbsoluteGeometry(image_info->size,&geometry);\n      if (flags & WidthValue)\n        if ((geometry.width != 0) && (geometry.width < image->columns))\n          image->columns=geometry.width;\n      if (flags & HeightValue)\n         if ((geometry.height != 0) && (geometry.height < image->rows))\n           image->rows=geometry.height;\n     }\n   if (image->storage_class == PseudoClass)\n     {\n       size_t\n        length,\n        packet_size;\n\n      unsigned char\n        *dib_colormap;\n\n      /*\n        Read DIB raster colormap.\n      */\n      if (AcquireImageColormap(image,image->colors) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      length=(size_t) image->colors;\n      dib_colormap=(unsigned char *) AcquireQuantumMemory(length,\n        4*sizeof(*dib_colormap));\n      if (dib_colormap == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      packet_size=4;\n      count=ReadBlob(image,packet_size*image->colors,dib_colormap);\n      if (count != (ssize_t) (packet_size*image->colors))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      p=dib_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        image->colormap[i].blue=ScaleCharToQuantum(*p++);\n        image->colormap[i].green=ScaleCharToQuantum(*p++);\n        image->colormap[i].red=ScaleCharToQuantum(*p++);\n        if (packet_size == 4)\n          p++;\n      }\n      dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);\n    }\n  /*\n    Read image data.\n  */\n  if (dib_info.compression == BI_RLE4)\n    dib_info.bits_per_pixel<<=1;\n  bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);\n  length=bytes_per_line*image->rows;\n  pixel_info=AcquireVirtualMemory((size_t) image->rows,MagickMax(\n    bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  if ((dib_info.compression == BI_RGB) ||\n      (dib_info.compression == BI_BITFIELDS))\n    {\n      count=ReadBlob(image,length,pixels);\n      if (count != (ssize_t) (length))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    }\n  else\n    {\n      /*\n        Convert run-length encoded raster pixels.\n      */\n      status=DecodeImage(image,dib_info.compression ? MagickTrue : MagickFalse,\n        pixels);\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToRunlengthDecodeImage\");\n    }\n  /*\n    Initialize image structure.\n  */\n  image->units=PixelsPerCentimeterResolution;\n  image->x_resolution=(double) dib_info.x_pixels/100.0;\n  image->y_resolution=(double) dib_info.y_pixels/100.0;\n  /*\n    Convert DIB raster image to pixel packets.\n  */\n  switch (dib_info.bits_per_pixel)\n  {\n    case 1:\n    {\n      /*\n        Convert bitmap scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(IndexPacket) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(indexes+x+bit,index);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=(IndexPacket) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n            }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Convert PseudoColor scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n        {\n          index=ConstrainColormapIndex(image,(*p >> 4) & 0xf);\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,*p & 0xf);\n          SetPixelIndex(indexes+x+1,index);\n          p++;\n        }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf);\n            SetPixelIndex(indexes+x,index);\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 8:\n    {\n      /*\n        Convert PseudoColor scanline.\n      */\n      if ((dib_info.compression == BI_RLE8) ||\n          (dib_info.compression == BI_RLE4))\n        bytes_per_line=image->columns;\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,*p);\n          SetPixelIndex(indexes+x,index);\n          p++;\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        word;\n\n      /*\n        Convert PseudoColor scanline.\n      */\n      image->storage_class=DirectClass;\n      if (dib_info.compression == BI_RLE8)\n        bytes_per_line=2*image->columns;\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          word=(*p++);\n          word|=(*p++ << 8);\n          if (dib_info.red_mask == 0)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 10) & 0x1f))));\n              SetPixelGreen(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 5) & 0x1f))));\n              SetPixelBlue(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) (word & 0x1f))));\n            }\n          else\n            {\n              SetPixelRed(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 11) & 0x1f))));\n              SetPixelGreen(q,ScaleCharToQuantum(ScaleColor6to8(\n                (unsigned char) ((word >> 5) & 0x3f))));\n              SetPixelBlue(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) (word & 0x1f))));\n            }\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      break;\n    }\n    case 24:\n    case 32:\n    {\n      /*\n        Convert DirectColor scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelBlue(q,ScaleCharToQuantum(*p++));\n          SetPixelGreen(q,ScaleCharToQuantum(*p++));\n          SetPixelRed(q,ScaleCharToQuantum(*p++));\n          if (image->matte != MagickFalse)\n            SetPixelOpacity(q,ScaleCharToQuantum(*p++));\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (dib_info.height < 0)\n    {\n      Image\n        *flipped_image;\n\n      /*\n        Correct image orientation.\n      */\n      flipped_image=FlipImage(image,exception);\n      if (flipped_image != (Image *) NULL)\n        {\n          DuplicateBlob(flipped_image,image);\n          image=DestroyImage(image);\n          image=flipped_image;\n        }\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void ImportCMYKQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline struct shmid_kernel *shm_obtain_object(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void conditionalAndLongAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::conditionalAndLongAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "expand_getlistele(int field, uschar * list)\n{\nuschar * tlist= list;\nint sep= 0;\nuschar dummy;\n\nif(field<0)\n{\n  for(field++; string_nextinlist(&tlist, &sep, &dummy, 1); ) field++;\n  sep= 0;\n}\nif(field==0) return NULL;\nwhile(--field>0 && (string_nextinlist(&list, &sep, &dummy, 1))) ;\nreturn string_nextinlist(&list, &sep, NULL, 0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void webkit_web_view_paste_clipboard(WebKitWebView* webView)\n{\n    g_return_if_fail(WEBKIT_IS_WEB_VIEW(webView));\n\n    if (webkit_web_view_can_paste_clipboard(webView))\n        g_signal_emit(webView, webkit_web_view_signals[PASTE_CLIPBOARD], 0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "png_write_find_filter(png_structp png_ptr, png_row_infop row_info)\n{\n   png_bytep best_row;\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n   png_bytep prev_row, row_buf;\n    png_uint_32 mins, bpp;\n    png_byte filter_to_do = png_ptr->do_filter;\n    png_uint_32 row_bytes = row_info->rowbytes;\n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n   int num_p_filters = (int)png_ptr->num_prev_filters;\n#endif \n \n    png_debug(1, \"in png_write_find_filter\");\n \n#ifndef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n  if (png_ptr->row_number == 0 && filter_to_do == PNG_ALL_FILTERS)\n  {\n      /* These will never be selected so we need not test them. */\n      filter_to_do &= ~(PNG_FILTER_UP | PNG_FILTER_PAETH);\n  }\n#endif \n    /* Find out how many bytes offset each pixel is */\n    bpp = (row_info->pixel_depth + 7) >> 3;\n \n   prev_row = png_ptr->prev_row;\n#endif\n   best_row = png_ptr->row_buf;\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n   row_buf = best_row;\n   mins = PNG_MAXSUM;\n\n   /* The prediction method we use is to find which method provides the\n    * smallest value when summing the absolute values of the distances\n    * from zero, using anything >= 128 as negative numbers.  This is known\n    * as the \"minimum sum of absolute differences\" heuristic.  Other\n    * heuristics are the \"weighted minimum sum of absolute differences\"\n    * (experimental and can in theory improve compression), and the \"zlib\n    * predictive\" method (not implemented yet), which does test compressions\n    * of lines using different filter methods, and then chooses the\n    * (series of) filter(s) that give minimum compressed data size (VERY\n    * computationally expensive).\n    *\n    * GRR 980525:  consider also\n    *   (1) minimum sum of absolute differences from running average (i.e.,\n    *       keep running sum of non-absolute differences & count of bytes)\n    *       [track dispersion, too?  restart average if dispersion too large?]\n    *  (1b) minimum sum of absolute differences from sliding average, probably\n    *       with window size <= deflate window (usually 32K)\n    *   (2) minimum sum of squared differences from zero or running average\n    *       (i.e., ~ root-mean-square approach)\n    */\n\n\n   /* We don't need to test the 'no filter' case if this is the only filter\n    * that has been chosen, as it doesn't actually do anything to the data.\n    */\n   if ((filter_to_do & PNG_FILTER_NONE) &&\n       filter_to_do != PNG_FILTER_NONE)\n   {\n      png_bytep rp;\n      png_uint_32 sum = 0;\n      png_uint_32 i;\n      int v;\n\n      for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)\n      {\n         v = *rp;\n          sum += (v < 128) ? v : 256 - v;\n       }\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         png_uint_32 sumhi, sumlo;\n         int j;\n         sumlo = sum & PNG_LOMASK;\n         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */\n         /* Reduce the sum if we match any of the previous rows */\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)\n            {\n               sumlo = (sumlo * png_ptr->filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               sumhi = (sumhi * png_ptr->filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         /* Factor in the cost of this filter (this is here for completeness,\n          * but it makes no sense to have a \"cost\" for the NONE filter, as\n          * it has the minimum possible computational cost - none).\n          */\n         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>\n            PNG_COST_SHIFT;\n         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>\n            PNG_COST_SHIFT;\n         if (sumhi > PNG_HIMASK)\n            sum = PNG_MAXSUM;\n         else\n            sum = (sumhi << PNG_HISHIFT) + sumlo;\n      }\n#endif\n       mins = sum;\n    }\n \n   /* Sub filter */\n   if (filter_to_do == PNG_FILTER_SUB)\n   /* It's the only filter so no testing is needed */\n   {\n      png_bytep rp, lp, dp;\n      png_uint_32 i;\n      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;\n           i++, rp++, dp++)\n      {\n         *dp = *rp;\n      }\n      for (lp = row_buf + 1; i < row_bytes;\n         i++, rp++, lp++, dp++)\n      {\n         *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);\n      }\n      best_row = png_ptr->sub_row;\n   }\n\n   else if (filter_to_do & PNG_FILTER_SUB)\n   {\n      png_bytep rp, dp, lp;\n      png_uint_32 sum = 0, lmins = mins;\n       png_uint_32 i;\n       int v;\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      /* We temporarily increase the \"minimum sum\" by the factor we\n       * would reduce the sum of this filter, so that we can do the\n       * early exit comparison without scaling the sum each time.\n       */\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         int j;\n         png_uint_32 lmhi, lmlo;\n         lmlo = lmins & PNG_LOMASK;\n         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)\n            {\n               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>\n            PNG_COST_SHIFT;\n         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>\n            PNG_COST_SHIFT;\n         if (lmhi > PNG_HIMASK)\n            lmins = PNG_MAXSUM;\n         else\n            lmins = (lmhi << PNG_HISHIFT) + lmlo;\n      }\n#endif\n       for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;\n            i++, rp++, dp++)\n       {\n         v = *dp = *rp;\n\n         sum += (v < 128) ? v : 256 - v;\n      }\n      for (lp = row_buf + 1; i < row_bytes;\n         i++, rp++, lp++, dp++)\n      {\n         v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);\n\n         sum += (v < 128) ? v : 256 - v;\n\n         if (sum > lmins)  /* We are already worse, don't continue. */\n             break;\n       }\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         int j;\n         png_uint_32 sumhi, sumlo;\n         sumlo = sum & PNG_LOMASK;\n         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)\n            {\n               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>\n            PNG_COST_SHIFT;\n         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>\n            PNG_COST_SHIFT;\n         if (sumhi > PNG_HIMASK)\n            sum = PNG_MAXSUM;\n         else\n            sum = (sumhi << PNG_HISHIFT) + sumlo;\n      }\n#endif\n       if (sum < mins)\n       {\n          mins = sum;\n         best_row = png_ptr->sub_row;\n      }\n   }\n\n   /* Up filter */\n   if (filter_to_do == PNG_FILTER_UP)\n   {\n      png_bytep rp, dp, pp;\n      png_uint_32 i;\n\n      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,\n           pp = prev_row + 1; i < row_bytes;\n           i++, rp++, pp++, dp++)\n      {\n         *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);\n      }\n      best_row = png_ptr->up_row;\n   }\n\n   else if (filter_to_do & PNG_FILTER_UP)\n   {\n      png_bytep rp, dp, pp;\n      png_uint_32 sum = 0, lmins = mins;\n       png_uint_32 i;\n       int v;\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         int j;\n         png_uint_32 lmhi, lmlo;\n         lmlo = lmins & PNG_LOMASK;\n         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)\n            {\n               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>\n            PNG_COST_SHIFT;\n         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>\n            PNG_COST_SHIFT;\n         if (lmhi > PNG_HIMASK)\n            lmins = PNG_MAXSUM;\n         else\n            lmins = (lmhi << PNG_HISHIFT) + lmlo;\n      }\n#endif\n       for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,\n            pp = prev_row + 1; i < row_bytes; i++)\n       {\n         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);\n\n         sum += (v < 128) ? v : 256 - v;\n\n         if (sum > lmins)  /* We are already worse, don't continue. */\n             break;\n       }\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         int j;\n         png_uint_32 sumhi, sumlo;\n         sumlo = sum & PNG_LOMASK;\n         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)\n            {\n               sumlo = (sumlo * png_ptr->filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               sumhi = (sumhi * png_ptr->filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>\n            PNG_COST_SHIFT;\n         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>\n            PNG_COST_SHIFT;\n         if (sumhi > PNG_HIMASK)\n            sum = PNG_MAXSUM;\n         else\n            sum = (sumhi << PNG_HISHIFT) + sumlo;\n      }\n#endif\n       if (sum < mins)\n       {\n          mins = sum;\n         best_row = png_ptr->up_row;\n      }\n   }\n\n   /* Avg filter */\n   if (filter_to_do == PNG_FILTER_AVG)\n   {\n      png_bytep rp, dp, pp, lp;\n      png_uint_32 i;\n      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,\n           pp = prev_row + 1; i < bpp; i++)\n      {\n         *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);\n      }\n      for (lp = row_buf + 1; i < row_bytes; i++)\n      {\n         *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))\n                 & 0xff);\n      }\n      best_row = png_ptr->avg_row;\n   }\n\n   else if (filter_to_do & PNG_FILTER_AVG)\n   {\n      png_bytep rp, dp, pp, lp;\n      png_uint_32 sum = 0, lmins = mins;\n       png_uint_32 i;\n       int v;\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         int j;\n         png_uint_32 lmhi, lmlo;\n         lmlo = lmins & PNG_LOMASK;\n         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)\n            {\n               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>\n            PNG_COST_SHIFT;\n         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>\n            PNG_COST_SHIFT;\n         if (lmhi > PNG_HIMASK)\n            lmins = PNG_MAXSUM;\n         else\n            lmins = (lmhi << PNG_HISHIFT) + lmlo;\n      }\n#endif\n       for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,\n            pp = prev_row + 1; i < bpp; i++)\n       {\n         v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);\n\n         sum += (v < 128) ? v : 256 - v;\n      }\n      for (lp = row_buf + 1; i < row_bytes; i++)\n      {\n         v = *dp++ =\n          (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);\n\n         sum += (v < 128) ? v : 256 - v;\n\n         if (sum > lmins)  /* We are already worse, don't continue. */\n             break;\n       }\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         int j;\n         png_uint_32 sumhi, sumlo;\n         sumlo = sum & PNG_LOMASK;\n         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)\n            {\n               sumlo = (sumlo * png_ptr->filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               sumhi = (sumhi * png_ptr->filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>\n            PNG_COST_SHIFT;\n         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>\n            PNG_COST_SHIFT;\n         if (sumhi > PNG_HIMASK)\n            sum = PNG_MAXSUM;\n         else\n            sum = (sumhi << PNG_HISHIFT) + sumlo;\n      }\n#endif\n       if (sum < mins)\n       {\n          mins = sum;\n         best_row = png_ptr->avg_row;\n      }\n   }\n\n   /* Paeth filter */\n   if (filter_to_do == PNG_FILTER_PAETH)\n   {\n      png_bytep rp, dp, pp, cp, lp;\n      png_uint_32 i;\n      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,\n           pp = prev_row + 1; i < bpp; i++)\n      {\n         *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);\n      }\n\n      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)\n      {\n         int a, b, c, pa, pb, pc, p;\n\n         b = *pp++;\n         c = *cp++;\n         a = *lp++;\n\n         p = b - c;\n         pc = a - c;\n\n#ifdef PNG_USE_ABS\n         pa = abs(p);\n         pb = abs(pc);\n         pc = abs(p + pc);\n#else\n         pa = p < 0 ? -p : p;\n         pb = pc < 0 ? -pc : pc;\n         pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n\n         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;\n\n         *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);\n      }\n      best_row = png_ptr->paeth_row;\n   }\n\n   else if (filter_to_do & PNG_FILTER_PAETH)\n   {\n      png_bytep rp, dp, pp, cp, lp;\n      png_uint_32 sum = 0, lmins = mins;\n       png_uint_32 i;\n       int v;\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         int j;\n         png_uint_32 lmhi, lmlo;\n         lmlo = lmins & PNG_LOMASK;\n         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)\n            {\n               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>\n            PNG_COST_SHIFT;\n         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>\n            PNG_COST_SHIFT;\n         if (lmhi > PNG_HIMASK)\n            lmins = PNG_MAXSUM;\n         else\n            lmins = (lmhi << PNG_HISHIFT) + lmlo;\n      }\n#endif\n       for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,\n            pp = prev_row + 1; i < bpp; i++)\n       {\n         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);\n\n         sum += (v < 128) ? v : 256 - v;\n      }\n\n      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)\n      {\n         int a, b, c, pa, pb, pc, p;\n\n         b = *pp++;\n         c = *cp++;\n         a = *lp++;\n\n#ifndef PNG_SLOW_PAETH\n         p = b - c;\n         pc = a - c;\n#ifdef PNG_USE_ABS\n         pa = abs(p);\n         pb = abs(pc);\n         pc = abs(p + pc);\n#else\n         pa = p < 0 ? -p : p;\n         pb = pc < 0 ? -pc : pc;\n         pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;\n#else /* PNG_SLOW_PAETH */\n         p = a + b - c;\n         pa = abs(p - a);\n         pb = abs(p - b);\n         pc = abs(p - c);\n         if (pa <= pb && pa <= pc)\n            p = a;\n         else if (pb <= pc)\n            p = b;\n         else\n            p = c;\n#endif /* PNG_SLOW_PAETH */\n\n         v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);\n\n         sum += (v < 128) ? v : 256 - v;\n\n         if (sum > lmins)  /* We are already worse, don't continue. */\n             break;\n       }\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)\n      {\n         int j;\n         png_uint_32 sumhi, sumlo;\n         sumlo = sum & PNG_LOMASK;\n         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;\n         for (j = 0; j < num_p_filters; j++)\n         {\n            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)\n            {\n               sumlo = (sumlo * png_ptr->filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n               sumhi = (sumhi * png_ptr->filter_weights[j]) >>\n                  PNG_WEIGHT_SHIFT;\n            }\n         }\n         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>\n            PNG_COST_SHIFT;\n         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>\n            PNG_COST_SHIFT;\n         if (sumhi > PNG_HIMASK)\n            sum = PNG_MAXSUM;\n         else\n            sum = (sumhi << PNG_HISHIFT) + sumlo;\n      }\n#endif\n       if (sum < mins)\n       {\n          best_row = png_ptr->paeth_row;\n      }\n   }\n#endif /* PNG_WRITE_FILTER_SUPPORTED */\n    /* Do the actual writing of the filtered row data from the chosen filter. */\n \n    png_write_filtered_row(png_ptr, best_row);\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n   /* Save the type of filter we picked this time for future calculations */\n   if (png_ptr->num_prev_filters > 0)\n   {\n      int j;\n      for (j = 1; j < num_p_filters; j++)\n      {\n         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];\n      }\n      png_ptr->prev_filters[j] = best_row[0];\n   }\n#endif\n#endif /* PNG_WRITE_FILTER_SUPPORTED */\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_16 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tctxt->_eip = tss->ip;\n\tctxt->eflags = tss->flag | 2;\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->ax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->cx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->dx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->bx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->sp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->bp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->si;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->di;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors\n\t */\n\tset_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\tcpl = tss->cs & 3;\n\n\t/*\n \t * Now load segment descriptors. If fault happens at this stage\n \t * it is handled in a context of new task\n \t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n \n\treturn X86EMUL_CONTINUE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int prism2_update_comms_qual(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret = 0;\n\tstruct hfa384x_comms_quality sq;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tif (!local->sta_fw_ver)\n\t\tret = -1;\n\telse if (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1)) {\n\t\tif (local->func->get_rid(local->dev,\n\t\t\t\t\t HFA384X_RID_DBMCOMMSQUALITY,\n\t\t\t\t\t &sq, sizeof(sq), 1) >= 0) {\n\t\t\tlocal->comms_qual = (s16) le16_to_cpu(sq.comm_qual);\n\t\t\tlocal->avg_signal = (s16) le16_to_cpu(sq.signal_level);\n\t\t\tlocal->avg_noise = (s16) le16_to_cpu(sq.noise_level);\n\t\t\tlocal->last_comms_qual_update = jiffies;\n\t\t} else\n\t\t\tret = -1;\n\t} else {\n\t\tif (local->func->get_rid(local->dev, HFA384X_RID_COMMSQUALITY,\n\t\t\t\t\t &sq, sizeof(sq), 1) >= 0) {\n\t\t\tlocal->comms_qual = le16_to_cpu(sq.comm_qual);\n\t\t\tlocal->avg_signal = HFA384X_LEVEL_TO_dBm(\n\t\t\t\tle16_to_cpu(sq.signal_level));\n\t\t\tlocal->avg_noise = HFA384X_LEVEL_TO_dBm(\n\t\t\t\tle16_to_cpu(sq.noise_level));\n\t\t\tlocal->last_comms_qual_update = jiffies;\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void OpenSSL_add_all_ciphers(void)\n\t{\n\n#ifndef OPENSSL_NO_DES\n\tEVP_add_cipher(EVP_des_cfb());\n\tEVP_add_cipher(EVP_des_cfb1());\n\tEVP_add_cipher(EVP_des_cfb8());\n\tEVP_add_cipher(EVP_des_ede_cfb());\n\tEVP_add_cipher(EVP_des_ede3_cfb());\n\tEVP_add_cipher(EVP_des_ede3_cfb1());\n\tEVP_add_cipher(EVP_des_ede3_cfb8());\n\n\tEVP_add_cipher(EVP_des_ofb());\n\tEVP_add_cipher(EVP_des_ede_ofb());\n\tEVP_add_cipher(EVP_des_ede3_ofb());\n\n\tEVP_add_cipher(EVP_desx_cbc());\n\tEVP_add_cipher_alias(SN_desx_cbc,\"DESX\");\n\tEVP_add_cipher_alias(SN_desx_cbc,\"desx\");\n\n\tEVP_add_cipher(EVP_des_cbc());\n\tEVP_add_cipher_alias(SN_des_cbc,\"DES\");\n\tEVP_add_cipher_alias(SN_des_cbc,\"des\");\n\tEVP_add_cipher(EVP_des_ede_cbc());\n\tEVP_add_cipher(EVP_des_ede3_cbc());\n\tEVP_add_cipher_alias(SN_des_ede3_cbc,\"DES3\");\n\tEVP_add_cipher_alias(SN_des_ede3_cbc,\"des3\");\n\n\tEVP_add_cipher(EVP_des_ecb());\n\tEVP_add_cipher(EVP_des_ede());\n\tEVP_add_cipher(EVP_des_ede3());\n#endif\n\n#ifndef OPENSSL_NO_RC4\n\tEVP_add_cipher(EVP_rc4());\n\tEVP_add_cipher(EVP_rc4_40());\n#ifndef OPENSSL_NO_MD5\n\tEVP_add_cipher(EVP_rc4_hmac_md5());\n#endif\n#endif\n\n#ifndef OPENSSL_NO_IDEA\n\tEVP_add_cipher(EVP_idea_ecb());\n\tEVP_add_cipher(EVP_idea_cfb());\n\tEVP_add_cipher(EVP_idea_ofb());\n\tEVP_add_cipher(EVP_idea_cbc());\n\tEVP_add_cipher_alias(SN_idea_cbc,\"IDEA\");\n\tEVP_add_cipher_alias(SN_idea_cbc,\"idea\");\n#endif\n\n#ifndef OPENSSL_NO_SEED\n\tEVP_add_cipher(EVP_seed_ecb());\n\tEVP_add_cipher(EVP_seed_cfb());\n\tEVP_add_cipher(EVP_seed_ofb());\n\tEVP_add_cipher(EVP_seed_cbc());\n\tEVP_add_cipher_alias(SN_seed_cbc,\"SEED\");\n\tEVP_add_cipher_alias(SN_seed_cbc,\"seed\");\n#endif\n\n#ifndef OPENSSL_NO_RC2\n\tEVP_add_cipher(EVP_rc2_ecb());\n\tEVP_add_cipher(EVP_rc2_cfb());\n\tEVP_add_cipher(EVP_rc2_ofb());\n\tEVP_add_cipher(EVP_rc2_cbc());\n\tEVP_add_cipher(EVP_rc2_40_cbc());\n\tEVP_add_cipher(EVP_rc2_64_cbc());\n\tEVP_add_cipher_alias(SN_rc2_cbc,\"RC2\");\n\tEVP_add_cipher_alias(SN_rc2_cbc,\"rc2\");\n#endif\n\n#ifndef OPENSSL_NO_BF\n\tEVP_add_cipher(EVP_bf_ecb());\n\tEVP_add_cipher(EVP_bf_cfb());\n\tEVP_add_cipher(EVP_bf_ofb());\n\tEVP_add_cipher(EVP_bf_cbc());\n\tEVP_add_cipher_alias(SN_bf_cbc,\"BF\");\n\tEVP_add_cipher_alias(SN_bf_cbc,\"bf\");\n\tEVP_add_cipher_alias(SN_bf_cbc,\"blowfish\");\n#endif\n\n#ifndef OPENSSL_NO_CAST\n\tEVP_add_cipher(EVP_cast5_ecb());\n\tEVP_add_cipher(EVP_cast5_cfb());\n\tEVP_add_cipher(EVP_cast5_ofb());\n\tEVP_add_cipher(EVP_cast5_cbc());\n\tEVP_add_cipher_alias(SN_cast5_cbc,\"CAST\");\n\tEVP_add_cipher_alias(SN_cast5_cbc,\"cast\");\n\tEVP_add_cipher_alias(SN_cast5_cbc,\"CAST-cbc\");\n\tEVP_add_cipher_alias(SN_cast5_cbc,\"cast-cbc\");\n#endif\n\n#ifndef OPENSSL_NO_RC5\n\tEVP_add_cipher(EVP_rc5_32_12_16_ecb());\n\tEVP_add_cipher(EVP_rc5_32_12_16_cfb());\n\tEVP_add_cipher(EVP_rc5_32_12_16_ofb());\n\tEVP_add_cipher(EVP_rc5_32_12_16_cbc());\n\tEVP_add_cipher_alias(SN_rc5_cbc,\"rc5\");\n\tEVP_add_cipher_alias(SN_rc5_cbc,\"RC5\");\n#endif\n\n#ifndef OPENSSL_NO_AES\n\tEVP_add_cipher(EVP_aes_128_ecb());\n\tEVP_add_cipher(EVP_aes_128_cbc());\n\tEVP_add_cipher(EVP_aes_128_cfb());\n\tEVP_add_cipher(EVP_aes_128_cfb1());\n\tEVP_add_cipher(EVP_aes_128_cfb8());\n\tEVP_add_cipher(EVP_aes_128_ofb());\n\tEVP_add_cipher(EVP_aes_128_ctr());\n\tEVP_add_cipher(EVP_aes_128_gcm());\n\tEVP_add_cipher(EVP_aes_128_xts());\n\tEVP_add_cipher_alias(SN_aes_128_cbc,\"AES128\");\n\tEVP_add_cipher_alias(SN_aes_128_cbc,\"aes128\");\n\tEVP_add_cipher(EVP_aes_192_ecb());\n\tEVP_add_cipher(EVP_aes_192_cbc());\n\tEVP_add_cipher(EVP_aes_192_cfb());\n\tEVP_add_cipher(EVP_aes_192_cfb1());\n\tEVP_add_cipher(EVP_aes_192_cfb8());\n\tEVP_add_cipher(EVP_aes_192_ofb());\n\tEVP_add_cipher(EVP_aes_192_ctr());\n\tEVP_add_cipher(EVP_aes_192_gcm());\n\tEVP_add_cipher_alias(SN_aes_192_cbc,\"AES192\");\n\tEVP_add_cipher_alias(SN_aes_192_cbc,\"aes192\");\n\tEVP_add_cipher(EVP_aes_256_ecb());\n\tEVP_add_cipher(EVP_aes_256_cbc());\n\tEVP_add_cipher(EVP_aes_256_cfb());\n\tEVP_add_cipher(EVP_aes_256_cfb1());\n\tEVP_add_cipher(EVP_aes_256_cfb8());\n\tEVP_add_cipher(EVP_aes_256_ofb());\n\tEVP_add_cipher(EVP_aes_256_ctr());\n\tEVP_add_cipher(EVP_aes_256_gcm());\n        EVP_add_cipher(EVP_aes_256_xts());\n        EVP_add_cipher_alias(SN_aes_256_cbc,\"AES256\");\n        EVP_add_cipher_alias(SN_aes_256_cbc,\"aes256\");\n#if 0  /* Disabled because of timing side-channel leaks. */\n #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)\n        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());\n        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());\n #endif\n #endif\n#endif\n \n #ifndef OPENSSL_NO_CAMELLIA\n        EVP_add_cipher(EVP_camellia_128_ecb());\n#ifndef OPENSSL_NO_CAMELLIA\n\tEVP_add_cipher(EVP_camellia_128_ecb());\n\tEVP_add_cipher(EVP_camellia_128_cbc());\n\tEVP_add_cipher(EVP_camellia_128_cfb());\n\tEVP_add_cipher(EVP_camellia_128_cfb1());\n\tEVP_add_cipher(EVP_camellia_128_cfb8());\n\tEVP_add_cipher(EVP_camellia_128_ofb());\n\tEVP_add_cipher_alias(SN_camellia_128_cbc,\"CAMELLIA128\");\n\tEVP_add_cipher_alias(SN_camellia_128_cbc,\"camellia128\");\n\tEVP_add_cipher(EVP_camellia_192_ecb());\n\tEVP_add_cipher(EVP_camellia_192_cbc());\n\tEVP_add_cipher(EVP_camellia_192_cfb());\n\tEVP_add_cipher(EVP_camellia_192_cfb1());\n\tEVP_add_cipher(EVP_camellia_192_cfb8());\n\tEVP_add_cipher(EVP_camellia_192_ofb());\n\tEVP_add_cipher_alias(SN_camellia_192_cbc,\"CAMELLIA192\");\n\tEVP_add_cipher_alias(SN_camellia_192_cbc,\"camellia192\");\n\tEVP_add_cipher(EVP_camellia_256_ecb());\n\tEVP_add_cipher(EVP_camellia_256_cbc());\n\tEVP_add_cipher(EVP_camellia_256_cfb());\n\tEVP_add_cipher(EVP_camellia_256_cfb1());\n\tEVP_add_cipher(EVP_camellia_256_cfb8());\n\tEVP_add_cipher(EVP_camellia_256_ofb());\n\tEVP_add_cipher_alias(SN_camellia_256_cbc,\"CAMELLIA256\");\n\tEVP_add_cipher_alias(SN_camellia_256_cbc,\"camellia256\");\n#endif\n\t}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Editor::~Editor() {}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void perf_event_exit_cpu(int cpu)\n {\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n \tperf_event_exit_cpu_context(cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void dec_pending(struct dm_io *io, blk_status_t error)\n{\n\tunsigned long flags;\n\tblk_status_t io_error;\n\tstruct bio *bio;\n\tstruct mapped_device *md = io->md;\n\n\t/* Push-back supersedes any I/O errors */\n\tif (unlikely(error)) {\n\t\tspin_lock_irqsave(&io->endio_lock, flags);\n\t\tif (!(io->status == BLK_STS_DM_REQUEUE &&\n\t\t\t\t__noflush_suspending(md)))\n\t\t\tio->status = error;\n\t\tspin_unlock_irqrestore(&io->endio_lock, flags);\n\t}\n\n\tif (atomic_dec_and_test(&io->io_count)) {\n\t\tif (io->status == BLK_STS_DM_REQUEUE) {\n\t\t\t/*\n\t\t\t * Target requested pushing back the I/O.\n\t\t\t */\n\t\t\tspin_lock_irqsave(&md->deferred_lock, flags);\n\t\t\tif (__noflush_suspending(md))\n\t\t\t\tbio_list_add_head(&md->deferred, io->bio);\n\t\t\telse\n\t\t\t\t/* noflush suspend was interrupted. */\n\t\t\t\tio->status = BLK_STS_IOERR;\n\t\t\tspin_unlock_irqrestore(&md->deferred_lock, flags);\n\t\t}\n\n\t\tio_error = io->status;\n\t\tbio = io->bio;\n\t\tend_io_acct(io);\n\t\tfree_io(md, io);\n\n\t\tif (io_error == BLK_STS_DM_REQUEUE)\n\t\t\treturn;\n\n\t\tif ((bio->bi_opf & REQ_PREFLUSH) && bio->bi_iter.bi_size) {\n\t\t\t/*\n\t\t\t * Preflush done for flush with data, reissue\n\t\t\t * without REQ_PREFLUSH.\n\t\t\t */\n\t\t\tbio->bi_opf &= ~REQ_PREFLUSH;\n\t\t\tqueue_io(md, bio);\n\t\t} else {\n\t\t\t/* done with normal IO or empty flush */\n\t\t\tbio->bi_status = io_error;\n\t\t\tbio_endio(bio);\n\t\t}\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool ContentSecurityPolicy::ExperimentalFeaturesEnabled() const {\n  return RuntimeEnabledFeatures::\n      ExperimentalContentSecurityPolicyFeaturesEnabled();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int cp2112_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-388"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "std::vector<int> TabStripModel::GetIndicesClosedByCommand(\n    int index,\n    ContextMenuCommand id) const {\n  DCHECK(ContainsIndex(index));\n  DCHECK(id == CommandCloseTabsToRight || id == CommandCloseOtherTabs);\n  bool is_selected = IsTabSelected(index);\n  int start;\n  if (id == CommandCloseTabsToRight) {\n    if (is_selected) {\n      start = selection_model_.selected_indices()[\n          selection_model_.selected_indices().size() - 1] + 1;\n    } else {\n      start = index + 1;\n    }\n  } else {\n    start = 0;\n  }\n  std::vector<int> indices;\n  for (int i = count() - 1; i >= start; --i) {\n    if (i != index && !IsMiniTab(i) && (!is_selected || !IsTabSelected(i)))\n      indices.push_back(i);\n  }\n  return indices;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CWebServer::RType_AddScene(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\tif (session.rights != 2)\n\t\t\t{\n\t\t\t\tsession.reply_status = reply::forbidden;\n\t\t\t\treturn; //Only admin user allowed\n\t\t\t}\n\n\t\t\tstd::string name = request::findValue(&req, \"name\");\n\t\t\tif (name.empty())\n\t\t\t{\n\t\t\t\troot[\"status\"] = \"ERR\";\n\t\t\t\troot[\"message\"] = \"No Scene Name specified!\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::string stype = request::findValue(&req, \"scenetype\");\n\t\t\tif (stype.empty())\n\t\t\t{\n\t\t\t\troot[\"status\"] = \"ERR\";\n\t\t\t\troot[\"message\"] = \"No Scene Type specified!\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (m_sql.DoesSceneByNameExits(name) == true)\n\t\t\t{\n\t\t\t\troot[\"status\"] = \"ERR\";\n\t\t\t\troot[\"message\"] = \"A Scene with this Name already Exits!\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"AddScene\";\n\t\t\tm_sql.safe_query(\n\t\t\t\t\"INSERT INTO Scenes (Name,SceneType) VALUES ('%q',%d)\",\n\t\t\t\tname.c_str(),\n\t\t\t\tatoi(stype.c_str())\n\t\t\t);\n\t\t\tif (m_sql.m_bEnableEventSystem)\n\t\t\t{\n\t\t\t\tm_mainworker.m_eventsystem.GetCurrentScenesGroups();\n\t\t\t}\n\t\t}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-89"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int virtcons_freeze(struct virtio_device *vdev)\n{\n\tstruct ports_device *portdev;\n\tstruct port *port;\n\n\tportdev = vdev->priv;\n\n\tvdev->config->reset(vdev);\n\n\tvirtqueue_disable_cb(portdev->c_ivq);\n\tcancel_work_sync(&portdev->control_work);\n\tcancel_work_sync(&portdev->config_work);\n\t/*\n\t * Once more: if control_work_handler() was running, it would\n\t * enable the cb as the last step.\n\t */\n\tvirtqueue_disable_cb(portdev->c_ivq);\n\tremove_controlq_data(portdev);\n\n\tlist_for_each_entry(port, &portdev->ports, list) {\n\t\tvirtqueue_disable_cb(port->in_vq);\n\t\tvirtqueue_disable_cb(port->out_vq);\n\t\t/*\n\t\t * We'll ask the host later if the new invocation has\n\t\t * the port opened or closed.\n\t\t */\n\t\tport->host_connected = false;\n\t\tremove_port_data(port);\n\t}\n\tremove_vqs(portdev);\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RTCPeerConnectionHandler::SetRemoteDescription(\n    const blink::WebRTCVoidRequest& request,\n    const blink::WebRTCSessionDescription& description) {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  TRACE_EVENT0(\"webrtc\", \"RTCPeerConnectionHandler::setRemoteDescription\");\n  std::string sdp = description.Sdp().Utf8();\n  std::string type = description.GetType().Utf8();\n\n  if (peer_connection_tracker_) {\n    peer_connection_tracker_->TrackSetSessionDescription(\n        this, sdp, type, PeerConnectionTracker::SOURCE_REMOTE);\n  }\n\n  webrtc::SdpParseError error;\n  std::unique_ptr<webrtc::SessionDescriptionInterface> native_desc(\n      CreateNativeSessionDescription(sdp, type, &error));\n  if (!native_desc) {\n    std::string reason_str = \"Failed to parse SessionDescription. \";\n    reason_str.append(error.line);\n    reason_str.append(\" \");\n    reason_str.append(error.description);\n    LOG(ERROR) << reason_str;\n    request.RequestFailed(webrtc::RTCError(\n        webrtc::RTCErrorType::UNSUPPORTED_OPERATION, std::move(reason_str)));\n    if (peer_connection_tracker_) {\n      peer_connection_tracker_->TrackSessionDescriptionCallback(\n          this, PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION,\n          \"OnFailure\", reason_str);\n    }\n    return;\n  }\n\n  if (!first_remote_description_ && IsOfferOrAnswer(native_desc.get())) {\n    first_remote_description_.reset(\n        new FirstSessionDescription(native_desc.get()));\n    if (first_local_description_) {\n      ReportFirstSessionDescriptions(\n          *first_local_description_,\n          *first_remote_description_);\n    }\n  }\n\n  scoped_refptr<WebRtcSetDescriptionObserverImpl> content_observer(\n      new WebRtcSetDescriptionObserverImpl(\n          weak_factory_.GetWeakPtr(), request, peer_connection_tracker_,\n          task_runner_, PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION,\n          configuration_.sdp_semantics));\n\n  bool surface_receivers_only =\n      (configuration_.sdp_semantics == webrtc::SdpSemantics::kPlanB);\n  rtc::scoped_refptr<webrtc::SetRemoteDescriptionObserverInterface>\n      webrtc_observer(WebRtcSetRemoteDescriptionObserverHandler::Create(\n                          task_runner_, signaling_thread(),\n                          native_peer_connection_, track_adapter_map_,\n                          content_observer, surface_receivers_only)\n                          .get());\n\n  signaling_thread()->PostTask(\n      FROM_HERE,\n      base::BindOnce(\n          &RunClosureWithTrace,\n          base::Bind(\n              static_cast<void (webrtc::PeerConnectionInterface::*)(\n                  std::unique_ptr<webrtc::SessionDescriptionInterface>,\n                  rtc::scoped_refptr<\n                      webrtc::SetRemoteDescriptionObserverInterface>)>(\n                  &webrtc::PeerConnectionInterface::SetRemoteDescription),\n              native_peer_connection_, base::Passed(&native_desc),\n              webrtc_observer),\n          \"SetRemoteDescription\"));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void rfcomm_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted dlcs */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\trfcomm_sock_close(sk);\n\t\trfcomm_sock_kill(sk);\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "NTSTATUS ProbeRealDriveSize (PDEVICE_OBJECT driveDeviceObject, LARGE_INTEGER *driveSize)\n{\n\tNTSTATUS status;\n\tLARGE_INTEGER sysLength;\n\tLARGE_INTEGER offset;\n\tbyte *sectorBuffer;\n\tULONGLONG startTime;\n\n\tif (!UserCanAccessDriveDevice())\n\t\treturn STATUS_ACCESS_DENIED;\n\n\tsectorBuffer = TCalloc (TC_SECTOR_SIZE_BIOS);\n\tif (!sectorBuffer)\n\t\treturn STATUS_INSUFFICIENT_RESOURCES;\n\n\tstatus = SendDeviceIoControlRequest (driveDeviceObject, IOCTL_DISK_GET_LENGTH_INFO,\n\t\tNULL, 0, &sysLength, sizeof (sysLength));\n\n\tif (!NT_SUCCESS (status))\n\t{\n\t\tDump (\"Failed to get drive size - error %x\\n\", status);\n\t\tTCfree (sectorBuffer);\n\t\treturn status;\n\t}\n\n\tstartTime = KeQueryInterruptTime ();\n\tfor (offset.QuadPart = sysLength.QuadPart; ; offset.QuadPart += TC_SECTOR_SIZE_BIOS)\n\t{\n\t\tstatus = TCReadDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);\n\n\t\tif (NT_SUCCESS (status))\n\t\t\tstatus = TCWriteDevice (driveDeviceObject, sectorBuffer, offset, TC_SECTOR_SIZE_BIOS);\n\n\t\tif (!NT_SUCCESS (status))\n\t\t{\n\t\t\tdriveSize->QuadPart = offset.QuadPart;\n\t\t\tDump (\"Real drive size = %I64d bytes (%I64d hidden)\\n\", driveSize->QuadPart, driveSize->QuadPart - sysLength.QuadPart);\n\t\t\tTCfree (sectorBuffer);\n\t\t\treturn STATUS_SUCCESS;\n\t\t}\n\n\t\tif (KeQueryInterruptTime() - startTime > 3ULL * 60 * 1000 * 1000 * 10)\n\t\t{\n\t\t\tdriveSize->QuadPart = sysLength.QuadPart;\n\t\t\tTCfree (sectorBuffer);\n\t\t\treturn STATUS_TIMEOUT;\n\t\t}\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "VideoCaptureManager::~VideoCaptureManager() {\n  DCHECK(controllers_.empty());\n   DCHECK(device_start_request_queue_.empty());\n   if (screenlock_monitor_) {\n     screenlock_monitor_->RemoveObserver(this);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void SyncTest::AddOptionalTypesToCommandLine(CommandLine* cl) {\n  if (!cl->HasSwitch(switches::kEnableSyncTabs))\n    cl->AppendSwitch(switches::kEnableSyncTabs);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "AudioOutputDevice::AudioOutputDevice(\n    AudioOutputIPC* ipc,\n    const scoped_refptr<base::MessageLoopProxy>& io_loop)\n    : ScopedLoopObserver(io_loop),\n      input_channels_(0),\n      callback_(NULL),\n       ipc_(ipc),\n       stream_id_(0),\n       play_on_start_(true),\n      is_started_(false),\n      audio_thread_(new AudioDeviceThread()) {\n   CHECK(ipc_);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n {\n     if (dir_path) {\n         v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n         v9fs_path_sprintf(target, \"%s\", name);\n     }\n     return 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-732"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "jas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)\n {\n \tjas_matrix_t *y;\n\tint i;\n\tint j;\n \ty = jas_seq2d_create(jas_seq2d_xstart(x), jas_seq2d_ystart(x),\n \t  jas_seq2d_xend(x), jas_seq2d_yend(x));\n \tassert(y);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\t\t\t   size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tint ret = 0;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\t/* once we're in the cl_nodes tree networking can look us up by\n\t * node number and try to use our address and port attributes\n\t * to connect to this node.. make sure that they've been set\n\t * before writing the node attribute? */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (cluster->cl_nodes[tmp])\n \t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n \t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n \tif (ret)\n \t\treturn ret;\n \n\treturn count;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MagickExport ChannelStatistics *GetImageStatistics(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  double\n    area,\n    *histogram,\n    standard_deviation;\n\n  MagickStatusType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*\n    sizeof(*histogram));\n  channel_statistics=(ChannelStatistics *) AcquireQuantumMemory(\n    MaxPixelChannels+1,sizeof(*channel_statistics));\n  if ((channel_statistics == (ChannelStatistics *) NULL) ||\n      (histogram == (double *) NULL))\n    {\n      if (histogram != (double *) NULL)\n        histogram=(double *) RelinquishMagickMemory(histogram);\n      if (channel_statistics != (ChannelStatistics *) NULL)\n        channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n          channel_statistics);\n      return(channel_statistics);\n    }\n  (void) memset(channel_statistics,0,(MaxPixelChannels+1)*\n    sizeof(*channel_statistics));\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    channel_statistics[i].depth=1;\n    channel_statistics[i].maxima=(-MagickMaximumValue);\n    channel_statistics[i].minima=MagickMaximumValue;\n  }\n  (void) memset(histogram,0,(MaxMap+1)*GetPixelChannels(image)*\n    sizeof(*histogram));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute pixel statistics.\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) <= (QuantumRange/2))\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (channel_statistics[channel].depth != MAGICKCORE_QUANTUM_DEPTH)\n          {\n            depth=channel_statistics[channel].depth;\n            range=GetQuantumRange(depth);\n            status=p[i] != ScaleAnyToQuantum(ScaleQuantumToAny(p[i],range),\n              range) ? MagickTrue : MagickFalse;\n            if (status != MagickFalse)\n              {\n                channel_statistics[channel].depth++;\n                i--;\n                continue;\n              }\n          }\n        if ((double) p[i] < channel_statistics[channel].minima)\n          channel_statistics[channel].minima=(double) p[i];\n        if ((double) p[i] > channel_statistics[channel].maxima)\n          channel_statistics[channel].maxima=(double) p[i];\n        channel_statistics[channel].sum+=p[i];\n        channel_statistics[channel].sum_squared+=(double) p[i]*p[i];\n        channel_statistics[channel].sum_cubed+=(double) p[i]*p[i]*p[i];\n        channel_statistics[channel].sum_fourth_power+=(double) p[i]*p[i]*p[i]*\n          p[i];\n        channel_statistics[channel].area++;\n        if ((double) p[i] < channel_statistics[CompositePixelChannel].minima)\n          channel_statistics[CompositePixelChannel].minima=(double) p[i];\n        if ((double) p[i] > channel_statistics[CompositePixelChannel].maxima)\n          channel_statistics[CompositePixelChannel].maxima=(double) p[i];\n        histogram[GetPixelChannels(image)*ScaleQuantumToMap(\n          ClampToQuantum((double) p[i]))+i]++;\n        channel_statistics[CompositePixelChannel].sum+=(double) p[i];\n        channel_statistics[CompositePixelChannel].sum_squared+=(double)\n          p[i]*p[i];\n        channel_statistics[CompositePixelChannel].sum_cubed+=(double)\n          p[i]*p[i]*p[i];\n        channel_statistics[CompositePixelChannel].sum_fourth_power+=(double)\n          p[i]*p[i]*p[i]*p[i];\n        channel_statistics[CompositePixelChannel].area++;\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    /*\n      Normalize pixel statistics.\n    */\n    area=PerceptibleReciprocal(channel_statistics[i].area);\n    channel_statistics[i].sum*=area;\n    channel_statistics[i].sum_squared*=area;\n    channel_statistics[i].sum_cubed*=area;\n    channel_statistics[i].sum_fourth_power*=area;\n    channel_statistics[i].mean=channel_statistics[i].sum;\n    channel_statistics[i].variance=channel_statistics[i].sum_squared;\n    standard_deviation=sqrt(channel_statistics[i].variance-\n      (channel_statistics[i].mean*channel_statistics[i].mean));\n    standard_deviation=sqrt(PerceptibleReciprocal(channel_statistics[i].area-\n      1.0)*channel_statistics[i].area*standard_deviation*standard_deviation);\n    channel_statistics[i].standard_deviation=standard_deviation;\n  }\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    double\n      number_bins;\n\n    register ssize_t\n      j;\n\n    /*\n      Compute pixel entropy.\n    */\n    PixelChannel channel = GetPixelChannelChannel(image,i);\n    number_bins=0.0;\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n      if (histogram[GetPixelChannels(image)*j+i] > 0.0)\n        number_bins++;\n    area=PerceptibleReciprocal(channel_statistics[channel].area);\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n    {\n      double\n        count;\n\n      count=area*histogram[GetPixelChannels(image)*j+i];\n      channel_statistics[channel].entropy+=-count*MagickLog10(count)*\n        PerceptibleReciprocal(MagickLog10(number_bins));\n      channel_statistics[CompositePixelChannel].entropy+=-count*\n        MagickLog10(count)*PerceptibleReciprocal(MagickLog10(number_bins))/\n        GetPixelChannels(image);\n    }\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    /*\n      Compute kurtosis & skewness statistics.\n    */\n    standard_deviation=PerceptibleReciprocal(\n      channel_statistics[i].standard_deviation);\n    channel_statistics[i].skewness=(channel_statistics[i].sum_cubed-3.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_squared+2.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation);\n    channel_statistics[i].kurtosis=(channel_statistics[i].sum_fourth_power-4.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_cubed+6.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].sum_squared-3.0*channel_statistics[i].mean*\n      channel_statistics[i].mean*1.0*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation*standard_deviation)-3.0;\n  }\n  channel_statistics[CompositePixelChannel].mean=0.0;\n  channel_statistics[CompositePixelChannel].standard_deviation=0.0;\n  channel_statistics[CompositePixelChannel].entropy=0.0;\n  for (i=0; i < (ssize_t) MaxPixelChannels; i++)\n  {\n    channel_statistics[CompositePixelChannel].mean+=\n      channel_statistics[i].mean;\n    channel_statistics[CompositePixelChannel].standard_deviation+=\n      channel_statistics[i].standard_deviation;\n    channel_statistics[CompositePixelChannel].entropy+=\n      channel_statistics[i].entropy;\n  }\n  channel_statistics[CompositePixelChannel].mean/=(double)\n    GetImageChannels(image);\n  channel_statistics[CompositePixelChannel].standard_deviation/=(double)\n    GetImageChannels(image);\n  channel_statistics[CompositePixelChannel].entropy/=(double)\n    GetImageChannels(image);\n  if (y < (ssize_t) image->rows)\n    channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n      channel_statistics);\n  return(channel_statistics);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval,\n   jas_seqent_t maxval)\n {\n\tint i;\n\tint j;\n \tjas_seqent_t v;\n \tjas_seqent_t *rowstart;\n \tjas_seqent_t *data;\n\tint rowstep;\n \n \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n \t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tdata = rowstart;\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\tv = *data;\n\t\t\t\tif (v < minval) {\n\t\t\t\t\t*data = minval;\n\t\t\t\t} else if (v > maxval) {\n\t\t\t\t\t*data = maxval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GfxImageColorMap::getRGBLine(Guchar *in, unsigned int *out, int length) {\n  int i, j;\n  Guchar *inp, *tmp_line;\n\n   switch (colorSpace->getMode()) {\n   case csIndexed:\n   case csSeparation:\n    tmp_line = (Guchar *) gmalloc (length * nComps2);\n     for (i = 0; i < length; i++) {\n       for (j = 0; j < nComps2; j++) {\n \ttmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];\n      }\n    }\n    colorSpace2->getRGBLine(tmp_line, out, length);\n    gfree (tmp_line);\n    break;\n\n  default:\n    inp = in;\n    for (j = 0; j < length; j++)\n      for (i = 0; i < nComps; i++) {\n\t*inp = byte_lookup[*inp * nComps + i];\n\tinp++;\n      }\n    colorSpace->getRGBLine(in, out, length);\n    break;\n  }\n\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void WebContentsImpl::RunJavaScriptDialog(RenderFrameHost* render_frame_host,\n                                          const base::string16& message,\n                                          const base::string16& default_prompt,\n                                           const GURL& frame_url,\n                                           JavaScriptDialogType dialog_type,\n                                           IPC::Message* reply_msg) {\n  bool suppress_this_message =\n      ShowingInterstitialPage() || !delegate_ ||\n      delegate_->ShouldSuppressDialogs(this) ||\n      !delegate_->GetJavaScriptDialogManager(this);\n\n  if (!suppress_this_message) {\n    is_showing_javascript_dialog_ = true;\n    dialog_manager_ = delegate_->GetJavaScriptDialogManager(this);\n    dialog_manager_->RunJavaScriptDialog(\n        this, frame_url, dialog_type, message, default_prompt,\n        base::Bind(&WebContentsImpl::OnDialogClosed, base::Unretained(this),\n                   render_frame_host->GetProcess()->GetID(),\n                   render_frame_host->GetRoutingID(), reply_msg, false),\n        &suppress_this_message);\n  }\n\n  if (suppress_this_message) {\n    OnDialogClosed(render_frame_host->GetProcess()->GetID(),\n                   render_frame_host->GetRoutingID(), reply_msg,\n                   true, false, base::string16());\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "_PUBLIC_ bool strhasupper_handle(struct smb_iconv_handle *ic,\n\t\t\t\t const char *string)\n{\n\twhile (*string) {\n\t\tsize_t c_size;\n\t\tcodepoint_t s;\n\t\tcodepoint_t t;\n\n\t\ts = next_codepoint_handle(ic, string, &c_size);\n\t\tstring += c_size;\n\n\t\tt = tolower_m(s);\n\n\t\tif (s != t) {\n\t\t\treturn true; /* that means it has upper case chars */\n\t\t}\n\t}\n\n\treturn false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void  Ins_JMPR( INS_ARG )\n   {\n     CUR.IP      += (Int)(args[0]);\n     CUR.step_ins = FALSE;\n     * allow for simple cases here by just checking the preceding byte.\n     * Fonts with this problem are not uncommon.\n     */\n      CUR.IP -= 1;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PreconnectRequest::PreconnectRequest(\n    const GURL& origin,\n     int num_sockets,\n     const net::NetworkIsolationKey& network_isolation_key)\n     : origin(origin),\n      num_sockets(num_sockets),\n      network_isolation_key(network_isolation_key) {\n  DCHECK_GE(num_sockets, 0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int uas_switch_interface(struct usb_device *udev,\n \t\t\t\tstruct usb_interface *intf)\n {\n\tint alt;\n \n \talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n \n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BrowserViewRenderer::SetTotalRootLayerScrollOffset(\n    gfx::Vector2dF scroll_offset_dip) {\n   if (scroll_offset_dip_ == scroll_offset_dip)\n     return;\n   scroll_offset_dip_ = scroll_offset_dip;\n\n  gfx::Vector2d max_offset = max_scroll_offset();\n  gfx::Vector2d scroll_offset;\n  if (max_scroll_offset_dip_.x()) {\n    scroll_offset.set_x((scroll_offset_dip.x() * max_offset.x()) /\n                        max_scroll_offset_dip_.x());\n  }\n\n  if (max_scroll_offset_dip_.y()) {\n    scroll_offset.set_y((scroll_offset_dip.y() * max_offset.y()) /\n                        max_scroll_offset_dip_.y());\n  }\n\n  DCHECK_LE(0, scroll_offset.x());\n  DCHECK_LE(0, scroll_offset.y());\n  DCHECK_LE(scroll_offset.x(), max_offset.x());\n  DCHECK_LE(scroll_offset.y(), max_offset.y());\n\n  client_->ScrollContainerViewTo(scroll_offset);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n \tND_PRINT((ndo,\" len=%d\", item_len - 4));\n \tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n \tif (2 < ndo->ndo_vflag && 4 < item_len) {\n \t\tND_PRINT((ndo,\" \"));\n \t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n \t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "DWORD WtsSessionProcessDelegate::Core::GetExitCode() {\n  DCHECK(main_task_runner_->BelongsToCurrentThread());\n \n   DWORD exit_code = CONTROL_C_EXIT;\n   if (worker_process_.IsValid()) {\n     if (!::GetExitCodeProcess(worker_process_, &exit_code)) {\n      LOG_GETLASTERROR(INFO)\n          << \"Failed to query the exit code of the worker process\";\n      exit_code = CONTROL_C_EXIT;\n     }\n   }\n \n  return exit_code;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "DictionaryValue* ExtensionTabUtil::CreateTabValue(\n    const WebContents* contents,\n     TabStripModel* tab_strip,\n     int tab_index,\n     const Extension* extension) {\n  bool has_permission = extension && extension->HasAPIPermissionForTab(\n      GetTabId(contents), APIPermission::kTab);\n  return CreateTabValue(contents, tab_strip, tab_index,\n                        has_permission ? INCLUDE_PRIVACY_SENSITIVE_FIELDS :\n                            OMIT_PRIVACY_SENSITIVE_FIELDS);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void PeopleHandler::FocusUI() {\n  WebContents* web_contents = web_ui()->GetWebContents();\n  web_contents->GetDelegate()->ActivateContents(web_contents);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n \t  lzx->intel_started = 1;\n \n \t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  ENSURE_BITS(16);\n\t  if (bits_left > 16) i_ptr -= 2;\n \t  bits_left = 0; bit_buffer = 0;\n \n \t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OMX_ERRORTYPE  omx_venc::set_parameter(OMX_IN OMX_HANDLETYPE     hComp,\n        OMX_IN OMX_INDEXTYPE paramIndex,\n        OMX_IN OMX_PTR        paramData)\n{\n (void)hComp;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n\n\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"ERROR: Set Param in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n if (paramData == NULL) {\n        DEBUG_PRINT_ERROR(\"ERROR: Get Param in Invalid paramData\");\n return OMX_ErrorBadParameter;\n }\n\n /*set_parameter can be called in loaded state\n      or disabled port */\n if (m_state == OMX_StateLoaded\n || m_sInPortDef.bEnabled == OMX_FALSE\n || m_sOutPortDef.bEnabled == OMX_FALSE) {\n        DEBUG_PRINT_LOW(\"Set Parameter called in valid state\");\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: Set Parameter called in Invalid State\");\n return OMX_ErrorIncorrectStateOperation;\n }\n\n switch ((int)paramIndex) {\n case OMX_IndexParamPortDefinition:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_PARAM_PORTDEFINITIONTYPE);\n                OMX_PARAM_PORTDEFINITIONTYPE *portDefn;\n                portDefn = (OMX_PARAM_PORTDEFINITIONTYPE *) paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamPortDefinition H= %d, W = %d\",\n (int)portDefn->format.video.nFrameHeight,\n (int)portDefn->format.video.nFrameWidth);\n\n if (PORT_INDEX_IN == portDefn->nPortIndex) {\n if (!dev_is_video_session_supported(portDefn->format.video.nFrameWidth,\n                                portDefn->format.video.nFrameHeight)) {\n                        DEBUG_PRINT_ERROR(\"video session not supported\");\n                        omx_report_unsupported_setting();\n return OMX_ErrorUnsupportedSetting;\n }\n\n                     DEBUG_PRINT_LOW(\"i/p actual cnt requested = %u\", (unsigned int)portDefn->nBufferCountActual);\n                     DEBUG_PRINT_LOW(\"i/p min cnt requested = %u\", (unsigned int)portDefn->nBufferCountMin);\n                     DEBUG_PRINT_LOW(\"i/p buffersize requested = %u\", (unsigned int)portDefn->nBufferSize);\n                     if (portDefn->nBufferCountMin > portDefn->nBufferCountActual) {\n                         DEBUG_PRINT_ERROR(\"ERROR: (In_PORT) Min buffers (%u) > actual count (%u)\",\n                                 (unsigned int)portDefn->nBufferCountMin, (unsigned int)portDefn->nBufferCountActual);\n return OMX_ErrorUnsupportedSetting;\n }\n if (handle->venc_set_param(paramData,OMX_IndexParamPortDefinition) != true) {\n                        DEBUG_PRINT_ERROR(\"ERROR: venc_set_param input failed\");\n return handle->hw_overload ? OMX_ErrorInsufficientResources :\n                                OMX_ErrorUnsupportedSetting;\n }\n\n                    DEBUG_PRINT_LOW(\"i/p previous actual cnt = %u\", (unsigned int)m_sInPortDef.nBufferCountActual);\n                    DEBUG_PRINT_LOW(\"i/p previous min cnt = %u\", (unsigned int)m_sInPortDef.nBufferCountMin);\n                    memcpy(&m_sInPortDef, portDefn,sizeof(OMX_PARAM_PORTDEFINITIONTYPE));\n\n#ifdef _ANDROID_ICS_\n if (portDefn->format.video.eColorFormat ==\n (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatAndroidOpaque) {\n                        m_sInPortDef.format.video.eColorFormat = (OMX_COLOR_FORMATTYPE)\n                            QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;\n if (!mUseProxyColorFormat) {\n if (!c2d_conv.init()) {\n                                DEBUG_PRINT_ERROR(\"C2D init failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                            DEBUG_PRINT_HIGH(\"C2D init is successful\");\n }\n                        mUseProxyColorFormat = true;\n                        m_input_msg_id = OMX_COMPONENT_GENERATE_ETB_OPQ;\n } else\n                        mUseProxyColorFormat = false;\n#endif\n /*Query Input Buffer Requirements*/\n                    dev_get_buf_req   (&m_sInPortDef.nBufferCountMin,\n &m_sInPortDef.nBufferCountActual,\n &m_sInPortDef.nBufferSize,\n                            m_sInPortDef.nPortIndex);\n\n /*Query ouput Buffer Requirements*/\n                    dev_get_buf_req   (&m_sOutPortDef.nBufferCountMin,\n &m_sOutPortDef.nBufferCountActual,\n &m_sOutPortDef.nBufferSize,\n                            m_sOutPortDef.nPortIndex);\n                    m_sInPortDef.nBufferCountActual = portDefn->nBufferCountActual;\n } else if (PORT_INDEX_OUT == portDefn->nPortIndex) {\n\n                     DEBUG_PRINT_LOW(\"o/p actual cnt requested = %u\", (unsigned int)portDefn->nBufferCountActual);\n                     DEBUG_PRINT_LOW(\"o/p min cnt requested = %u\", (unsigned int)portDefn->nBufferCountMin);\n                     DEBUG_PRINT_LOW(\"o/p buffersize requested = %u\", (unsigned int)portDefn->nBufferSize);\n                     if (portDefn->nBufferCountMin > portDefn->nBufferCountActual) {\n                         DEBUG_PRINT_ERROR(\"ERROR: (Out_PORT) Min buffers (%u) > actual count (%u)\",\n                                 (unsigned int)portDefn->nBufferCountMin, (unsigned int)portDefn->nBufferCountActual);\n return OMX_ErrorUnsupportedSetting;\n }\n if (handle->venc_set_param(paramData,OMX_IndexParamPortDefinition) != true) {\n                        DEBUG_PRINT_ERROR(\"ERROR: venc_set_param output failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n#ifdef _MSM8974_\n /*Query ouput Buffer Requirements*/\n                    dev_get_buf_req(&m_sOutPortDef.nBufferCountMin,\n &m_sOutPortDef.nBufferCountActual,\n &m_sOutPortDef.nBufferSize,\n                            m_sOutPortDef.nPortIndex);\n#endif\n                    memcpy(&m_sOutPortDef,portDefn,sizeof(struct OMX_PARAM_PORTDEFINITIONTYPE));\n                    update_profile_level(); //framerate , bitrate\n\n                    DEBUG_PRINT_LOW(\"o/p previous actual cnt = %u\", (unsigned int)m_sOutPortDef.nBufferCountActual);\n                    DEBUG_PRINT_LOW(\"o/p previous min cnt = %u\", (unsigned int)m_sOutPortDef.nBufferCountMin);\n                    m_sOutPortDef.nBufferCountActual = portDefn->nBufferCountActual;\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: Set_parameter: Bad Port idx %d\",\n (int)portDefn->nPortIndex);\n                    eRet = OMX_ErrorBadPortIndex;\n }\n                m_sConfigFramerate.xEncodeFramerate = portDefn->format.video.xFramerate;\n                m_sConfigBitrate.nEncodeBitrate = portDefn->format.video.nBitrate;\n                m_sParamBitrate.nTargetBitrate = portDefn->format.video.nBitrate;\n }\n break;\n\n case OMX_IndexParamVideoPortFormat:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_PORTFORMATTYPE);\n                OMX_VIDEO_PARAM_PORTFORMATTYPE *portFmt =\n (OMX_VIDEO_PARAM_PORTFORMATTYPE *)paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoPortFormat %d\",\n                        portFmt->eColorFormat);\n if (PORT_INDEX_IN == portFmt->nPortIndex) {\n if (handle->venc_set_param(paramData,OMX_IndexParamVideoPortFormat) != true) {\n return OMX_ErrorUnsupportedSetting;\n }\n\n                    DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoPortFormat %d\",\n                            portFmt->eColorFormat);\n                    update_profile_level(); //framerate\n\n#ifdef _ANDROID_ICS_\n if (portFmt->eColorFormat ==\n (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatAndroidOpaque) {\n                        m_sInPortFormat.eColorFormat = (OMX_COLOR_FORMATTYPE)\n                            QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;\n if (!mUseProxyColorFormat) {\n if (!c2d_conv.init()) {\n                                DEBUG_PRINT_ERROR(\"C2D init failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                            DEBUG_PRINT_HIGH(\"C2D init is successful\");\n }\n                        mUseProxyColorFormat = true;\n                        m_input_msg_id = OMX_COMPONENT_GENERATE_ETB_OPQ;\n } else\n#endif\n {\n                        m_sInPortFormat.eColorFormat = portFmt->eColorFormat;\n                        m_sInPortDef.format.video.eColorFormat = portFmt->eColorFormat;\n                        m_input_msg_id = OMX_COMPONENT_GENERATE_ETB;\n                        mUseProxyColorFormat = false;\n }\n                    m_sInPortFormat.xFramerate = portFmt->xFramerate;\n }\n }\n break;\n case OMX_IndexParamVideoInit:\n { //TODO, do we need this index set param\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_PORT_PARAM_TYPE);\n                OMX_PORT_PARAM_TYPE* pParam = (OMX_PORT_PARAM_TYPE*)(paramData);\n                DEBUG_PRINT_LOW(\"Set OMX_IndexParamVideoInit called\");\n break;\n }\n\n case OMX_IndexParamVideoBitrate:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_BITRATETYPE);\n                OMX_VIDEO_PARAM_BITRATETYPE* pParam = (OMX_VIDEO_PARAM_BITRATETYPE*)paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoBitrate\");\n if (handle->venc_set_param(paramData,OMX_IndexParamVideoBitrate) != true) {\n return OMX_ErrorUnsupportedSetting;\n }\n                m_sParamBitrate.nTargetBitrate = pParam->nTargetBitrate;\n                m_sParamBitrate.eControlRate = pParam->eControlRate;\n                update_profile_level(); //bitrate\n                m_sConfigBitrate.nEncodeBitrate = pParam->nTargetBitrate;\n                m_sInPortDef.format.video.nBitrate = pParam->nTargetBitrate;\n                m_sOutPortDef.format.video.nBitrate = pParam->nTargetBitrate;\n                DEBUG_PRINT_LOW(\"bitrate = %u\", (unsigned int)m_sOutPortDef.format.video.nBitrate);\n break;\n }\n case OMX_IndexParamVideoMpeg4:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_MPEG4TYPE);\n                OMX_VIDEO_PARAM_MPEG4TYPE* pParam = (OMX_VIDEO_PARAM_MPEG4TYPE*)paramData;\n                OMX_VIDEO_PARAM_MPEG4TYPE mp4_param;\n                memcpy(&mp4_param, pParam, sizeof(struct OMX_VIDEO_PARAM_MPEG4TYPE));\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoMpeg4\");\n if (pParam->eProfile == OMX_VIDEO_MPEG4ProfileAdvancedSimple) {\n#ifdef MAX_RES_1080P\n if (pParam->nBFrames) {\n                        DEBUG_PRINT_HIGH(\"INFO: Only 1 Bframe is supported\");\n                        mp4_param.nBFrames = 1;\n }\n#else\n if (pParam->nBFrames) {\n                        DEBUG_PRINT_ERROR(\"Warning: B frames not supported\");\n                        mp4_param.nBFrames = 0;\n }\n#endif\n#ifdef _MSM8974_\n if (pParam->nBFrames || bframes)\n                        mp4_param.nBFrames = (pParam->nBFrames > (unsigned int) bframes)? pParam->nBFrames : bframes;\n                    DEBUG_PRINT_HIGH(\"MPEG4: %u BFrames are being set\", (unsigned int)mp4_param.nBFrames);\n#endif\n\n } else {\n if (pParam->nBFrames) {\n                        DEBUG_PRINT_ERROR(\"Warning: B frames not supported\");\n                        mp4_param.nBFrames = 0;\n }\n }\n if (handle->venc_set_param(&mp4_param,OMX_IndexParamVideoMpeg4) != true) {\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sParamMPEG4,pParam, sizeof(struct OMX_VIDEO_PARAM_MPEG4TYPE));\n                m_sIntraperiod.nPFrames = m_sParamMPEG4.nPFrames;\n if (pParam->nBFrames || bframes)\n                    m_sIntraperiod.nBFrames = m_sParamMPEG4.nBFrames = mp4_param.nBFrames;\n else\n                m_sIntraperiod.nBFrames = m_sParamMPEG4.nBFrames;\n break;\n }\n case OMX_IndexParamVideoH263:\n {\n                OMX_VIDEO_PARAM_H263TYPE* pParam = (OMX_VIDEO_PARAM_H263TYPE*)paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoH263\");\n if (handle->venc_set_param(paramData,OMX_IndexParamVideoH263) != true) {\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sParamH263,pParam, sizeof(struct OMX_VIDEO_PARAM_H263TYPE));\n                m_sIntraperiod.nPFrames = m_sParamH263.nPFrames;\n                m_sIntraperiod.nBFrames = m_sParamH263.nBFrames;\n break;\n }\n case OMX_IndexParamVideoAvc:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_AVCTYPE);\n                OMX_VIDEO_PARAM_AVCTYPE* pParam = (OMX_VIDEO_PARAM_AVCTYPE*)paramData;\n                OMX_VIDEO_PARAM_AVCTYPE avc_param;\n                memcpy(&avc_param, pParam, sizeof( struct OMX_VIDEO_PARAM_AVCTYPE));\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoAvc\");\n\n if ((pParam->eProfile == OMX_VIDEO_AVCProfileHigh)||\n (pParam->eProfile == OMX_VIDEO_AVCProfileMain)) {\n#ifdef MAX_RES_1080P\n if (pParam->nBFrames) {\n                        DEBUG_PRINT_HIGH(\"INFO: Only 1 Bframe is supported\");\n                        avc_param.nBFrames = 1;\n }\n if (pParam->nRefFrames != 2) {\n                        DEBUG_PRINT_ERROR(\"Warning: 2 RefFrames are needed, changing RefFrames from %u to 2\", (unsigned int)pParam->nRefFrames);\n                        avc_param.nRefFrames = 2;\n }\n#else\n if (pParam->nBFrames) {\n                        DEBUG_PRINT_ERROR(\"Warning: B frames not supported\");\n                        avc_param.nBFrames = 0;\n }\n if (pParam->nRefFrames != 1) {\n                        DEBUG_PRINT_ERROR(\"Warning: Only 1 RefFrame is supported, changing RefFrame from %u to 1)\", (unsigned int)pParam->nRefFrames);\n                        avc_param.nRefFrames = 1;\n }\n#endif\n#ifdef _MSM8974_\n if (pParam->nBFrames || bframes) {\n                        avc_param.nBFrames = (pParam->nBFrames > (unsigned int) bframes)? pParam->nBFrames : bframes;\n                        avc_param.nRefFrames = (avc_param.nBFrames < 4)? avc_param.nBFrames + 1 : 4;\n }\n                    DEBUG_PRINT_HIGH(\"AVC: RefFrames: %u, BFrames: %u\", (unsigned int)avc_param.nRefFrames, (unsigned int)avc_param.nBFrames);\n\n                    avc_param.bEntropyCodingCABAC = (OMX_BOOL)(avc_param.bEntropyCodingCABAC && entropy);\n                    avc_param.nCabacInitIdc = entropy ? avc_param.nCabacInitIdc : 0;\n#endif\n } else {\n if (pParam->nRefFrames != 1) {\n                        DEBUG_PRINT_ERROR(\"Warning: Only 1 RefFrame is supported, changing RefFrame from %u to 1)\", (unsigned int)pParam->nRefFrames);\n                        avc_param.nRefFrames = 1;\n }\n if (pParam->nBFrames) {\n                        DEBUG_PRINT_ERROR(\"Warning: B frames not supported\");\n                        avc_param.nBFrames = 0;\n }\n }\n if (handle->venc_set_param(&avc_param,OMX_IndexParamVideoAvc) != true) {\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sParamAVC,pParam, sizeof(struct OMX_VIDEO_PARAM_AVCTYPE));\n                m_sIntraperiod.nPFrames = m_sParamAVC.nPFrames;\n if (pParam->nBFrames || bframes)\n                    m_sIntraperiod.nBFrames = m_sParamAVC.nBFrames = avc_param.nBFrames;\n else\n                m_sIntraperiod.nBFrames = m_sParamAVC.nBFrames;\n break;\n }\n case (OMX_INDEXTYPE)OMX_IndexParamVideoVp8:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_VP8TYPE);\n                OMX_VIDEO_PARAM_VP8TYPE* pParam = (OMX_VIDEO_PARAM_VP8TYPE*)paramData;\n                OMX_VIDEO_PARAM_VP8TYPE vp8_param;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoVp8\");\n if (pParam->nDCTPartitions != m_sParamVP8.nDCTPartitions ||\n                    pParam->bErrorResilientMode != m_sParamVP8.bErrorResilientMode) {\n                    DEBUG_PRINT_ERROR(\"VP8 doesn't support nDCTPartitions or bErrorResilientMode\");\n }\n                memcpy(&vp8_param, pParam, sizeof( struct OMX_VIDEO_PARAM_VP8TYPE));\n if (handle->venc_set_param(&vp8_param, (OMX_INDEXTYPE)OMX_IndexParamVideoVp8) != true) {\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sParamVP8,pParam, sizeof(struct OMX_VIDEO_PARAM_VP8TYPE));\n break;\n }\n case (OMX_INDEXTYPE)OMX_IndexParamVideoHevc:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_HEVCTYPE);\n                OMX_VIDEO_PARAM_HEVCTYPE* pParam = (OMX_VIDEO_PARAM_HEVCTYPE*)paramData;\n                OMX_VIDEO_PARAM_HEVCTYPE hevc_param;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoHevc\");\n                memcpy(&hevc_param, pParam, sizeof( struct OMX_VIDEO_PARAM_HEVCTYPE));\n if (handle->venc_set_param(&hevc_param, (OMX_INDEXTYPE)OMX_IndexParamVideoHevc) != true) {\n                    DEBUG_PRINT_ERROR(\"Failed : set_parameter: OMX_IndexParamVideoHevc\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sParamHEVC, pParam, sizeof(struct OMX_VIDEO_PARAM_HEVCTYPE));\n break;\n }\n case OMX_IndexParamVideoProfileLevelCurrent:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_PROFILELEVELTYPE);\n                OMX_VIDEO_PARAM_PROFILELEVELTYPE* pParam = (OMX_VIDEO_PARAM_PROFILELEVELTYPE*)paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoProfileLevelCurrent\");\n if (handle->venc_set_param(pParam,OMX_IndexParamVideoProfileLevelCurrent) != true) {\n                    DEBUG_PRINT_ERROR(\"set_parameter: OMX_IndexParamVideoProfileLevelCurrent failed for Profile: %u \"\n \"Level :%u\", (unsigned int)pParam->eProfile, (unsigned int)pParam->eLevel);\n return OMX_ErrorUnsupportedSetting;\n }\n                m_sParamProfileLevel.eProfile = pParam->eProfile;\n                m_sParamProfileLevel.eLevel = pParam->eLevel;\n\n if (!strncmp((char *)m_nkind, \"OMX.qcom.video.encoder.mpeg4\",\\\n                            OMX_MAX_STRINGNAME_SIZE)) {\n                    m_sParamMPEG4.eProfile = (OMX_VIDEO_MPEG4PROFILETYPE)m_sParamProfileLevel.eProfile;\n                    m_sParamMPEG4.eLevel = (OMX_VIDEO_MPEG4LEVELTYPE)m_sParamProfileLevel.eLevel;\n                    DEBUG_PRINT_LOW(\"MPEG4 profile = %d, level = %d\", m_sParamMPEG4.eProfile,\n                            m_sParamMPEG4.eLevel);\n } else if (!strncmp((char *)m_nkind, \"OMX.qcom.video.encoder.h263\",\\\n                            OMX_MAX_STRINGNAME_SIZE)) {\n                    m_sParamH263.eProfile = (OMX_VIDEO_H263PROFILETYPE)m_sParamProfileLevel.eProfile;\n                    m_sParamH263.eLevel = (OMX_VIDEO_H263LEVELTYPE)m_sParamProfileLevel.eLevel;\n                    DEBUG_PRINT_LOW(\"H263 profile = %d, level = %d\", m_sParamH263.eProfile,\n                            m_sParamH263.eLevel);\n } else if (!strncmp((char *)m_nkind, \"OMX.qcom.video.encoder.avc\",\\\n                            OMX_MAX_STRINGNAME_SIZE)) {\n                    m_sParamAVC.eProfile = (OMX_VIDEO_AVCPROFILETYPE)m_sParamProfileLevel.eProfile;\n                    m_sParamAVC.eLevel = (OMX_VIDEO_AVCLEVELTYPE)m_sParamProfileLevel.eLevel;\n                    DEBUG_PRINT_LOW(\"AVC profile = %d, level = %d\", m_sParamAVC.eProfile,\n                            m_sParamAVC.eLevel);\n } else if (!strncmp((char *)m_nkind, \"OMX.qcom.video.encoder.avc.secure\",\\\n                            OMX_MAX_STRINGNAME_SIZE)) {\n                    m_sParamAVC.eProfile = (OMX_VIDEO_AVCPROFILETYPE)m_sParamProfileLevel.eProfile;\n                    m_sParamAVC.eLevel = (OMX_VIDEO_AVCLEVELTYPE)m_sParamProfileLevel.eLevel;\n                    DEBUG_PRINT_LOW(\"\\n AVC profile = %d, level = %d\", m_sParamAVC.eProfile,\n                            m_sParamAVC.eLevel);\n }\n else if (!strncmp((char*)m_nkind, \"OMX.qcom.video.encoder.vp8\",\\\n                            OMX_MAX_STRINGNAME_SIZE)) {\n                    m_sParamVP8.eProfile = (OMX_VIDEO_VP8PROFILETYPE)m_sParamProfileLevel.eProfile;\n                    m_sParamVP8.eLevel = (OMX_VIDEO_VP8LEVELTYPE)m_sParamProfileLevel.eLevel;\n                    DEBUG_PRINT_LOW(\"VP8 profile = %d, level = %d\", m_sParamVP8.eProfile,\n                            m_sParamVP8.eLevel);\n }\n else if (!strncmp((char*)m_nkind, \"OMX.qcom.video.encoder.hevc\",\\\n                            OMX_MAX_STRINGNAME_SIZE)) {\n                    m_sParamHEVC.eProfile = (OMX_VIDEO_HEVCPROFILETYPE)m_sParamProfileLevel.eProfile;\n                    m_sParamHEVC.eLevel = (OMX_VIDEO_HEVCLEVELTYPE)m_sParamProfileLevel.eLevel;\n                    DEBUG_PRINT_LOW(\"HEVC profile = %d, level = %d\", m_sParamHEVC.eProfile,\n                            m_sParamHEVC.eLevel);\n }\n\n break;\n }\n case OMX_IndexParamStandardComponentRole:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_PARAM_COMPONENTROLETYPE);\n                OMX_PARAM_COMPONENTROLETYPE *comp_role;\n                comp_role = (OMX_PARAM_COMPONENTROLETYPE *) paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamStandardComponentRole %s\",\n                        comp_role->cRole);\n\n if ((m_state == OMX_StateLoaded)&&\n !BITMASK_PRESENT(&m_flags,OMX_COMPONENT_IDLE_PENDING)) {\n                    DEBUG_PRINT_LOW(\"Set Parameter called in valid state\");\n } else {\n                    DEBUG_PRINT_ERROR(\"Set Parameter called in Invalid State\");\n return OMX_ErrorIncorrectStateOperation;\n }\n\n if (!strncmp((char*)m_nkind, \"OMX.qcom.video.encoder.avc\",OMX_MAX_STRINGNAME_SIZE)) {\n if (!strncmp((char*)comp_role->cRole,\"video_encoder.avc\",OMX_MAX_STRINGNAME_SIZE)) {\n                        strlcpy((char*)m_cRole,\"video_encoder.avc\",OMX_MAX_STRINGNAME_SIZE);\n } else {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setparameter: unknown Index %s\", comp_role->cRole);\n                        eRet =OMX_ErrorUnsupportedSetting;\n }\n } else if (!strncmp((char*)m_nkind, \"OMX.qcom.video.encoder.avc.secure\",OMX_MAX_STRINGNAME_SIZE)) {\n if (!strncmp((char*)comp_role->cRole,\"video_encoder.avc\",OMX_MAX_STRINGNAME_SIZE)) {\n                        strlcpy((char*)m_cRole,\"video_encoder.avc\",OMX_MAX_STRINGNAME_SIZE);\n } else {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setparameter: unknown Index %s\\n\", comp_role->cRole);\n                        eRet =OMX_ErrorUnsupportedSetting;\n }\n } else if (!strncmp((char*)m_nkind, \"OMX.qcom.video.encoder.mpeg4\",OMX_MAX_STRINGNAME_SIZE)) {\n if (!strncmp((const char*)comp_role->cRole,\"video_encoder.mpeg4\",OMX_MAX_STRINGNAME_SIZE)) {\n                        strlcpy((char*)m_cRole,\"video_encoder.mpeg4\",OMX_MAX_STRINGNAME_SIZE);\n } else {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setparameter: unknown Index %s\", comp_role->cRole);\n                        eRet = OMX_ErrorUnsupportedSetting;\n }\n } else if (!strncmp((char*)m_nkind, \"OMX.qcom.video.encoder.h263\",OMX_MAX_STRINGNAME_SIZE)) {\n if (!strncmp((const char*)comp_role->cRole,\"video_encoder.h263\",OMX_MAX_STRINGNAME_SIZE)) {\n                        strlcpy((char*)m_cRole,\"video_encoder.h263\",OMX_MAX_STRINGNAME_SIZE);\n } else {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setparameter: unknown Index %s\", comp_role->cRole);\n                        eRet =OMX_ErrorUnsupportedSetting;\n }\n }\n#ifdef _MSM8974_\n else if (!strncmp((char*)m_nkind, \"OMX.qcom.video.encoder.vp8\",OMX_MAX_STRINGNAME_SIZE)) {\n if (!strncmp((const char*)comp_role->cRole,\"video_encoder.vp8\",OMX_MAX_STRINGNAME_SIZE)) {\n                        strlcpy((char*)m_cRole,\"video_encoder.vp8\",OMX_MAX_STRINGNAME_SIZE);\n } else {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setparameter: unknown Index %s\", comp_role->cRole);\n                        eRet =OMX_ErrorUnsupportedSetting;\n }\n }\n#endif\n else if (!strncmp((char*)m_nkind, \"OMX.qcom.video.encoder.hevc\",OMX_MAX_STRINGNAME_SIZE)) {\n if (!strncmp((const char*)comp_role->cRole,\"video_encoder.hevc\",OMX_MAX_STRINGNAME_SIZE)) {\n                        strlcpy((char*)m_cRole,\"video_encoder.hevc\",OMX_MAX_STRINGNAME_SIZE);\n } else {\n                        DEBUG_PRINT_ERROR(\"ERROR: Setparameter: unknown Index %s\", comp_role->cRole);\n                        eRet = OMX_ErrorUnsupportedSetting;\n }\n }\n\n else {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setparameter: unknown param %s\", m_nkind);\n                    eRet = OMX_ErrorInvalidComponentName;\n }\n break;\n }\n\n case OMX_IndexParamPriorityMgmt:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_PRIORITYMGMTTYPE);\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamPriorityMgmt\");\n if (m_state != OMX_StateLoaded) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Set Parameter called in Invalid State\");\n return OMX_ErrorIncorrectStateOperation;\n }\n                OMX_PRIORITYMGMTTYPE *priorityMgmtype = (OMX_PRIORITYMGMTTYPE*) paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamPriorityMgmt %u\",\n (unsigned int)priorityMgmtype->nGroupID);\n\n                DEBUG_PRINT_LOW(\"set_parameter: priorityMgmtype %u\",\n (unsigned int)priorityMgmtype->nGroupPriority);\n\n                m_sPriorityMgmt.nGroupID = priorityMgmtype->nGroupID;\n                m_sPriorityMgmt.nGroupPriority = priorityMgmtype->nGroupPriority;\n\n break;\n }\n\n case OMX_IndexParamCompBufferSupplier:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_PARAM_BUFFERSUPPLIERTYPE);\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamCompBufferSupplier\");\n                OMX_PARAM_BUFFERSUPPLIERTYPE *bufferSupplierType = (OMX_PARAM_BUFFERSUPPLIERTYPE*) paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamCompBufferSupplier %d\",\n                        bufferSupplierType->eBufferSupplier);\n if (bufferSupplierType->nPortIndex == 0 || bufferSupplierType->nPortIndex ==1)\n                    m_sInBufSupplier.eBufferSupplier = bufferSupplierType->eBufferSupplier;\n\n else\n\n                    eRet = OMX_ErrorBadPortIndex;\n\n break;\n\n }\n case OMX_IndexParamVideoQuantization:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_QUANTIZATIONTYPE);\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_IndexParamVideoQuantization\");\n                OMX_VIDEO_PARAM_QUANTIZATIONTYPE *session_qp = (OMX_VIDEO_PARAM_QUANTIZATIONTYPE*) paramData;\n if (session_qp->nPortIndex == PORT_INDEX_OUT) {\n if (handle->venc_set_param(paramData, OMX_IndexParamVideoQuantization) != true) {\n return OMX_ErrorUnsupportedSetting;\n }\n                    m_sSessionQuantization.nQpI = session_qp->nQpI;\n                    m_sSessionQuantization.nQpP = session_qp->nQpP;\n                    m_sSessionQuantization.nQpB = session_qp->nQpB;\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: Unsupported port Index for Session QP setting\");\n                    eRet = OMX_ErrorBadPortIndex;\n }\n break;\n }\n\n case OMX_QcomIndexParamVideoQPRange:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_QPRANGETYPE);\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_QcomIndexParamVideoQPRange\");\n                OMX_QCOM_VIDEO_PARAM_QPRANGETYPE *qp_range = (OMX_QCOM_VIDEO_PARAM_QPRANGETYPE*) paramData;\n if (qp_range->nPortIndex == PORT_INDEX_OUT) {\n if (handle->venc_set_param(paramData,\n (OMX_INDEXTYPE)OMX_QcomIndexParamVideoQPRange) != true) {\n return OMX_ErrorUnsupportedSetting;\n }\n                    m_sSessionQPRange.minQP= qp_range->minQP;\n                    m_sSessionQPRange.maxQP= qp_range->maxQP;\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: Unsupported port Index for QP range setting\");\n                    eRet = OMX_ErrorBadPortIndex;\n }\n break;\n }\n\n case OMX_QcomIndexPortDefn:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_PARAM_PORTDEFINITIONTYPE);\n                OMX_QCOM_PARAM_PORTDEFINITIONTYPE* pParam =\n (OMX_QCOM_PARAM_PORTDEFINITIONTYPE*)paramData;\n                DEBUG_PRINT_LOW(\"set_parameter: OMX_QcomIndexPortDefn\");\n if (pParam->nPortIndex == (OMX_U32)PORT_INDEX_IN) {\n if (pParam->nMemRegion > OMX_QCOM_MemRegionInvalid &&\n                            pParam->nMemRegion < OMX_QCOM_MemRegionMax) {\n                        m_use_input_pmem = OMX_TRUE;\n } else {\n                        m_use_input_pmem = OMX_FALSE;\n }\n } else if (pParam->nPortIndex == (OMX_U32)PORT_INDEX_OUT) {\n if (pParam->nMemRegion > OMX_QCOM_MemRegionInvalid &&\n                            pParam->nMemRegion < OMX_QCOM_MemRegionMax) {\n                        m_use_output_pmem = OMX_TRUE;\n } else {\n                        m_use_output_pmem = OMX_FALSE;\n }\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: SetParameter called on unsupported Port Index for QcomPortDefn\");\n return OMX_ErrorBadPortIndex;\n }\n break;\n }\n\n case OMX_IndexParamVideoErrorCorrection:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE);\n                DEBUG_PRINT_LOW(\"OMX_IndexParamVideoErrorCorrection\");\n                OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE* pParam =\n (OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE*)paramData;\n if (!handle->venc_set_param(paramData, OMX_IndexParamVideoErrorCorrection)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Request for setting Error Resilience failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sErrorCorrection,pParam, sizeof(m_sErrorCorrection));\n break;\n }\n case OMX_IndexParamVideoIntraRefresh:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_INTRAREFRESHTYPE);\n                DEBUG_PRINT_LOW(\"set_param:OMX_IndexParamVideoIntraRefresh\");\n                OMX_VIDEO_PARAM_INTRAREFRESHTYPE* pParam =\n (OMX_VIDEO_PARAM_INTRAREFRESHTYPE*)paramData;\n if (!handle->venc_set_param(paramData,OMX_IndexParamVideoIntraRefresh)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Request for setting intra refresh failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sIntraRefresh, pParam, sizeof(m_sIntraRefresh));\n break;\n }\n#ifdef _ANDROID_ICS_\n case OMX_QcomIndexParamVideoMetaBufferMode:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, StoreMetaDataInBuffersParams);\n StoreMetaDataInBuffersParams *pParam =\n (StoreMetaDataInBuffersParams*)paramData;\n                DEBUG_PRINT_HIGH(\"set_parameter:OMX_QcomIndexParamVideoMetaBufferMode: \"\n \"port_index = %u, meta_mode = %d\", (unsigned int)pParam->nPortIndex, pParam->bStoreMetaData);\n if (pParam->nPortIndex == PORT_INDEX_IN) {\n if (pParam->bStoreMetaData != meta_mode_enable) {\n if (!handle->venc_set_meta_mode(pParam->bStoreMetaData)) {\n                            DEBUG_PRINT_ERROR(\"ERROR: set Metabuffer mode %d fail\",\n                                    pParam->bStoreMetaData);\n return OMX_ErrorUnsupportedSetting;\n }\n                        meta_mode_enable = pParam->bStoreMetaData;\n if (meta_mode_enable) {\n                            m_sInPortDef.nBufferCountActual = m_sInPortDef.nBufferCountMin;\n if (handle->venc_set_param(&m_sInPortDef,OMX_IndexParamPortDefinition) != true) {\n                                DEBUG_PRINT_ERROR(\"ERROR: venc_set_param input failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n } else {\n /*TODO: reset encoder driver Meta mode*/\n                            dev_get_buf_req   (&m_sOutPortDef.nBufferCountMin,\n &m_sOutPortDef.nBufferCountActual,\n &m_sOutPortDef.nBufferSize,\n                                    m_sOutPortDef.nPortIndex);\n }\n }\n } else if (pParam->nPortIndex == PORT_INDEX_OUT && secure_session) {\n if (pParam->bStoreMetaData != meta_mode_enable) {\n if (!handle->venc_set_meta_mode(pParam->bStoreMetaData)) {\n                            DEBUG_PRINT_ERROR(\"\\nERROR: set Metabuffer mode %d fail\",\n                                    pParam->bStoreMetaData);\n return OMX_ErrorUnsupportedSetting;\n }\n                        meta_mode_enable = pParam->bStoreMetaData;\n }\n } else {\n                    DEBUG_PRINT_ERROR(\"set_parameter: metamode is \"\n \"valid for input port only\");\n                    eRet = OMX_ErrorUnsupportedIndex;\n }\n }\n break;\n#endif\n#if !defined(MAX_RES_720P) || defined(_MSM8974_)\n case OMX_QcomIndexParamIndexExtraDataType:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_INDEXEXTRADATATYPE);\n                DEBUG_PRINT_HIGH(\"set_parameter: OMX_QcomIndexParamIndexExtraDataType\");\n                QOMX_INDEXEXTRADATATYPE *pParam = (QOMX_INDEXEXTRADATATYPE *)paramData;\n bool enable = false;\n                OMX_U32 mask = 0;\n\n if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoEncoderSliceInfo) {\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n                        mask = VEN_EXTRADATA_SLICEINFO;\n\n                        DEBUG_PRINT_HIGH(\"SliceInfo extradata %s\",\n ((pParam->bEnabled == OMX_TRUE) ? \"enabled\" : \"disabled\"));\n } else {\n                        DEBUG_PRINT_ERROR(\"set_parameter: Slice information is \"\n \"valid for output port only\");\n                        eRet = OMX_ErrorUnsupportedIndex;\n break;\n }\n } else if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoEncoderMBInfo) {\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n                        mask = VEN_EXTRADATA_MBINFO;\n\n                        DEBUG_PRINT_HIGH(\"MBInfo extradata %s\",\n ((pParam->bEnabled == OMX_TRUE) ? \"enabled\" : \"disabled\"));\n } else {\n                        DEBUG_PRINT_ERROR(\"set_parameter: MB information is \"\n \"valid for output port only\");\n                        eRet = OMX_ErrorUnsupportedIndex;\n break;\n }\n }\n#ifndef _MSM8974_\n else if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoLTRInfo) {\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n if (pParam->bEnabled == OMX_TRUE)\n                            mask = VEN_EXTRADATA_LTRINFO;\n\n                        DEBUG_PRINT_HIGH(\"LTRInfo extradata %s\",\n ((pParam->bEnabled == OMX_TRUE) ? \"enabled\" : \"disabled\"));\n } else {\n                        DEBUG_PRINT_ERROR(\"set_parameter: LTR information is \"\n \"valid for output port only\");\n                        eRet = OMX_ErrorUnsupportedIndex;\n break;\n }\n }\n#endif\n else {\n                    DEBUG_PRINT_ERROR(\"set_parameter: unsupported extrdata index (%x)\",\n                            pParam->nIndex);\n                    eRet = OMX_ErrorUnsupportedIndex;\n break;\n }\n\n\n if (pParam->bEnabled == OMX_TRUE)\n                    m_sExtraData |= mask;\n else\n                    m_sExtraData &= ~mask;\n\n                enable = !!(m_sExtraData & mask);\n if (handle->venc_set_param(&enable,\n (OMX_INDEXTYPE)pParam->nIndex) != true) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting Extradata (%x) failed\", pParam->nIndex);\n return OMX_ErrorUnsupportedSetting;\n } else {\n                    m_sOutPortDef.nPortIndex = PORT_INDEX_OUT;\n                    dev_get_buf_req(&m_sOutPortDef.nBufferCountMin,\n &m_sOutPortDef.nBufferCountActual,\n &m_sOutPortDef.nBufferSize,\n                            m_sOutPortDef.nPortIndex);\n                    DEBUG_PRINT_HIGH(\"updated out_buf_req: buffer cnt=%u, \"\n \"count min=%u, buffer size=%u\",\n (unsigned int)m_sOutPortDef.nBufferCountActual,\n (unsigned int)m_sOutPortDef.nBufferCountMin,\n (unsigned int)m_sOutPortDef.nBufferSize);\n }\n break;\n }\n case QOMX_IndexParamVideoLTRMode:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_VIDEO_PARAM_LTRMODE_TYPE);\n                QOMX_VIDEO_PARAM_LTRMODE_TYPE* pParam =\n (QOMX_VIDEO_PARAM_LTRMODE_TYPE*)paramData;\n if (!handle->venc_set_param(paramData, (OMX_INDEXTYPE)QOMX_IndexParamVideoLTRMode)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting LTR mode failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sParamLTRMode, pParam, sizeof(m_sParamLTRMode));\n break;\n }\n case QOMX_IndexParamVideoLTRCount:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_VIDEO_PARAM_LTRCOUNT_TYPE);\n                QOMX_VIDEO_PARAM_LTRCOUNT_TYPE* pParam =\n (QOMX_VIDEO_PARAM_LTRCOUNT_TYPE*)paramData;\n if (!handle->venc_set_param(paramData, (OMX_INDEXTYPE)QOMX_IndexParamVideoLTRCount)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting LTR count failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sParamLTRCount, pParam, sizeof(m_sParamLTRCount));\n break;\n }\n#endif\n case OMX_QcomIndexParamVideoMaxAllowedBitrateCheck:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_EXTNINDEX_PARAMTYPE);\n                QOMX_EXTNINDEX_PARAMTYPE* pParam =\n (QOMX_EXTNINDEX_PARAMTYPE*)paramData;\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n                    handle->m_max_allowed_bitrate_check =\n ((pParam->bEnable == OMX_TRUE) ? true : false);\n                    DEBUG_PRINT_HIGH(\"set_parameter: max allowed bitrate check %s\",\n ((pParam->bEnable == OMX_TRUE) ? \"enabled\" : \"disabled\"));\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: OMX_QcomIndexParamVideoMaxAllowedBitrateCheck \"\n \" called on wrong port(%u)\", (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n break;\n }\n#ifdef MAX_RES_1080P\n case OMX_QcomIndexEnableSliceDeliveryMode:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_EXTNINDEX_PARAMTYPE);\n                QOMX_EXTNINDEX_PARAMTYPE* pParam =\n (QOMX_EXTNINDEX_PARAMTYPE*)paramData;\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n if (!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE)OMX_QcomIndexEnableSliceDeliveryMode)) {\n                        DEBUG_PRINT_ERROR(\"ERROR: Request for setting slice delivery mode failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: OMX_QcomIndexEnableSliceDeliveryMode \"\n \"called on wrong port(%u)\", (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n break;\n }\n#endif\n case OMX_QcomIndexEnableH263PlusPType:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_EXTNINDEX_PARAMTYPE);\n                QOMX_EXTNINDEX_PARAMTYPE* pParam =\n (QOMX_EXTNINDEX_PARAMTYPE*)paramData;\n                DEBUG_PRINT_LOW(\"OMX_QcomIndexEnableH263PlusPType\");\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n if (!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE)OMX_QcomIndexEnableH263PlusPType)) {\n                        DEBUG_PRINT_ERROR(\"ERROR: Request for setting PlusPType failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: OMX_QcomIndexEnableH263PlusPType \"\n \"called on wrong port(%u)\", (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n break;\n }\n case OMX_QcomIndexParamSequenceHeaderWithIDR:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, PrependSPSPPSToIDRFramesParams);\n if(!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE)OMX_QcomIndexParamSequenceHeaderWithIDR)) {\n                    DEBUG_PRINT_ERROR(\"%s: %s\",\n \"OMX_QComIndexParamSequenceHeaderWithIDR:\",\n \"request for inband sps/pps failed.\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n }\n case OMX_QcomIndexParamH264AUDelimiter:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_CONFIG_H264_AUD);\n if(!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE)OMX_QcomIndexParamH264AUDelimiter)) {\n                    DEBUG_PRINT_ERROR(\"%s: %s\",\n \"OMX_QComIndexParamh264AUDelimiter:\",\n \"request for AU Delimiters failed.\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n }\n case OMX_QcomIndexHierarchicalStructure:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_VIDEO_HIERARCHICALLAYERS);\n                QOMX_VIDEO_HIERARCHICALLAYERS* pParam =\n (QOMX_VIDEO_HIERARCHICALLAYERS*)paramData;\n                DEBUG_PRINT_LOW(\"OMX_QcomIndexHierarchicalStructure\");\n if (pParam->nPortIndex == PORT_INDEX_OUT) {\n if (!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE)OMX_QcomIndexHierarchicalStructure)) {\n                        DEBUG_PRINT_ERROR(\"ERROR: Request for setting PlusPType failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n if((pParam->eHierarchicalCodingType == QOMX_HIERARCHICALCODING_B) && pParam->nNumLayers)\n                    hier_b_enabled = true;\n                    m_sHierLayers.nNumLayers = pParam->nNumLayers;\n                    m_sHierLayers.eHierarchicalCodingType = pParam->eHierarchicalCodingType;\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: OMX_QcomIndexHierarchicalStructure called on wrong port(%u)\",\n (unsigned int)pParam->nPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n break;\n\n }\n case OMX_QcomIndexParamPerfLevel:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_PERF_LEVEL);\n if (!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE) OMX_QcomIndexParamPerfLevel)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting performance level\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n }\n case OMX_QcomIndexParamH264VUITimingInfo:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_VUI_TIMING_INFO);\n if (!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE) OMX_QcomIndexParamH264VUITimingInfo)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting VUI timing info\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n }\n case OMX_QcomIndexParamPeakBitrate:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_PEAK_BITRATE);\n if (!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE) OMX_QcomIndexParamPeakBitrate)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting peak bitrate\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n }\n case QOMX_IndexParamVideoInitialQp:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_EXTNINDEX_VIDEO_INITIALQP);\n if(!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE)QOMX_IndexParamVideoInitialQp)) {\n                    DEBUG_PRINT_ERROR(\"Request to Enable initial QP failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n                memcpy(&m_sParamInitqp, paramData, sizeof(m_sParamInitqp));\n break;\n }\n case OMX_QcomIndexParamSetMVSearchrange:\n {\n if (!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE) OMX_QcomIndexParamSetMVSearchrange)) {\n                    DEBUG_PRINT_ERROR(\"ERROR: Setting Searchrange\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n }\n case OMX_QcomIndexParamVideoHybridHierpMode:\n {\n                VALIDATE_OMX_PARAM_DATA(paramData, QOMX_EXTNINDEX_VIDEO_HYBRID_HP_MODE);\n if(!handle->venc_set_param(paramData,\n (OMX_INDEXTYPE)OMX_QcomIndexParamVideoHybridHierpMode)) {\n                   DEBUG_PRINT_ERROR(\"Request to Enable Hybrid Hier-P failed\");\n return OMX_ErrorUnsupportedSetting;\n }\n break;\n }\n case OMX_IndexParamVideoSliceFMO:\n default:\n {\n                DEBUG_PRINT_ERROR(\"ERROR: Setparameter: unknown param %d\", paramIndex);\n                eRet = OMX_ErrorUnsupportedIndex;\n break;\n }\n }\n return eRet;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "vrrp_netlink_cmd_rcv_bufs_force_handler(vector_t *strvec)\n{\n\tint res = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec,1));\n\t\tif (res < 0) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid value '%s' for global vrrp_netlink_cmd_rcv_bufs_force specified\", FMT_STR_VSLOT(strvec, 1));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tglobal_data->vrrp_netlink_cmd_rcv_bufs_force = res;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void UpdateProperty(IBusProperty* ibus_prop) {\n    DLOG(INFO) << \"UpdateProperty\";\n    DCHECK(ibus_prop);\n    ImePropertyList prop_list;  // our representation.\n    if (!FlattenProperty(ibus_prop, &prop_list)) {\n      LOG(ERROR) << \"Malformed properties are detected\";\n      return;\n    }\n    if (!prop_list.empty()) {\n      update_ime_property_(language_library_, prop_list);\n    }\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void DataReductionProxySettings::OnServiceInitialized() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  if (!deferred_initialization_)\n    return;\n  deferred_initialization_ = false;\n  UpdateIOData(true);\n  if (proxy_config_client_) {\n    data_reduction_proxy_service_->SetCustomProxyConfigClient(\n        std::move(proxy_config_client_));\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int platform_pm_freeze(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->freeze)\n\t\t\tret = drv->pm->freeze(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_FREEZE);\n\t}\n\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GesturePoint::Reset() {\n  first_touch_time_ = last_touch_time_ = 0.0;\n  velocity_calculator_.ClearHistory();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n \tstruct context context;\n \tint rc = 0;\n \n \tif (!ss_initialized) {\n \t\tint i;\n \n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void tcp_v6_destroy_sock(struct sock *sk)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Clean up the MD5 key list */\n\tif (tcp_sk(sk)->md5sig_info)\n\t\ttcp_v6_clear_md5_list(sk);\n#endif\n\ttcp_v4_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RenderThread::Init() {\n  TRACE_EVENT_BEGIN_ETW(\"RenderThread::Init\", 0, \"\");\n\n#if defined(OS_MACOSX)\n  WebKit::WebView::setUseExternalPopupMenus(true);\n#endif\n\n  lazy_tls.Pointer()->Set(this);\n#if defined(OS_WIN)\n  if (RenderProcessImpl::InProcessPlugins())\n    CoInitialize(0);\n#endif\n\n  suspend_webkit_shared_timer_ = true;\n  notify_webkit_of_modal_loop_ = true;\n  plugin_refresh_allowed_ = true;\n  widget_count_ = 0;\n  hidden_widget_count_ = 0;\n  idle_notification_delay_in_s_ = kInitialIdleHandlerDelayS;\n  task_factory_.reset(new ScopedRunnableMethodFactory<RenderThread>(this));\n\n  appcache_dispatcher_.reset(new AppCacheDispatcher(this));\n  indexed_db_dispatcher_.reset(new IndexedDBDispatcher());\n\n  db_message_filter_ = new DBMessageFilter();\n  AddFilter(db_message_filter_.get());\n\n  vc_manager_ = new VideoCaptureImplManager();\n  AddFilter(vc_manager_->video_capture_message_filter());\n\n  audio_input_message_filter_ = new AudioInputMessageFilter();\n  AddFilter(audio_input_message_filter_.get());\n\n   audio_message_filter_ = new AudioMessageFilter();\n   AddFilter(audio_message_filter_.get());\n \n   content::GetContentClient()->renderer()->RenderThreadStarted();\n \n   TRACE_EVENT_END_ETW(\"RenderThread::Init\", 0, \"\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kNGroupsOffset = 12;\n const size_t kFirstGroupOffset = 16;\n\n     const size_t kGroupSize = 12;\n     const size_t kStartCharCodeOffset = 0;\n     const size_t kEndCharCodeOffset = 4;\n     if (kFirstGroupOffset > size) {\n         return false;\n     }\n     uint32_t nGroups = readU32(data, kNGroupsOffset);\n    if (kFirstGroupOffset + nGroups * kGroupSize > size) {\n         return false;\n     }\n     for (uint32_t i = 0; i < nGroups; i++) {\n uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n        addRange(coverage, start, end + 1); // file is inclusive, vector is exclusive\n }\n return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-19"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ProfileDependencyManager::AssertFactoriesBuilt() {\n  if (built_factories_)\n    return;\n\n#if defined(ENABLE_BACKGROUND)\n  BackgroundContentsServiceFactory::GetInstance();\n#endif\n  BookmarkModelFactory::GetInstance();\n#if defined(ENABLE_CAPTIVE_PORTAL_DETECTION)\n  captive_portal::CaptivePortalServiceFactory::GetInstance();\n#endif\n  ChromeURLDataManagerFactory::GetInstance();\n#if defined(ENABLE_PRINTING)\n  CloudPrintProxyServiceFactory::GetInstance();\n#endif\n  CookieSettings::Factory::GetInstance();\n#if defined(ENABLE_NOTIFICATIONS)\n  DesktopNotificationServiceFactory::GetInstance();\n#endif\n  DownloadServiceFactory::GetInstance();\n#if defined(ENABLE_EXTENSIONS)\n  extensions::AppRestoreServiceFactory::GetInstance();\n   extensions::BluetoothAPIFactory::GetInstance();\n   extensions::CommandServiceFactory::GetInstance();\n   extensions::CookiesAPIFactory::GetInstance();\n   extensions::ExtensionSystemFactory::GetInstance();\n   extensions::FontSettingsAPIFactory::GetInstance();\n   extensions::IdleManagerFactory::GetInstance();\n  extensions::ManagedModeAPIFactory::GetInstance();\n  extensions::ProcessesAPIFactory::GetInstance();\n  extensions::SuggestedLinksRegistryFactory::GetInstance();\n  extensions::TabCaptureRegistryFactory::GetInstance();\n  extensions::WebNavigationAPIFactory::GetInstance();\n  ExtensionManagementAPIFactory::GetInstance();\n#endif\n  FaviconServiceFactory::GetInstance();\n  FindBarStateFactory::GetInstance();\n#if defined(USE_AURA)\n  GesturePrefsObserverFactoryAura::GetInstance();\n#endif\n  GlobalErrorServiceFactory::GetInstance();\n  GoogleURLTrackerFactory::GetInstance();\n  HistoryServiceFactory::GetInstance();\n  MediaGalleriesPreferencesFactory::GetInstance();\n  NTPResourceCacheFactory::GetInstance();\n  PasswordStoreFactory::GetInstance();\n  PersonalDataManagerFactory::GetInstance();\n#if !defined(OS_ANDROID)\n  PinnedTabServiceFactory::GetInstance();\n#endif\n  PluginPrefsFactory::GetInstance();\n#if defined(ENABLE_CONFIGURATION_POLICY) && !defined(OS_CHROMEOS)\n  policy::UserPolicySigninServiceFactory::GetInstance();\n#endif\n  predictors::AutocompleteActionPredictorFactory::GetInstance();\n  predictors::PredictorDatabaseFactory::GetInstance();\n  predictors::ResourcePrefetchPredictorFactory::GetInstance();\n  prerender::PrerenderManagerFactory::GetInstance();\n  prerender::PrerenderLinkManagerFactory::GetInstance();\n  ProfileSyncServiceFactory::GetInstance();\n  ProtocolHandlerRegistryFactory::GetInstance();\n#if defined(ENABLE_PROTECTOR_SERVICE)\n  protector::ProtectorServiceFactory::GetInstance();\n#endif\n#if defined(ENABLE_SESSION_SERVICE)\n  SessionServiceFactory::GetInstance();\n#endif\n  ShortcutsBackendFactory::GetInstance();\n  ThumbnailServiceFactory::GetInstance();\n  SigninManagerFactory::GetInstance();\n#if defined(ENABLE_INPUT_SPEECH)\n  SpeechInputExtensionManager::InitializeFactory();\n  ChromeSpeechRecognitionPreferences::InitializeFactory();\n#endif\n  SpellcheckServiceFactory::GetInstance();\n  TabRestoreServiceFactory::GetInstance();\n  TemplateURLFetcherFactory::GetInstance();\n  TemplateURLServiceFactory::GetInstance();\n#if defined(ENABLE_THEMES)\n  ThemeServiceFactory::GetInstance();\n#endif\n  TokenServiceFactory::GetInstance();\n  UserStyleSheetWatcherFactory::GetInstance();\n  VisitedLinkMasterFactory::GetInstance();\n  WebDataServiceFactory::GetInstance();\n#if defined(ENABLE_WEB_INTENTS)\n  WebIntentsRegistryFactory::GetInstance();\n#endif\n\n  built_factories_ = true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int processPCPRequest(void * req, int req_size, pcp_info_t *pcp_msg_info)\n{\n\tint remainingSize;\n\n\t/* start with PCP_SUCCESS as result code,\n\t * if everything is OK value will be unchanged */\n\tpcp_msg_info->result_code = PCP_SUCCESS;\n\n\tremainingSize = req_size;\n\n\t/* discard request that exceeds maximal length,\n\t   or that is shorter than PCP_MIN_LEN (=24)\n\t   or that is not the multiple of 4 */\n\tif (req_size < 3)\n\t\treturn 0; /* ignore msg */\n\n\tif (req_size < PCP_MIN_LEN) {\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 1; /* send response */\n\t}\n\n\tif ( (req_size > PCP_MAX_LEN) || ( (req_size & 3) != 0)) {\n\t\tsyslog(LOG_ERR, \"PCP: Size of PCP packet(%d) is larger than %d bytes or \"\n\t\t       \"the size is not multiple of 4.\\n\", req_size, PCP_MAX_LEN);\n\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\treturn 1; /* send response */\n\t}\n\n\t/* first parse request header */\n\tif (parseCommonRequestHeader(req, pcp_msg_info) ) {\n\t\treturn 1;\n\t}\n\n\tremainingSize -= PCP_COMMON_REQUEST_SIZE;\n\treq += PCP_COMMON_REQUEST_SIZE;\n\n\tif (pcp_msg_info->version == 1) {\n\t\t/* legacy PCP version 1 support */\n\t\tswitch (pcp_msg_info->opcode) {\n\t\tcase PCP_OPCODE_MAP:\n\n\t\t\tremainingSize -= PCP_MAP_V1_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintMAPOpcodeVersion1(req);\n#endif /* DEBUG */\n\t\t\tparsePCPMAP_version1(req, pcp_msg_info);\n\n\t\t\treq += PCP_MAP_V1_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPMap(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPMap(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v1 MAP message.\");\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef PCP_PEER\n\t\tcase PCP_OPCODE_PEER:\n\n\t\t\tremainingSize -= PCP_PEER_V1_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintPEEROpcodeVersion1(req);\n#endif /* DEBUG */\n\t\t\tparsePCPPEER_version1(req, pcp_msg_info);\n\n\t\t\treq += PCP_PEER_V1_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPPeer(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPPeer(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v1 PEER message.\");\n\t\t\t\t return pcp_msg_info->result_code;\n\t\t\t}\n\n\n\t\t\tbreak;\n#endif /* PCP_PEER */\n\t\tdefault:\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPCODE;\n\t\t\tbreak;\n\t\t}\n\n\t} else if (pcp_msg_info->version == 2) {\n\t\t/* RFC 6887 PCP support\n\t\t * http://tools.ietf.org/html/rfc6887 */\n\t\tswitch (pcp_msg_info->opcode) {\n\t\tcase PCP_OPCODE_ANNOUNCE:\n\t\t\t/* should check PCP Client's IP Address in request */\n\t\t\t/* see http://tools.ietf.org/html/rfc6887#section-14.1 */\n\t\t\tbreak;\n\t\tcase PCP_OPCODE_MAP:\n\n\t\t\tremainingSize -= PCP_MAP_V2_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintMAPOpcodeVersion2(req);\n#endif /* DEBUG */\n\t\t\tparsePCPMAP_version2(req, pcp_msg_info);\n\t\t\treq += PCP_MAP_V2_SIZE;\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPMap(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPMap(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v2 MAP message.\");\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\n\t\t\tbreak;\n\n#ifdef PCP_PEER\n\t\tcase PCP_OPCODE_PEER:\n\n\t\t\tremainingSize -= PCP_PEER_V2_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintPEEROpcodeVersion2(req);\n#endif /* DEBUG */\n\t\t\tparsePCPPEER_version2(req, pcp_msg_info);\n\t\t\treq += PCP_PEER_V2_SIZE;\n\n\t\t\tif (pcp_msg_info->result_code != 0) {\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\t\t\tparsePCPOptions(req, remainingSize, pcp_msg_info);\n\n\t\t\tif (ValidatePCPMsg(pcp_msg_info)) {\n\t\t\t\tif (pcp_msg_info->lifetime == 0) {\n\t\t\t\t\tDeletePCPPeer(pcp_msg_info);\n\t\t\t\t} else {\n\t\t\t\t\tCreatePCPPeer(pcp_msg_info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"PCP: Invalid PCP v2 PEER message.\");\n\t\t\t}\n\n\t\tbreak;\n#endif /* PCP_PEER */\n\n#ifdef PCP_SADSCP\n\t\tcase PCP_OPCODE_SADSCP:\n\t\t\tremainingSize -= PCP_SADSCP_REQ_SIZE;\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_REQUEST;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n\t\t\tremainingSize -= ((uint8_t *)req)[13];\t/* app_name_length */\n\t\t\tif (remainingSize < 0) {\n\t\t\t\tpcp_msg_info->result_code = PCP_ERR_MALFORMED_OPTION;\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tprintSADSCPOpcode(req);\n#endif\n\t\t\tparseSADSCP(req, pcp_msg_info);\n\t\t\treq += PCP_SADSCP_REQ_SIZE;\n\t\t\tif (pcp_msg_info->result_code != 0) {\n\t\t\t\treturn pcp_msg_info->result_code;\n\t\t\t}\n\t\t\treq += pcp_msg_info->app_name_len;\n\n\t\t\tget_dscp_value(pcp_msg_info);\n\n\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_OPCODE;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpcp_msg_info->result_code = PCP_ERR_UNSUPP_VERSION;\n\t\treturn pcp_msg_info->result_code;\n\t}\n\treturn 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xsltFreeTemplateHashes(xsltStylesheetPtr style) {\n    if (style->templatesHash != NULL)\n\txmlHashFree((xmlHashTablePtr) style->templatesHash,\n\t\t    (xmlHashDeallocator) xsltFreeCompMatchList);\n    if (style->rootMatch != NULL)\n        xsltFreeCompMatchList(style->rootMatch);\n    if (style->keyMatch != NULL)\n        xsltFreeCompMatchList(style->keyMatch);\n    if (style->elemMatch != NULL)\n        xsltFreeCompMatchList(style->elemMatch);\n    if (style->attrMatch != NULL)\n        xsltFreeCompMatchList(style->attrMatch);\n    if (style->parentMatch != NULL)\n        xsltFreeCompMatchList(style->parentMatch);\n    if (style->textMatch != NULL)\n        xsltFreeCompMatchList(style->textMatch);\n    if (style->piMatch != NULL)\n         xsltFreeCompMatchList(style->piMatch);\n     if (style->commentMatch != NULL)\n         xsltFreeCompMatchList(style->commentMatch);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "png_set_filter(png_structp png_ptr, int method, int filters)\n{\n   png_debug(1, \"in png_set_filter\");\n\n   if (png_ptr == NULL)\n      return;\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&\n      (method == PNG_INTRAPIXEL_DIFFERENCING))\n         method = PNG_FILTER_TYPE_BASE;\n#endif\n   if (method == PNG_FILTER_TYPE_BASE)\n    {\n       switch (filters & (PNG_ALL_FILTERS | 0x07))\n       {\n #ifdef PNG_WRITE_FILTER_SUPPORTED\n          case 5:\n          case 6:\n          case 7: png_warning(png_ptr, \"Unknown row filter for method 0\");\n#endif /* PNG_WRITE_FILTER_SUPPORTED */\n         case PNG_FILTER_VALUE_NONE:\n              png_ptr->do_filter = PNG_FILTER_NONE; break;\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n          case PNG_FILTER_VALUE_SUB:\n               png_ptr->do_filter = PNG_FILTER_SUB; break;\n          case PNG_FILTER_VALUE_UP:\n              png_ptr->do_filter = PNG_FILTER_UP; break;\n         case PNG_FILTER_VALUE_AVG:\n              png_ptr->do_filter = PNG_FILTER_AVG; break;\n         case PNG_FILTER_VALUE_PAETH:\n              png_ptr->do_filter = PNG_FILTER_PAETH; break;\n          default: png_ptr->do_filter = (png_byte)filters; break;\n #else\n          default: png_warning(png_ptr, \"Unknown row filter for method 0\");\n #endif /* PNG_WRITE_FILTER_SUPPORTED */\n       }\n \n      /* If we have allocated the row_buf, this means we have already started\n       * with the image and we should have allocated all of the filter buffers\n       * that have been selected.  If prev_row isn't already allocated, then\n       * it is too late to start using the filters that need it, since we\n       * will be missing the data in the previous row.  If an application\n       * wants to start and stop using particular filters during compression,\n       * it should start out with all of the filters, and then add and\n       * remove them after the start of compression.\n       */\n      if (png_ptr->row_buf != NULL)\n      {\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n         if ((png_ptr->do_filter & PNG_FILTER_SUB) && png_ptr->sub_row == NULL)\n         {\n            png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,\n              (png_ptr->rowbytes + 1));\n            png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_UP) && png_ptr->up_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Up filter after starting\");\n               png_ptr->do_filter &= ~PNG_FILTER_UP;\n            }\n            else\n            {\n               png_ptr->up_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;\n            }\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_AVG) && png_ptr->avg_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Average filter after starting\");\n               png_ptr->do_filter &= ~PNG_FILTER_AVG;\n            }\n            else\n            {\n               png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;\n            }\n         }\n\n         if ((png_ptr->do_filter & PNG_FILTER_PAETH) &&\n             png_ptr->paeth_row == NULL)\n         {\n            if (png_ptr->prev_row == NULL)\n            {\n               png_warning(png_ptr, \"Can't add Paeth filter after starting\");\n               png_ptr->do_filter &= (png_byte)(~PNG_FILTER_PAETH);\n            }\n            else\n            {\n               png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,\n                  (png_ptr->rowbytes + 1));\n               png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;\n            }\n         }\n\n         if (png_ptr->do_filter == PNG_NO_FILTERS)\n#endif /* PNG_WRITE_FILTER_SUPPORTED */\n            png_ptr->do_filter = PNG_FILTER_NONE;\n      }\n   }\n   else\n      png_error(png_ptr, \"Unknown custom filter method\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SkBitmap Browser::GetCurrentPageIcon() const {\n  TabContentsWrapper* contents = GetSelectedTabContentsWrapper();\n  return contents ? contents->favicon_tab_helper()->GetFavicon() : SkBitmap();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "struct crypto_template *crypto_lookup_template(const char *name)\n {\n\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n\t\t\t\t       name);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "mysqlnd_switch_to_ssl_if_needed(\n\t\t\tMYSQLND_CONN_DATA * conn,\n\t\t\tconst MYSQLND_PACKET_GREET * const greet_packet,\n\t\t\tconst MYSQLND_OPTIONS * const options,\n\t\t\tunsigned long mysql_flags\n\t\t\tTSRMLS_DC\n\t\t)\n{\n\tenum_func_status ret = FAIL;\n\tconst MYSQLND_CHARSET * charset;\n\tMYSQLND_PACKET_AUTH * auth_packet;\n\tDBG_ENTER(\"mysqlnd_switch_to_ssl_if_needed\");\n\n\tauth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);\n\tif (!auth_packet) {\n\t\tSET_OOM_ERROR(*conn->error_info);\n\t\tgoto end;\n\t}\n\tauth_packet->client_flags = mysql_flags;\n\tauth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;\n\n\tif (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {\n\t\tauth_packet->charset_no\t= charset->nr;\n\t} else {\n#if MYSQLND_UNICODE\n\t\tauth_packet->charset_no\t= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */\n#else\n\t\tauth_packet->charset_no\t= greet_packet->charset_no;\n#endif\n        }\n \n #ifdef MYSQLND_SSL_SUPPORTED\n       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {\n               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;\n               DBG_INF(\"Switching to SSL\");\n               if (!PACKET_WRITE(auth_packet, conn)) {\n                       CONN_SET_STATE(conn, CONN_QUIT_SENT);\n                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\n                       goto end;\n               }\n \n               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);\n \n               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {\n                       goto end;\n                }\n        }\n #endif\n        ret = PASS;\n end:\n        PACKET_FREE(auth_packet);\n        DBG_RETURN(ret);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Ins_LT( FT_Long*  args )\n  {\n    args[0] = ( args[0] < args[1] );\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void SafeBrowsingPrivateEventRouter::OnDangerousDeepScanningResult(\n    const GURL& url,\n     const std::string& file_name,\n     const std::string& download_digest_sha256) {\n   if (client_) {\n     base::Value event(base::Value::Type::DICTIONARY);\n     event.SetStringKey(kKeyUrl, url.spec());\n     event.SetStringKey(kKeyFileName, file_name);\n    event.SetStringKey(kKeyDownloadDigestSha256, download_digest_sha256);\n    event.SetStringKey(kKeyProfileUserName, GetProfileUserName());\n    ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(event));\n   }\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int append_new_servers(GArray *const servers, GError **const gerror) {\n        int i;\n        GArray *new_servers;\n        const int old_len = servers->len;\n        int retval = -1;\n        struct generic_conf genconf;\n\n        new_servers = parse_cfile(config_file_pos, &genconf, gerror);\n        if (!new_servers)\n                goto out;\n\n        for (i = 0; i < new_servers->len; ++i) {\n                SERVER new_server = g_array_index(new_servers, SERVER, i);\n\n                if (new_server.servename\n                    && -1 == get_index_by_servename(new_server.servename,\n                                                    servers)) {\n                        if (setup_serve(&new_server, gerror) == -1)\n                                goto out;\n                        if (append_serve(&new_server, servers) == -1)\n                                goto out;\n                }\n        }\n\n        retval = servers->len - old_len;\nout:\n        g_array_free(new_servers, TRUE);\n\n        return retval;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OMX::buffer_id OMXNodeInstance::findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {\n    return (OMX::buffer_id)bufferHeader;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "const PPB_NaCl_Private* GetNaclInterface() {\n  pp::Module *module = pp::Module::Get();\n  CHECK(module);\n  return static_cast<const PPB_NaCl_Private*>(\n      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void FrameLoader::ProcessFragment(const KURL& url,\n                                  WebFrameLoadType frame_load_type,\n                                  LoadStartType load_start_type) {\n  LocalFrameView* view = frame_->View();\n  if (!view)\n    return;\n\n  Frame* boundary_frame =\n      url.HasFragmentIdentifier()\n          ? frame_->FindUnsafeParentScrollPropagationBoundary()\n          : nullptr;\n\n  if (boundary_frame && boundary_frame->IsLocalFrame()) {\n    ToLocalFrame(boundary_frame)\n        ->View()\n        ->SetSafeToPropagateScrollToParent(false);\n  }\n\n  bool should_scroll_to_fragment =\n      (load_start_type == kNavigationWithinSameDocument &&\n       !IsBackForwardLoadType(frame_load_type)) ||\n      (!GetDocumentLoader()->GetInitialScrollState().did_restore_from_history &&\n       !(GetDocumentLoader()->GetHistoryItem() &&\n         GetDocumentLoader()->GetHistoryItem()->ScrollRestorationType() ==\n             kScrollRestorationManual));\n\n  view->ProcessUrlFragment(url, should_scroll_to_fragment\n                                    ? LocalFrameView::kUrlFragmentScroll\n                                    : LocalFrameView::kUrlFragmentDontScroll);\n\n  if (boundary_frame && boundary_frame->IsLocalFrame())\n    ToLocalFrame(boundary_frame)\n        ->View()\n        ->SetSafeToPropagateScrollToParent(true);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int path_walk(const char *name, struct nameidata *nd)\n{\n\tstruct path save = nd->path;\n\tint result;\n\n\tcurrent->total_link_count = 0;\n\n\t/* make sure the stuff we saved doesn't go away */\n\tpath_get(&save);\n\n\tresult = link_path_walk(name, nd);\n\tif (result == -ESTALE) {\n\t\t/* nd->path had been dropped */\n\t\tcurrent->total_link_count = 0;\n\t\tnd->path = save;\n\t\tpath_get(&nd->path);\n\t\tnd->flags |= LOOKUP_REVAL;\n\t\tresult = link_path_walk(name, nd);\n\t}\n\n\tpath_put(&save);\n\n\treturn result;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(\n    CommandLine* command_line, int child_process_id) {\n#if defined(USE_LINUX_BREAKPAD)\n  if (IsCrashReporterEnabled()) {\n    command_line->AppendSwitchASCII(switches::kEnableCrashReporter,\n        child_process_logging::GetClientId() + \",\" + base::GetLinuxDistro());\n  }\n#elif defined(OS_MACOSX)\n  if (IsCrashReporterEnabled()) {\n    command_line->AppendSwitchASCII(switches::kEnableCrashReporter,\n                                    child_process_logging::GetClientId());\n  }\n#endif  // OS_MACOSX\n\n  if (logging::DialogsAreSuppressed())\n    command_line->AppendSwitch(switches::kNoErrorDialogs);\n\n  std::string process_type =\n      command_line->GetSwitchValueASCII(switches::kProcessType);\n  const CommandLine& browser_command_line = *CommandLine::ForCurrentProcess();\n  if (process_type == switches::kExtensionProcess ||\n      process_type == switches::kRendererProcess) {\n    FilePath user_data_dir =\n        browser_command_line.GetSwitchValuePath(switches::kUserDataDir);\n    if (!user_data_dir.empty())\n      command_line->AppendSwitchPath(switches::kUserDataDir, user_data_dir);\n#if defined(OS_CHROMEOS)\n    const std::string& login_profile =\n        browser_command_line.GetSwitchValueASCII(switches::kLoginProfile);\n    if (!login_profile.empty())\n      command_line->AppendSwitchASCII(switches::kLoginProfile, login_profile);\n#endif\n\n    RenderProcessHost* process = RenderProcessHost::FromID(child_process_id);\n\n    PrefService* prefs = process->profile()->GetPrefs();\n    if (prefs->HasPrefPath(prefs::kDisable3DAPIs) &&\n        prefs->GetBoolean(prefs::kDisable3DAPIs)) {\n      command_line->AppendSwitch(switches::kDisable3DAPIs);\n    }\n\n    if (!prefs->GetBoolean(prefs::kSafeBrowsingEnabled) ||\n        !g_browser_process->safe_browsing_detection_service()) {\n      command_line->AppendSwitch(switches::kDisableClientSidePhishingDetection);\n    }\n\n    static const char* const kSwitchNames[] = {\n      switches::kAllowHTTPBackgroundPage,\n      switches::kAllowScriptingGallery,\n      switches::kAppsCheckoutURL,\n      switches::kAppsGalleryURL,\n      switches::kCloudPrintServiceURL,\n      switches::kDebugPrint,\n#if defined(GOOGLE_CHROME_BUILD) && !defined(OS_CHROMEOS) && !defined(OS_MACOSX)\n      switches::kDisablePrintPreview,\n#else\n      switches::kEnablePrintPreview,\n#endif\n      switches::kDomAutomationController,\n      switches::kDumpHistogramsOnExit,\n      switches::kEnableClickToPlay,\n      switches::kEnableCrxlessWebApps,\n      switches::kEnableExperimentalExtensionApis,\n      switches::kEnableInBrowserThumbnailing,\n      switches::kEnableIPCFuzzing,\n      switches::kEnableNaCl,\n      switches::kEnableRemoting,\n      switches::kEnableResourceContentSettings,\n      switches::kEnableSearchProviderApiV2,\n      switches::kEnableWatchdog,\n      switches::kExperimentalSpellcheckerFeatures,\n      switches::kMemoryProfiling,\n      switches::kMessageLoopHistogrammer,\n      switches::kPpapiFlashArgs,\n      switches::kPpapiFlashInProcess,\n      switches::kPpapiFlashPath,\n      switches::kPpapiFlashVersion,\n       switches::kProfilingAtStart,\n       switches::kProfilingFile,\n       switches::kProfilingFlush,\n      switches::kRemoteShellPort,\n       switches::kSilentDumpOnDCHECK,\n     };\n \n    command_line->CopySwitchesFrom(browser_command_line, kSwitchNames,\n                                   arraysize(kSwitchNames));\n  } else if (process_type == switches::kUtilityProcess) {\n    if (browser_command_line.HasSwitch(\n            switches::kEnableExperimentalExtensionApis)) {\n      command_line->AppendSwitch(switches::kEnableExperimentalExtensionApis);\n    }\n  } else if (process_type == switches::kPluginProcess) {\n    static const char* const kSwitchNames[] = {\n  #if defined(OS_CHROMEOS)\n      switches::kLoginProfile,\n  #endif\n      switches::kMemoryProfiling,\n      switches::kSilentDumpOnDCHECK,\n      switches::kUserDataDir,\n    };\n\n    command_line->CopySwitchesFrom(browser_command_line, kSwitchNames,\n                                   arraysize(kSwitchNames));\n  } else if (process_type == switches::kZygoteProcess) {\n    static const char* const kSwitchNames[] = {\n      switches::kEnableRemoting,\n      switches::kUserDataDir,  // Make logs go to the right file.\n      switches::kPpapiFlashInProcess,\n      switches::kPpapiFlashPath,\n      switches::kPpapiFlashVersion,\n    };\n\n    command_line->CopySwitchesFrom(browser_command_line, kSwitchNames,\n                                   arraysize(kSwitchNames));\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n \t\t\tunsigned long mask = PSW_MASK_USER;\n \n \t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n \t\t\t\treturn -EINVAL;\n \t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n \t\t\t\treturn -EINVAL;\n \t\t}\n \t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writes of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\n\t}\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool PageCaptureSaveAsMHTMLFunction::RunAsync() {\n  params_ = SaveAsMHTML::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params_.get());\n\n  AddRef();  // Balanced in ReturnFailure/ReturnSuccess()\n\n#if defined(OS_CHROMEOS)\n  if (profiles::ArePublicSessionRestrictionsEnabled()) {\n    WebContents* web_contents = GetWebContents();\n    if (!web_contents) {\n      ReturnFailure(kTabClosedError);\n      return true;\n    }\n    auto callback =\n        base::Bind(&PageCaptureSaveAsMHTMLFunction::ResolvePermissionRequest,\n                   base::Unretained(this));\n    permission_helper::HandlePermissionRequest(\n        *extension(), {APIPermission::kPageCapture}, web_contents, callback,\n        permission_helper::PromptFactory());\n    return true;\n   }\n #endif\n \n   base::PostTaskWithTraits(\n       FROM_HERE, kCreateTemporaryFileTaskTraits,\n       base::BindOnce(&PageCaptureSaveAsMHTMLFunction::CreateTemporaryFile,\n                      this));\n   return true;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECKEY ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key not ECDH capable\" ) );\n        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx,\n                                 mbedtls_pk_ec( *mbedtls_ssl_own_key( ssl ) ),\n                                 MBEDTLS_ECDH_OURS ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ecdh_get_params\" ), ret );\n        return( ret );\n    }\n\n    return( 0 );\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool HTMLSelectElement::anonymousIndexedSetter(unsigned index, PassRefPtr<HTMLOptionElement> value, ExceptionState& exceptionState)\n{\n    if (!value) {\n        exceptionState.throwTypeError(ExceptionMessages::failedToSet(String::number(index), \"HTMLSelectElement\", \"The value provided was not an HTMLOptionElement.\"));\n        return false;\n    }\n    setOption(index, value.get(), exceptionState);\n    return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ux500_hash_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct hash_device_data *device_data;\n\tstruct hash_ctx *temp_ctx = NULL;\n\n\tdevice_data = dev_get_drvdata(dev);\n\tif (!device_data) {\n\t\tdev_err(dev, \"%s: platform_get_drvdata() failed!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&device_data->ctx_lock);\n\tif (!device_data->current_ctx)\n\t\tdevice_data->current_ctx++;\n\tspin_unlock(&device_data->ctx_lock);\n\n\tif (device_data->current_ctx == ++temp_ctx) {\n\t\tif (down_interruptible(&driver_data.device_allocation))\n\t\t\tdev_dbg(dev, \"%s: down_interruptible() failed\\n\",\n\t\t\t\t__func__);\n\t\tret = hash_disable_power(device_data, false);\n\n\t} else {\n\t\tret = hash_disable_power(device_data, true);\n\t}\n\n\tif (ret)\n\t\tdev_err(dev, \"%s: hash_disable_power()\\n\", __func__);\n\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static jlong Region_constructor(JNIEnv* env, jobject) {\n return reinterpret_cast<jlong>(new SkRegion);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n{\n\tstatic const char module[] = \"PredictorEncodeTile\";\n\tTIFFPredictorState *sp = PredictorState(tif);\n        uint8 *working_copy;\n\ttmsize_t cc = cc0, rowsize;\n\tunsigned char* bp;\n        int result_code;\n\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encodetile != NULL);\n\n        /* \n         * Do predictor manipulation in a working buffer to avoid altering\n         * the callers buffer. http://trac.osgeo.org/gdal/ticket/1965\n         */\n        working_copy = (uint8*) _TIFFmalloc(cc0);\n        if( working_copy == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, module, \n                         \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",\n                         cc0 );\n            return 0;\n        }\n        memcpy( working_copy, bp0, cc0 );\n        bp = working_copy;\n \n \trowsize = sp->rowsize;\n \tassert(rowsize > 0);\n\tassert((cc0%rowsize)==0);\n \twhile (cc > 0) {\n \t\t(*sp->encodepfunc)(tif, bp, rowsize);\n \t\tcc -= rowsize;\n\t\tbp += rowsize;\n\t}\n\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);\n\n        _TIFFfree( working_copy );\n\n        return result_code;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n {\n \tGF_HandlerBox *p = (GF_HandlerBox *)a;\n \tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n \t} else {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "char* iwpvt_strdup_dbl(struct iw_context *ctx, double n)\n{\n\tchar buf[100];\n\tiw_snprintf(buf, sizeof(buf), \"%.20f\", n);\n\treturn iw_strdup(ctx, buf);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-682"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){\n  u8 aff = (char)sqlite3ExprAffinity(pExpr2);\n  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;\n  return aff;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)\n {\n     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "XcursorCommentCreate (XcursorUInt comment_type, int length)\n{\n    XcursorComment  *comment;\n\n    if (length > XCURSOR_COMMENT_MAX_LEN)\n\treturn NULL;\n {\n     XcursorComment  *comment;\n \n    if (length > XCURSOR_COMMENT_MAX_LEN)\n \treturn NULL;\n \n     comment = malloc (sizeof (XcursorComment) + length + 1);\n    comment->comment[0] = '\\0';\n    return comment;\n}\n\nvoid\nXcursorCommentDestroy (XcursorComment *comment)\n{\n    free (comment);\n}\n\nXcursorComments *\nXcursorCommentsCreate (int size)\n{\n    XcursorComments *comments;\n\n    comments = malloc (sizeof (XcursorComments) +\n\t\t       size * sizeof (XcursorComment *));\n    if (!comments)\n\treturn NULL;\n    comments->ncomment = 0;\n    comments->comments = (XcursorComment **) (comments + 1);\n    return comments;\n}\n\nvoid\nXcursorCommentsDestroy (XcursorComments *comments)\n{\n    int\tn;\n\n    if (!comments)\n        return;\n\n    for (n = 0; n < comments->ncomment; n++)\n\tXcursorCommentDestroy (comments->comments[n]);\n    free (comments);\n}\n\nstatic XcursorBool\n_XcursorReadUInt (XcursorFile *file, XcursorUInt *u)\n{\n    unsigned char   bytes[4];\n\n    if (!file || !u)\n        return XcursorFalse;\n\n    if ((*file->read) (file, bytes, 4) != 4)\n\treturn XcursorFalse;\n    *u = ((bytes[0] << 0) |\n\t  (bytes[1] << 8) |\n\t  (bytes[2] << 16) |\n\t  (bytes[3] << 24));\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorReadBytes (XcursorFile *file, char *bytes, int length)\n{\n    if (!file || !bytes || (*file->read) (file, (unsigned char *) bytes, length) != length)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorWriteUInt (XcursorFile *file, XcursorUInt u)\n{\n    unsigned char   bytes[4];\n\n    if (!file)\n        return XcursorFalse;\n\n    bytes[0] = u;\n    bytes[1] = u >>  8;\n    bytes[2] = u >> 16;\n    bytes[3] = u >> 24;\n    if ((*file->write) (file, bytes, 4) != 4)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorWriteBytes (XcursorFile *file, char *bytes, int length)\n{\n    if (!file || !bytes || (*file->write) (file, (unsigned char *) bytes, length) != length)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic void\n_XcursorFileHeaderDestroy (XcursorFileHeader *fileHeader)\n{\n    free (fileHeader);\n}\n\nstatic XcursorFileHeader *\n_XcursorFileHeaderCreate (XcursorUInt ntoc)\n{\n    XcursorFileHeader\t*fileHeader;\n\n    if (ntoc > 0x10000)\n\treturn NULL;\n    fileHeader = malloc (sizeof (XcursorFileHeader) +\n\t\t\t ntoc * sizeof (XcursorFileToc));\n    if (!fileHeader)\n\treturn NULL;\n    fileHeader->magic = XCURSOR_MAGIC;\n    fileHeader->header = XCURSOR_FILE_HEADER_LEN;\n    fileHeader->version = XCURSOR_FILE_VERSION;\n    fileHeader->ntoc = ntoc;\n    fileHeader->tocs = (XcursorFileToc *) (fileHeader + 1);\n    return fileHeader;\n}\n\nstatic XcursorFileHeader *\n_XcursorReadFileHeader (XcursorFile *file)\n{\n    XcursorFileHeader\thead, *fileHeader;\n    XcursorUInt\t\tskip;\n    int\t\t\tn;\n\n    if (!file)\n        return NULL;\n\n    if (!_XcursorReadUInt (file, &head.magic))\n\treturn NULL;\n    if (head.magic != XCURSOR_MAGIC)\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.header))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.version))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.ntoc))\n\treturn NULL;\n    skip = head.header - XCURSOR_FILE_HEADER_LEN;\n    if (skip)\n\tif ((*file->seek) (file, skip, SEEK_CUR) == EOF)\n\t    return NULL;\n    fileHeader = _XcursorFileHeaderCreate (head.ntoc);\n    if (!fileHeader)\n\treturn NULL;\n    fileHeader->magic = head.magic;\n    fileHeader->header = head.header;\n    fileHeader->version = head.version;\n    fileHeader->ntoc = head.ntoc;\n    for (n = 0; n < fileHeader->ntoc; n++)\n    {\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].type))\n\t    break;\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].subtype))\n\t    break;\n\tif (!_XcursorReadUInt (file, &fileHeader->tocs[n].position))\n\t    break;\n    }\n    if (n != fileHeader->ntoc)\n    {\n\t_XcursorFileHeaderDestroy (fileHeader);\n\treturn NULL;\n    }\n    return fileHeader;\n}\n\nstatic XcursorUInt\n_XcursorFileHeaderLength (XcursorFileHeader *fileHeader)\n{\n    return (XCURSOR_FILE_HEADER_LEN +\n\t    fileHeader->ntoc * XCURSOR_FILE_TOC_LEN);\n}\n\nstatic XcursorBool\n_XcursorWriteFileHeader (XcursorFile *file, XcursorFileHeader *fileHeader)\n{\n    int\ttoc;\n\n    if (!file || !fileHeader)\n        return XcursorFalse;\n\n    if (!_XcursorWriteUInt (file, fileHeader->magic))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->version))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, fileHeader->ntoc))\n\treturn XcursorFalse;\n    for (toc = 0; toc < fileHeader->ntoc; toc++)\n    {\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].type))\n\t    return XcursorFalse;\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].subtype))\n\t    return XcursorFalse;\n\tif (!_XcursorWriteUInt (file, fileHeader->tocs[toc].position))\n\t    return XcursorFalse;\n    }\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorSeekToToc (XcursorFile\t\t*file,\n\t\t   XcursorFileHeader\t*fileHeader,\n\t\t   int\t\t\ttoc)\n{\n    if (!file || !fileHeader || \\\n        (*file->seek) (file, fileHeader->tocs[toc].position, SEEK_SET) == EOF)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorFileReadChunkHeader (XcursorFile\t*file,\n\t\t\t     XcursorFileHeader\t*fileHeader,\n\t\t\t     int\t\ttoc,\n\t\t\t     XcursorChunkHeader\t*chunkHeader)\n{\n    if (!file || !fileHeader || !chunkHeader)\n        return XcursorFalse;\n    if (!_XcursorSeekToToc (file, fileHeader, toc))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->type))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->subtype))\n\treturn XcursorFalse;\n    if (!_XcursorReadUInt (file, &chunkHeader->version))\n\treturn XcursorFalse;\n    /* sanity check */\n    if (chunkHeader->type != fileHeader->tocs[toc].type ||\n\tchunkHeader->subtype != fileHeader->tocs[toc].subtype)\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\nstatic XcursorBool\n_XcursorFileWriteChunkHeader (XcursorFile\t    *file,\n\t\t\t      XcursorFileHeader\t    *fileHeader,\n\t\t\t      int\t\t    toc,\n\t\t\t      XcursorChunkHeader    *chunkHeader)\n{\n    if (!file || !fileHeader || !chunkHeader)\n        return XcursorFalse;\n    if (!_XcursorSeekToToc (file, fileHeader, toc))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->header))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->type))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->subtype))\n\treturn XcursorFalse;\n    if (!_XcursorWriteUInt (file, chunkHeader->version))\n\treturn XcursorFalse;\n    return XcursorTrue;\n}\n\n#define dist(a,b)   ((a) > (b) ? (a) - (b) : (b) - (a))\n\nstatic XcursorDim\n_XcursorFindBestSize (XcursorFileHeader *fileHeader,\n\t\t      XcursorDim\tsize,\n\t\t      int\t\t*nsizesp)\n{\n    int\t\tn;\n    int\t\tnsizes = 0;\n    XcursorDim\tbestSize = 0;\n    XcursorDim\tthisSize;\n\n    if (!fileHeader || !nsizesp)\n        return 0;\n\n    for (n = 0; n < fileHeader->ntoc; n++)\n    {\n\tif (fileHeader->tocs[n].type != XCURSOR_IMAGE_TYPE)\n\t    continue;\n\tthisSize = fileHeader->tocs[n].subtype;\n\tif (!bestSize || dist (thisSize, size) < dist (bestSize, size))\n\t{\n\t    bestSize = thisSize;\n\t    nsizes = 1;\n\t}\n\telse if (thisSize == bestSize)\n\t    nsizes++;\n    }\n    *nsizesp = nsizes;\n    return bestSize;\n}\n\nstatic int\n_XcursorFindImageToc (XcursorFileHeader\t*fileHeader,\n\t\t      XcursorDim\tsize,\n\t\t      int\t\tcount)\n{\n    int\t\t\ttoc;\n    XcursorDim\t\tthisSize;\n\n    if (!fileHeader)\n        return 0;\n\n    for (toc = 0; toc < fileHeader->ntoc; toc++)\n    {\n\tif (fileHeader->tocs[toc].type != XCURSOR_IMAGE_TYPE)\n\t    continue;\n\tthisSize = fileHeader->tocs[toc].subtype;\n\tif (thisSize != size)\n\t    continue;\n\tif (!count)\n\t    break;\n\tcount--;\n    }\n    if (toc == fileHeader->ntoc)\n\treturn -1;\n    return toc;\n}\n\nstatic XcursorImage *\n_XcursorReadImage (XcursorFile\t\t*file,\n\t\t   XcursorFileHeader\t*fileHeader,\n\t\t   int\t\t\ttoc)\n{\n    XcursorChunkHeader\tchunkHeader;\n    XcursorImage\thead;\n    XcursorImage\t*image;\n    int\t\t\tn;\n    XcursorPixel\t*p;\n\n    if (!file || !fileHeader)\n        return NULL;\n\n    if (!_XcursorFileReadChunkHeader (file, fileHeader, toc, &chunkHeader))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.width))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.height))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.xhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.yhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.delay))\n\treturn NULL;\n    /* sanity check data */\n    if (head.width >= 0x10000 || head.height > 0x10000)\n\treturn NULL;\n     if (!_XcursorReadUInt (file, &head.delay))\n \treturn NULL;\n     /* sanity check data */\n    if (head.width >= 0x10000 || head.height > 0x10000)\n \treturn NULL;\n     if (head.width == 0 || head.height == 0)\n \treturn NULL;\n\timage->version = chunkHeader.version;\n    image->size = chunkHeader.subtype;\n \n     /* Create the image and initialize it */\n     image = XcursorImageCreate (head.width, head.height);\n     if (chunkHeader.version < image->version)\n \timage->version = chunkHeader.version;\n     image->size = chunkHeader.subtype;\n\t{\n\t    XcursorImageDestroy (image);\n\t    return NULL;\n\t}\n\tp++;\n    }\n    return image;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long ContentEncoding::ParseEncryptionEntry(long long start, long long size,\n IMkvReader* pReader,\n ContentEncryption* encryption) {\n  assert(pReader);\n  assert(encryption);\n\n long long pos = start;\n const long long stop = start + size;\n\n while (pos < stop) {\n long long id, size;\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n if (status < 0) // error\n return status;\n\n if (id == 0x7E1) {\n      encryption->algo = UnserializeUInt(pReader, pos, size);\n if (encryption->algo != 5)\n\n         return E_FILE_FORMAT_INVALID;\n     } else if (id == 0x7E2) {\n      delete[] encryption -> key_id;\n       encryption->key_id = NULL;\n       encryption->key_id_len = 0;\n \n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      typedef unsigned char* buf_t;\n      const buf_t buf = new (std::nothrow) unsigned char[buflen];\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      encryption->key_id = buf;\n\n       encryption->key_id_len = buflen;\n     } else if (id == 0x7E3) {\n      delete[] encryption -> signature;\n       encryption->signature = NULL;\n       encryption->signature_len = 0;\n \n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      typedef unsigned char* buf_t;\n      const buf_t buf = new (std::nothrow) unsigned char[buflen];\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      encryption->signature = buf;\n\n       encryption->signature_len = buflen;\n     } else if (id == 0x7E4) {\n      delete[] encryption -> sig_key_id;\n       encryption->sig_key_id = NULL;\n       encryption->sig_key_id_len = 0;\n \n if (size <= 0)\n\n         return E_FILE_FORMAT_INVALID;\n \n       const size_t buflen = static_cast<size_t>(size);\n      typedef unsigned char* buf_t;\n      const buf_t buf = new (std::nothrow) unsigned char[buflen];\n       if (buf == NULL)\n         return -1;\n \n const int read_status =\n          pReader->Read(pos, static_cast<long>(buflen), buf);\n if (read_status) {\n delete[] buf;\n return status;\n }\n\n      encryption->sig_key_id = buf;\n      encryption->sig_key_id_len = buflen;\n } else if (id == 0x7E5) {\n      encryption->sig_algo = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x7E6) {\n      encryption->sig_hash_algo = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x7E7) {\n const long status = ParseContentEncAESSettingsEntry(\n          pos, size, pReader, &encryption->aes_settings);\n if (status)\n return status;\n\n     }\n \n     pos += size;  // consume payload\n    assert(pos <= stop);\n   }\n \n   return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "CancelPendingTask() {\n  filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                 MSG_ROUTING_NONE /* no plugin frame */);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j, bl;\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n     bl = ctx->cipher->block_size;\n     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n     if (i != 0) {\n        if (i + inl < bl) {\n             memcpy(&(ctx->buf[i]), in, inl);\n             ctx->buf_len += inl;\n             *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n            memcpy(&(ctx->buf[i]), in, j);\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            inl -= j;\n            in += j;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "pcf_get_encodings( FT_Stream  stream,\n                     PCF_Face   face )\n  {\n    FT_Error      error;\n    FT_Memory     memory = FT_FACE( face )->memory;\n    FT_ULong      format, size;\n    int           firstCol, lastCol;\n    int           firstRow, lastRow;\n    int           nencoding, encodingOffset;\n    int           i, j, k;\n    PCF_Encoding  encoding = NULL;\n\n\n    error = pcf_seek_to_table_type( stream,\n                                    face->toc.tables,\n                                    face->toc.count,\n                                    PCF_BDF_ENCODINGS,\n                                    &format,\n                                    &size );\n    if ( error )\n      return error;\n\n    error = FT_Stream_EnterFrame( stream, 14 );\n    if ( error )\n      return error;\n\n    format = FT_GET_ULONG_LE();\n\n    if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n    {\n      firstCol          = FT_GET_SHORT();\n      lastCol           = FT_GET_SHORT();\n      firstRow          = FT_GET_SHORT();\n      lastRow           = FT_GET_SHORT();\n      face->defaultChar = FT_GET_SHORT();\n    }\n    else\n    {\n      firstCol          = FT_GET_SHORT_LE();\n      lastCol           = FT_GET_SHORT_LE();\n      firstRow          = FT_GET_SHORT_LE();\n      lastRow           = FT_GET_SHORT_LE();\n      face->defaultChar = FT_GET_SHORT_LE();\n    }\n\n    FT_Stream_ExitFrame( stream );\n\n     if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )\n       return FT_THROW( Invalid_File_Format );\n \n     FT_TRACE4(( \"pdf_get_encodings:\\n\" ));\n \n     FT_TRACE4(( \"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\\n\",\n      goto Bail;\n\n    k = 0;\n    for ( i = firstRow; i <= lastRow; i++ )\n    {\n      for ( j = firstCol; j <= lastCol; j++ )\n      {\n        if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n          encodingOffset = FT_GET_SHORT();\n        else\n          encodingOffset = FT_GET_SHORT_LE();\n\n        if ( encodingOffset != -1 )\n        {\n          encoding[k].enc   = i * 256 + j;\n          encoding[k].glyph = (FT_Short)encodingOffset;\n\n          FT_TRACE5(( \"  code %d (0x%04X): idx %d\\n\",\n                      encoding[k].enc, encoding[k].enc, encoding[k].glyph ));\n\n          k++;\n        }\n      }\n    }\n    FT_Stream_ExitFrame( stream );\n\n    if ( FT_RENEW_ARRAY( encoding, nencoding, k ) )\n      goto Bail;\n\n    face->nencodings = k;\n    face->encodings  = encoding;\n\n    return error;\n\n  Bail:\n    FT_FREE( encoding );\n    return error;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "php_stream *php_stream_url_wrap_http_ex(php_stream_wrapper *wrapper, \n\t\tconst char *path, const char *mode, int options, char **opened_path, \n\t\tphp_stream_context *context, int redirect_max, int flags STREAMS_DC TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *stream = NULL;\n\tphp_url *resource = NULL;\n\tint use_ssl;\n\tint use_proxy = 0;\n\tchar *scratch = NULL;\n\tchar *tmp = NULL;\n\tchar *ua_str = NULL;\n\tzval **ua_zval = NULL, **tmpzval = NULL, *ssl_proxy_peer_name = NULL;\n\tint scratch_len = 0;\n\tint body = 0;\n\tchar location[HTTP_HEADER_BLOCK_SIZE];\n\tzval *response_header = NULL;\n\tint reqok = 0;\n\tchar *http_header_line = NULL;\n\tchar tmp_line[128];\n\tsize_t chunk_size = 0, file_size = 0;\n\tint eol_detect = 0;\n\tchar *transport_string, *errstr = NULL;\n\tint transport_len, have_header = 0, request_fulluri = 0, ignore_errors = 0;\n\tchar *protocol_version = NULL;\n\tint protocol_version_len = 3; /* Default: \"1.0\" */\n\tstruct timeval timeout;\n\tchar *user_headers = NULL;\n\tint header_init = ((flags & HTTP_WRAPPER_HEADER_INIT) != 0);\n\tint redirected = ((flags & HTTP_WRAPPER_REDIRECTED) != 0);\n\tint follow_location = 1;\n\tphp_stream_filter *transfer_encoding = NULL;\n\tint response_code;\n\n\ttmp_line[0] = '\\0';\n\n\tif (redirect_max < 1) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Redirection limit reached, aborting\");\n\t\treturn NULL;\n\t}\n\n\tresource = php_url_parse(path);\n\tif (resource == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (strncasecmp(resource->scheme, \"http\", sizeof(\"http\")) && strncasecmp(resource->scheme, \"https\", sizeof(\"https\"))) {\n\t\tif (!context ||\n\t\t\tphp_stream_context_get_option(context, wrapper->wops->label, \"proxy\", &tmpzval) == FAILURE ||\n\t\t\tZ_TYPE_PP(tmpzval) != IS_STRING ||\n\t\t\tZ_STRLEN_PP(tmpzval) <= 0) {\n\t\t\tphp_url_free(resource);\n\t\t\treturn php_stream_open_wrapper_ex(path, mode, REPORT_ERRORS, NULL, context);\n\t\t}\n\t\t/* Called from a non-http wrapper with http proxying requested (i.e. ftp) */\n\t\trequest_fulluri = 1;\n\t\tuse_ssl = 0;\n\t\tuse_proxy = 1;\n\n\t\ttransport_len = Z_STRLEN_PP(tmpzval);\n\t\ttransport_string = estrndup(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t} else {\n\t\t/* Normal http request (possibly with proxy) */\n\n\t\tif (strpbrk(mode, \"awx+\")) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP wrapper does not support writeable connections\");\n\t\t\tphp_url_free(resource);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuse_ssl = resource->scheme && (strlen(resource->scheme) > 4) && resource->scheme[4] == 's';\n\t\t/* choose default ports */\n\t\tif (use_ssl && resource->port == 0)\n\t\t\tresource->port = 443;\n\t\telse if (resource->port == 0)\n\t\t\tresource->port = 80;\n\n\t\tif (context &&\n\t\t\tphp_stream_context_get_option(context, wrapper->wops->label, \"proxy\", &tmpzval) == SUCCESS &&\n\t\t\tZ_TYPE_PP(tmpzval) == IS_STRING &&\n\t\t\tZ_STRLEN_PP(tmpzval) > 0) {\n\t\t\tuse_proxy = 1;\n\t\t\ttransport_len = Z_STRLEN_PP(tmpzval);\n\t\t\ttransport_string = estrndup(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t\t} else {\n\t\t\ttransport_len = spprintf(&transport_string, 0, \"%s://%s:%d\", use_ssl ? \"ssl\" : \"tcp\", resource->host, resource->port);\n\t\t}\n\t}\n\n\tif (context && php_stream_context_get_option(context, wrapper->wops->label, \"timeout\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_double_ex(tmpzval);\n\t\ttimeout.tv_sec = (time_t) Z_DVAL_PP(tmpzval);\n\t\ttimeout.tv_usec = (size_t) ((Z_DVAL_PP(tmpzval) - timeout.tv_sec) * 1000000);\n\t} else {\n\t\ttimeout.tv_sec = FG(default_socket_timeout);\n\t\ttimeout.tv_usec = 0;\n\t}\n\n\tstream = php_stream_xport_create(transport_string, transport_len, options,\n\t\t\tSTREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\n\t\t\tNULL, &timeout, context, &errstr, NULL);\n\n\tif (stream) {\n\t\tphp_stream_set_option(stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &timeout);\n\t}\n\n\tif (errstr) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"%s\", errstr);\n\t\tefree(errstr);\n\t\terrstr = NULL;\n\t}\n\n\tefree(transport_string);\n\n\tif (stream && use_proxy && use_ssl) {\n\t\tsmart_str header = {0};\n\n\t\t/* Set peer_name or name verification will try to use the proxy server name */\n\t\tif (!context || php_stream_context_get_option(context, \"ssl\", \"peer_name\", &tmpzval) == FAILURE) {\n\t\t\tMAKE_STD_ZVAL(ssl_proxy_peer_name);\n\t\t\tZVAL_STRING(ssl_proxy_peer_name, resource->host, 1);\n\t\t\tphp_stream_context_set_option(stream->context, \"ssl\", \"peer_name\", ssl_proxy_peer_name);\n\t\t}\n\n\t\tsmart_str_appendl(&header, \"CONNECT \", sizeof(\"CONNECT \")-1);\n\t\tsmart_str_appends(&header, resource->host);\n\t\tsmart_str_appendc(&header, ':');\n\t\tsmart_str_append_unsigned(&header, resource->port);\n\t\tsmart_str_appendl(&header, \" HTTP/1.0\\r\\n\", sizeof(\" HTTP/1.0\\r\\n\")-1);\n\n\t    /* check if we have Proxy-Authorization header */\n\t\tif (context && php_stream_context_get_option(context, \"http\", \"header\", &tmpzval) == SUCCESS) {\n\t\t\tchar *s, *p;\n\n\t\t\tif (Z_TYPE_PP(tmpzval) == IS_ARRAY) {\n\t\t\t\tHashPosition pos;\n\t\t\t\tzval **tmpheader = NULL;\n\n\t\t\t\tfor (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(tmpzval), &pos);\n\t\t\t\t\tSUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_PP(tmpzval), (void *)&tmpheader, &pos);\n\t\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_PP(tmpzval), &pos)) {\n\t\t\t\t\tif (Z_TYPE_PP(tmpheader) == IS_STRING) {\n\t\t\t\t\t\ts = Z_STRVAL_PP(tmpheader);\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\t\t\tp = s;\n\t\t\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts = p;\n\t\t\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t\t\t} while (*s != 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval)) {\n\t\t\t\ts = Z_STRVAL_PP(tmpzval);\n\t\t\t\tdo {\n\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\tp = s;\n\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts = p;\n\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t} while (*s != 0);\n\t\t\t}\n\t\t}\nfinish:\n\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\n\t\tif (php_stream_write(stream, header.c, header.len) != header.len) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Cannot connect to HTTPS server through proxy\");\n\t\t\tphp_stream_close(stream);\n\t\t\tstream = NULL;\n\t\t}\n \t \tsmart_str_free(&header);\n\n \t \tif (stream) {\n \t \t\tchar header_line[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t/* get response header */\n\t\t\twhile (php_stream_gets(stream, header_line, HTTP_HEADER_BLOCK_SIZE-1) != NULL) {\n\t\t\t\tif (header_line[0] == '\\n' ||\n\t\t\t\t    header_line[0] == '\\r' ||\n\t\t\t\t    header_line[0] == '\\0') {\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* enable SSL transport layer */\n\t\tif (stream) {\n\t\t\tif (php_stream_xport_crypto_setup(stream, STREAM_CRYPTO_METHOD_SSLv23_CLIENT, NULL TSRMLS_CC) < 0 ||\n\t\t\t    php_stream_xport_crypto_enable(stream, 1 TSRMLS_CC) < 0) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Cannot connect to HTTPS server through proxy\");\n\t\t\t\tphp_stream_close(stream);\n\t\t\t\tstream = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stream == NULL)\n\t\tgoto out;\n\n\t/* avoid buffering issues while reading header */\n\tif (options & STREAM_WILL_CAST)\n\t\tchunk_size = php_stream_set_chunk_size(stream, 1);\n\n\t/* avoid problems with auto-detecting when reading the headers -> the headers\n\t * are always in canonical \\r\\n format */\n\teol_detect = stream->flags & (PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\tstream->flags &= ~(PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\n\tphp_stream_context_set(stream, context);\n\n\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_CONNECT, NULL, 0);\n\n\tif (header_init && context && php_stream_context_get_option(context, \"http\", \"max_redirects\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_long_ex(tmpzval);\n\t\tredirect_max = Z_LVAL_PP(tmpzval);\n\t}\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"method\", &tmpzval) == SUCCESS) {\n\t\tif (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0) {\n\t\t\t/* As per the RFC, automatically redirected requests MUST NOT use other methods than\n\t\t\t * GET and HEAD unless it can be confirmed by the user */\n\t\t\tif (!redirected\n\t\t\t\t|| (Z_STRLEN_PP(tmpzval) == 3 && memcmp(\"GET\", Z_STRVAL_PP(tmpzval), 3) == 0)\n\t\t\t\t|| (Z_STRLEN_PP(tmpzval) == 4 && memcmp(\"HEAD\",Z_STRVAL_PP(tmpzval), 4) == 0)\n\t\t\t) {\n\t\t\t\tscratch_len = strlen(path) + 29 + Z_STRLEN_PP(tmpzval);\n\t\t\t\tscratch = emalloc(scratch_len);\n\t\t\t\tstrlcpy(scratch, Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval) + 1);\n\t\t\t\tstrncat(scratch, \" \", 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"protocol_version\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_double_ex(tmpzval);\n\t\tprotocol_version_len = spprintf(&protocol_version, 0, \"%.1F\", Z_DVAL_PP(tmpzval));\n\t}\n\n\tif (!scratch) {\n\t\tscratch_len = strlen(path) + 29 + protocol_version_len;\n\t\tscratch = emalloc(scratch_len);\n\t\tstrncpy(scratch, \"GET \", scratch_len);\n\t}\n\n\t/* Should we send the entire path in the request line, default to no. */\n\tif (!request_fulluri &&\n\t\tcontext &&\n\t\tphp_stream_context_get_option(context, \"http\", \"request_fulluri\", &tmpzval) == SUCCESS) {\n\t\tzval ztmp = **tmpzval;\n\n\t\tzval_copy_ctor(&ztmp);\n\t\tconvert_to_boolean(&ztmp);\n\t\trequest_fulluri = Z_BVAL(ztmp) ? 1 : 0;\n\t\tzval_dtor(&ztmp);\n\t}\n\n\tif (request_fulluri) {\n\t\t/* Ask for everything */\n\t\tstrcat(scratch, path);\n\t} else {\n\t\t/* Send the traditional /path/to/file?query_string */\n\n\t\t/* file */\n\t\tif (resource->path && *resource->path) {\n\t\t\tstrlcat(scratch, resource->path, scratch_len);\n\t\t} else {\n\t\t\tstrlcat(scratch, \"/\", scratch_len);\n\t\t}\n\n\t\t/* query string */\n\t\tif (resource->query) {\n\t\t\tstrlcat(scratch, \"?\", scratch_len);\n\t\t\tstrlcat(scratch, resource->query, scratch_len);\n\t\t}\n\t}\n\n\t/* protocol version we are speaking */\n\tif (protocol_version) {\n\t\tstrlcat(scratch, \" HTTP/\", scratch_len);\n\t\tstrlcat(scratch, protocol_version, scratch_len);\n\t\tstrlcat(scratch, \"\\r\\n\", scratch_len);\n\t} else {\n\t\tstrlcat(scratch, \" HTTP/1.0\\r\\n\", scratch_len);\n\t}\n\n\t/* send it */\n\tphp_stream_write(stream, scratch, strlen(scratch));\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"header\", &tmpzval) == SUCCESS) {\n\t\ttmp = NULL;\n\n\t\tif (Z_TYPE_PP(tmpzval) == IS_ARRAY) {\n\t\t\tHashPosition pos;\n\t\t\tzval **tmpheader = NULL;\n\t\t\tsmart_str tmpstr = {0};\n\n\t\t\tfor (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(tmpzval), &pos);\n\t\t\t\tSUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_PP(tmpzval), (void *)&tmpheader, &pos);\n\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_PP(tmpzval), &pos)\n\t\t\t) {\n\t\t\t\tif (Z_TYPE_PP(tmpheader) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&tmpstr, Z_STRVAL_PP(tmpheader), Z_STRLEN_PP(tmpheader));\n\t\t\t\t\tsmart_str_appendl(&tmpstr, \"\\r\\n\", sizeof(\"\\r\\n\") - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmart_str_0(&tmpstr);\n\t\t\t/* Remove newlines and spaces from start and end. there's at least one extra \\r\\n at the end that needs to go. */\n\t\t\tif (tmpstr.c) {\n\t\t\t\ttmp = php_trim(tmpstr.c, strlen(tmpstr.c), NULL, 0, NULL, 3 TSRMLS_CC);\n\t\t\t\tsmart_str_free(&tmpstr);\n\t\t\t}\n\t\t}\n\t\tif (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval)) {\n\t\t\t/* Remove newlines and spaces from start and end php_trim will estrndup() */\n\t\t\ttmp = php_trim(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval), NULL, 0, NULL, 3 TSRMLS_CC);\n\t\t}\n\t\tif (tmp && strlen(tmp) > 0) {\n\t\t\tchar *s;\n\n\t\t\tuser_headers = estrdup(tmp);\n\n\t\t\t/* Make lowercase for easy comparison against 'standard' headers */\n\t\t\tphp_strtolower(tmp, strlen(tmp));\n\n\t\t\tif (!header_init) {\n\t\t\t\t/* strip POST headers on redirect */\n\t\t\t\tstrip_header(user_headers, tmp, \"content-length:\");\n\t\t\t\tstrip_header(user_headers, tmp, \"content-type:\");\n\t\t\t}\n\n\t\t\tif ((s = strstr(tmp, \"user-agent:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_USER_AGENT;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"host:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_HOST;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"from:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_FROM;\n\t\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"authorization:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_AUTH;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"content-length:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"content-type:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_TYPE;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"connection:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' || \n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONNECTION;\n\t\t\t}\n\t\t\t/* remove Proxy-Authorization header */\n\t\t\tif (use_proxy && use_ssl && (s = strstr(tmp, \"proxy-authorization:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\tchar *p = s + sizeof(\"proxy-authorization:\") - 1;\n\n\t\t\t\twhile (s > tmp && (*(s-1) == ' ' || *(s-1) == '\\t')) s--;\n\t\t\t\twhile (*p != 0 && *p != '\\r' && *p != '\\n') p++;\n\t\t\t\twhile (*p == '\\r' || *p == '\\n') p++;\n\t\t\t\tif (*p == 0) {\n\t\t\t\t\tif (s == tmp) {\n\t\t\t\t\t\tefree(user_headers);\n\t\t\t\t\t\tuser_headers = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (s > tmp && (*(s-1) == '\\r' || *(s-1) == '\\n')) s--;\n\t\t\t\t\t\tuser_headers[s - tmp] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmemmove(user_headers + (s - tmp), user_headers + (p - tmp), strlen(p) + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (tmp) {\n\t\t\tefree(tmp);\n\t\t}\n\t}\n\n\t/* auth header if it was specified */\n\tif (((have_header & HTTP_HEADER_AUTH) == 0) && resource->user) {\n\t\t/* decode the strings first */\n\t\tphp_url_decode(resource->user, strlen(resource->user));\n\n\t\t/* scratch is large enough, since it was made large enough for the whole URL */\n\t\tstrcpy(scratch, resource->user);\n\t\tstrcat(scratch, \":\");\n\n\t\t/* Note: password is optional! */\n\t\tif (resource->pass) {\n\t\t\tphp_url_decode(resource->pass, strlen(resource->pass));\n\t\t\tstrcat(scratch, resource->pass);\n\t\t}\n\n\t\ttmp = (char*)php_base64_encode((unsigned char*)scratch, strlen(scratch), NULL);\n\n\t\tif (snprintf(scratch, scratch_len, \"Authorization: Basic %s\\r\\n\", tmp) > 0) {\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_AUTH_REQUIRED, NULL, 0);\n\t\t}\n\n\t\tefree(tmp);\n\t\ttmp = NULL;\n\t}\n\n\t/* if the user has configured who they are, send a From: line */\n\tif (((have_header & HTTP_HEADER_FROM) == 0) && FG(from_address)) {\n\t\tif (snprintf(scratch, scratch_len, \"From: %s\\r\\n\", FG(from_address)) > 0)\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t}\n\n\t/* Send Host: header so name-based virtual hosts work */\n\tif ((have_header & HTTP_HEADER_HOST) == 0) {\n\t\tif ((use_ssl && resource->port != 443 && resource->port != 0) ||\n\t\t\t(!use_ssl && resource->port != 80 && resource->port != 0)) {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s:%i\\r\\n\", resource->host, resource->port) > 0)\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t} else {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s\\r\\n\", resource->host) > 0) {\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send a Connection: close header to avoid hanging when the server\n\t * interprets the RFC literally and establishes a keep-alive connection,\n\t * unless the user specifically requests something else by specifying a\n\t * Connection header in the context options. Send that header even for\n\t * HTTP/1.0 to avoid issues when the server respond with a HTTP/1.1\n\t * keep-alive response, which is the preferred response type. */\n\tif ((have_header & HTTP_HEADER_CONNECTION) == 0) {\n\t\tphp_stream_write_string(stream, \"Connection: close\\r\\n\");\n\t}\n\n\tif (context &&\n\t    php_stream_context_get_option(context, \"http\", \"user_agent\", &ua_zval) == SUCCESS &&\n\t\tZ_TYPE_PP(ua_zval) == IS_STRING) {\n\t\tua_str = Z_STRVAL_PP(ua_zval);\n\t} else if (FG(user_agent)) {\n\t\tua_str = FG(user_agent);\n\t}\n\n\tif (((have_header & HTTP_HEADER_USER_AGENT) == 0) && ua_str) {\n#define _UA_HEADER \"User-Agent: %s\\r\\n\"\n\t\tchar *ua;\n\t\tsize_t ua_len;\n\n\t\tua_len = sizeof(_UA_HEADER) + strlen(ua_str);\n\n\t\t/* ensure the header is only sent if user_agent is not blank */\n\t\tif (ua_len > sizeof(_UA_HEADER)) {\n\t\t\tua = emalloc(ua_len + 1);\n\t\t\tif ((ua_len = slprintf(ua, ua_len, _UA_HEADER, ua_str)) > 0) {\n\t\t\t\tua[ua_len] = 0;\n\t\t\t\tphp_stream_write(stream, ua, ua_len);\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot construct User-agent header\");\n\t\t\t}\n\n\t\t\tif (ua) {\n\t\t\t\tefree(ua);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (user_headers) {\n\t\t/* A bit weird, but some servers require that Content-Length be sent prior to Content-Type for POST\n\t\t * see bug #44603 for details. Since Content-Type maybe part of user's headers we need to do this check first.\n\t\t */\n\t\tif (\n\t\t\t\theader_init &&\n\t\t\t\tcontext &&\n\t\t\t\t!(have_header & HTTP_HEADER_CONTENT_LENGTH) &&\n\t\t\t\tphp_stream_context_get_option(context, \"http\", \"content\", &tmpzval) == SUCCESS &&\n\t\t\t\tZ_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0\n\t\t) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_PP(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t\thave_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t}\n\n\t\tphp_stream_write(stream, user_headers, strlen(user_headers));\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tefree(user_headers);\n\t}\n\n\t/* Request content, such as for POST requests */\n\tif (header_init && context &&\n\t\tphp_stream_context_get_option(context, \"http\", \"content\", &tmpzval) == SUCCESS &&\n\t\tZ_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0) {\n\t\tif (!(have_header & HTTP_HEADER_CONTENT_LENGTH)) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_PP(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t}\n\t\tif (!(have_header & HTTP_HEADER_TYPE)) {\n\t\t\tphp_stream_write(stream, \"Content-Type: application/x-www-form-urlencoded\\r\\n\",\n\t\t\t\tsizeof(\"Content-Type: application/x-www-form-urlencoded\\r\\n\") - 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Content-type not specified assuming application/x-www-form-urlencoded\");\n\t\t}\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tphp_stream_write(stream, Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t} else {\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t}\n\n\tlocation[0] = '\\0';\n\n\tif (!EG(active_symbol_table)) {\n\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t}\n\n\tif (header_init) {\n\t\tzval *ztmp;\n\t\tMAKE_STD_ZVAL(ztmp);\n\t\tarray_init(ztmp);\n\t\tZEND_SET_SYMBOL(EG(active_symbol_table), \"http_response_header\", ztmp);\n\t}\n\n\t{\n\t\tzval **rh;\n\t\tif(zend_hash_find(EG(active_symbol_table), \"http_response_header\", sizeof(\"http_response_header\"), (void **) &rh) != SUCCESS || Z_TYPE_PP(rh) != IS_ARRAY) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed, http_response_header overwritten\");\n\t\t\tgoto out;\n\t\t}\n\t\tresponse_header = *rh;\n\t\tZ_ADDREF_P(response_header);\n\t}\n\n\tif (!php_stream_eof(stream)) {\n\t\tsize_t tmp_line_len;\n\t\t/* get response header */\n\n\t\tif (php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL) {\n\t\t\tzval *http_response;\n\n\t\t\tif (tmp_line_len > 9) {\n\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t} else {\n\t\t\t\tresponse_code = 0;\n\t\t\t}\n\t\t\tif (context && SUCCESS==php_stream_context_get_option(context, \"http\", \"ignore_errors\", &tmpzval)) {\n\t\t\t\tignore_errors = zend_is_true(*tmpzval);\n\t\t\t}\n\t\t\t/* when we request only the header, don't fail even on error codes */\n\t\t\tif ((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) {\n\t\t\t\treqok = 1;\n\t\t\t}\n\n\t\t\t/* status codes of 1xx are \"informational\", and will be followed by a real response\n\t\t\t * e.g \"100 Continue\". RFC 7231 states that unexpected 1xx status MUST be parsed,\n\t\t\t * and MAY be ignored. As such, we need to skip ahead to the \"real\" status*/\n\t\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t\t/* consume lines until we find a line starting 'HTTP/1' */\n\t\t\t\twhile (\n\t\t\t\t\t!php_stream_eof(stream)\n\t\t\t\t\t&& php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL\n\t\t\t\t\t&& ( tmp_line_len < sizeof(\"HTTP/1\") - 1 || strncasecmp(tmp_line, \"HTTP/1\", sizeof(\"HTTP/1\") - 1) )\n\t\t\t\t);\n\n\t\t\t\tif (tmp_line_len > 9) {\n\t\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t\t} else {\n\t\t\t\t\tresponse_code = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* all status codes in the 2xx range are defined by the specification as successful;\n\t\t\t * all status codes in the 3xx range are for redirection, and so also should never\n\t\t\t * fail */\n\t\t\tif (response_code >= 200 && response_code < 400) {\n\t\t\t\treqok = 1;\n\t\t\t} else {\n\t\t\t\tswitch(response_code) {\n\t\t\t\t\tcase 403:\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_AUTH_RESULT,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* safety net in the event tmp_line == NULL */\n\t\t\t\t\t\tif (!tmp_line_len) {\n\t\t\t\t\t\t\ttmp_line[0] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_FAILURE,\n \t\t\t\t\t\t\t\ttmp_line, response_code);\n \t\t\t\t}\n \t\t\t}\n\t\t\tif (tmp_line[tmp_line_len - 1] == '\\n') {\n \t\t\t\t--tmp_line_len;\n\t\t\t\tif (tmp_line[tmp_line_len - 1] == '\\r') {\n \t\t\t\t\t--tmp_line_len;\n \t\t\t\t}\n \t\t\t}\n\t\t\tMAKE_STD_ZVAL(http_response);\n\t\t\tZVAL_STRINGL(http_response, tmp_line, tmp_line_len, 1);\n\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(response_header), &http_response, sizeof(zval *), NULL);\n\t\t}\n\t} else {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed, unexpected end of socket!\");\n\t\tgoto out;\n\t}\n\n\t/* read past HTTP headers */\n\n\thttp_header_line = emalloc(HTTP_HEADER_BLOCK_SIZE);\n\n\twhile (!body && !php_stream_eof(stream)) {\n\t\tsize_t http_header_line_length;\n\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) && *http_header_line != '\\n' && *http_header_line != '\\r') {\n\t\t\tchar *e = http_header_line + http_header_line_length - 1;\n\t\t\tif (*e != '\\n') {\n\t\t\t\tdo { /* partial header */\n\t\t\t\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) == NULL) {\n\t\t\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Failed to read HTTP headers\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\te = http_header_line + http_header_line_length - 1;\n\t\t\t\t} while (*e != '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (*e == '\\n' || *e == '\\r') {\n\t\t\t\te--;\n\t\t\t}\n\t\t\thttp_header_line_length = e - http_header_line + 1;\n\t\t\thttp_header_line[http_header_line_length] = '\\0';\n\n\t\t\tif (!strncasecmp(http_header_line, \"Location: \", 10)) {\n\t\t\t\tif (context && php_stream_context_get_option(context, \"http\", \"follow_location\", &tmpzval) == SUCCESS) {\n\t\t\t\t\tSEPARATE_ZVAL(tmpzval);\n\t\t\t\t\tconvert_to_long_ex(tmpzval);\n\t\t\t\t\tfollow_location = Z_LVAL_PP(tmpzval);\n\t\t\t\t} else if (!(response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code)) {\n\t\t\t\t\t/* we shouldn't redirect automatically\n\t\t\t\t\tif follow_location isn't set and response_code not in (300, 301, 302, 303 and 307)\n\t\t\t\t\tsee http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.1\n\t\t\t\t\tRFC 7238 defines 308: http://tools.ietf.org/html/rfc7238 */\n\t\t\t\t\tfollow_location = 0;\n\t\t\t\t}\n\t\t\t\tstrlcpy(location, http_header_line + 10, sizeof(location));\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Type: \", 14)) {\n\t\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_MIME_TYPE_IS, http_header_line + 14, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Length: \", 16)) {\n\t\t\t\tfile_size = atoi(http_header_line + 16);\n\t\t\t\tphp_stream_notify_file_size(context, file_size, http_header_line, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Transfer-Encoding: chunked\", sizeof(\"Transfer-Encoding: chunked\"))) {\n\n\t\t\t\t/* create filter to decode response body */\n\t\t\t\tif (!(options & STREAM_ONLY_GET_HEADERS)) {\n\t\t\t\t\tlong decode = 1;\n\n\t\t\t\t\tif (context && php_stream_context_get_option(context, \"http\", \"auto_decode\", &tmpzval) == SUCCESS) {\n\t\t\t\t\t\tSEPARATE_ZVAL(tmpzval);\n\t\t\t\t\t\tconvert_to_boolean(*tmpzval);\n\t\t\t\t\t\tdecode = Z_LVAL_PP(tmpzval);\n\t\t\t\t\t}\n\t\t\t\t\tif (decode) {\n\t\t\t\t\t\ttransfer_encoding = php_stream_filter_create(\"dechunk\", NULL, php_stream_is_persistent(stream) TSRMLS_CC);\n\t\t\t\t\t\tif (transfer_encoding) {\n\t\t\t\t\t\t\t/* don't store transfer-encodeing header */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (http_header_line[0] == '\\0') {\n\t\t\t\tbody = 1;\n\t\t\t} else {\n\t\t\t\tzval *http_header;\n\n\t\t\t\tMAKE_STD_ZVAL(http_header);\n\n\t\t\t\tZVAL_STRINGL(http_header, http_header_line, http_header_line_length, 1);\n\n\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(response_header), &http_header, sizeof(zval *), NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!reqok || (location[0] != '\\0' && follow_location)) {\n\t\tif (!follow_location || (((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) && redirect_max <= 1)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (location[0] != '\\0')\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_REDIRECTED, location, 0);\n\n\t\tphp_stream_close(stream);\n\t\tstream = NULL;\n\n\t\tif (location[0] != '\\0') {\n\n\t\t\tchar new_path[HTTP_HEADER_BLOCK_SIZE];\n\t\t\tchar loc_path[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t*new_path='\\0';\n\t\t\tif (strlen(location)<8 || (strncasecmp(location, \"http://\", sizeof(\"http://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"https://\", sizeof(\"https://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftp://\", sizeof(\"ftp://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftps://\", sizeof(\"ftps://\")-1)))\n\t\t\t{\n\t\t\t\tif (*location != '/') {\n\t\t\t\t\tif (*(location+1) != '\\0' && resource->path) {\n\t\t\t\t\t\tchar *s = strrchr(resource->path, '/');\n\t\t\t\t\t\tif (!s) {\n\t\t\t\t\t\t\ts = resource->path;\n\t\t\t\t\t\t\tif (!s[0]) {\n\t\t\t\t\t\t\t\tefree(s);\n\t\t\t\t\t\t\t\ts = resource->path = estrdup(\"/\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t*s = '/';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[1] = '\\0';\n\t\t\t\t\t\tif (resource->path && *(resource->path) == '/' && *(resource->path + 1) == '\\0') {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s%s\", resource->path, location);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s/%s\", resource->path, location);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"/%s\", location);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(loc_path, location, sizeof(loc_path));\n\t\t\t\t}\n\t\t\t\tif ((use_ssl && resource->port != 443) || (!use_ssl && resource->port != 80)) {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s:%d%s\", resource->scheme, resource->host, resource->port, loc_path);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s%s\", resource->scheme, resource->host, loc_path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(new_path, location, sizeof(new_path));\n\t\t\t}\n\n\t\t\tphp_url_free(resource);\n\t\t\t/* check for invalid redirection URLs */\n\t\t\tif ((resource = php_url_parse(new_path)) == NULL) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Invalid redirect URL! %s\", new_path);\n\t\t\t\tgoto out;\n\t\t\t}\n\n#define CHECK_FOR_CNTRL_CHARS(val) { \\\n\tif (val) { \\\n\t\tunsigned char *s, *e; \\\n\t\tint l; \\\n\t\tl = php_url_decode(val, strlen(val)); \\\n\t\ts = (unsigned char*)val; e = s + l; \\\n\t\twhile (s < e) { \\\n\t\t\tif (iscntrl(*s)) { \\\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Invalid redirect URL! %s\", new_path); \\\n\t\t\t\tgoto out; \\\n\t\t\t} \\\n\t\t\ts++; \\\n\t\t} \\\n\t} \\\n}\n\t\t\t/* check for control characters in login, password & path */\n\t\t\tif (strncasecmp(new_path, \"http://\", sizeof(\"http://\") - 1) || strncasecmp(new_path, \"https://\", sizeof(\"https://\") - 1)) {\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->user)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->pass)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->path)\n\t\t\t}\n\t\t\tstream = php_stream_url_wrap_http_ex(wrapper, new_path, mode, options, opened_path, context, --redirect_max, HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed! %s\", tmp_line);\n\t\t}\n\t}\nout:\n\tif (protocol_version) {\n\t\tefree(protocol_version);\n\t}\n\n\tif (http_header_line) {\n\t\tefree(http_header_line);\n\t}\n\n\tif (scratch) {\n\t\tefree(scratch);\n\t}\n\n\tif (resource) {\n\t\tphp_url_free(resource);\n\t}\n\n\tif (stream) {\n\t\tif (header_init) {\n\t\t\tstream->wrapperdata = response_header;\n\t\t} else {\n\t\t\tif(response_header) {\n\t\t\t\tZ_DELREF_P(response_header);\n\t\t\t}\n\t\t}\n\t\tphp_stream_notify_progress_init(context, 0, file_size);\n\n\t\t/* Restore original chunk size now that we're done with headers */\n\t\tif (options & STREAM_WILL_CAST)\n\t\t\tphp_stream_set_chunk_size(stream, chunk_size);\n\n\t\t/* restore the users auto-detect-line-endings setting */\n\t\tstream->flags |= eol_detect;\n\n\t\t/* as far as streams are concerned, we are now at the start of\n\t\t * the stream */\n\t\tstream->position = 0;\n\n\t\t/* restore mode */\n\t\tstrlcpy(stream->mode, mode, sizeof(stream->mode));\n\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_append(&stream->readfilters, transfer_encoding);\n\t\t}\n\t} else {\n\t\tif(response_header) {\n\t\t\tZ_DELREF_P(response_header);\n\t\t}\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_free(transfer_encoding TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn stream;\n}\n/* }}} */"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static sent_status_t send_data_to_app(int fd, BT_HDR *p_buf) {\n\n   if (p_buf->len == 0)\n     return SENT_ALL;\n \n  ssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);\n \n   if (sent == -1) {\n     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\n return SENT_NONE;\n    LOG_ERROR(\"%s error writing RFCOMM data back to app: %s\", __func__, strerror(errno));\n return SENT_FAILED;\n }\n\n if (sent == 0)\n return SENT_FAILED;\n\n if (sent == p_buf->len)\n return SENT_ALL;\n\n  p_buf->offset += sent;\n  p_buf->len -= sent;\n return SENT_PARTIAL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "WORD32 ih264d_parse_islice_data_cavlc(dec_struct_t * ps_dec,\n dec_slice_params_t * ps_slice,\n                                      UWORD16 u2_first_mb_in_slice)\n{\n    UWORD8 uc_more_data_flag;\n    UWORD8 u1_num_mbs, u1_mb_idx;\n dec_mb_info_t *ps_cur_mb_info;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    WORD16 i2_cur_mb_addr;\n    UWORD8 u1_mbaff;\n    UWORD8 u1_num_mbs_next, u1_end_of_row, u1_tfr_n_mb;\n    WORD32 ret = OK;\n\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n\n /* initializations */\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    u1_num_mbs = u1_mb_idx;\n\n    uc_more_data_flag = 1;\n    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;\n\n do\n {\n        UWORD8 u1_mb_type;\n\n        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n {\n            ret = ERROR_MB_ADDRESS_T;\n break;\n }\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n /***************************************************************/\n /* Get the required information for decoding of MB             */\n /* mb_x, mb_y , neighbour availablity,                         */\n /***************************************************************/\n        ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 0);\n\n /***************************************************************/\n /* Set the deblocking parameters for this MB                   */\n /***************************************************************/\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n\n        ps_cur_deblk_mb->u1_mb_type = ps_cur_deblk_mb->u1_mb_type | D_INTRA_MB;\n\n /**************************************************************/\n /* Macroblock Layer Begins, Decode the u1_mb_type                */\n /**************************************************************/\n {\n            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;\n            UWORD32 u4_word, u4_ldz, u4_temp;\n\n /***************************************************************/\n /* Find leading zeros in next 32 bits                          */\n /***************************************************************/\n            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);\n            u4_ldz = CLZ(u4_word);\n /* Flush the ps_bitstrm */\n            u4_bitstream_offset += (u4_ldz + 1);\n /* Read the suffix from the ps_bitstrm */\n            u4_word = 0;\n if(u4_ldz)\n                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,\n                        u4_ldz);\n *pu4_bitstrm_ofst = u4_bitstream_offset;\n            u4_temp = ((1 << u4_ldz) + u4_word - 1);\n if(u4_temp > 25)\n return ERROR_MB_TYPE;\n            u1_mb_type = u4_temp;\n\n }\n        ps_cur_mb_info->u1_mb_type = u1_mb_type;\n        COPYTHECONTEXT(\"u1_mb_type\", u1_mb_type);\n\n /**************************************************************/\n /* Parse Macroblock data                                      */\n /**************************************************************/\n if(25 == u1_mb_type)\n {\n /* I_PCM_MB */\n            ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;\n            ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);\n if(ret != OK)\n return ret;\n            ps_cur_deblk_mb->u1_mb_qp = 0;\n }\n else\n {\n            ret = ih264d_parse_imb_cavlc(ps_dec, ps_cur_mb_info, u1_num_mbs, u1_mb_type);\n if(ret != OK)\n return ret;\n            ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n }\n\n if(u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n /**************************************************************/\n /* Get next Macroblock address                                */\n /**************************************************************/\n\n        i2_cur_mb_addr++;\n        uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);\n\n /* Store the colocated information */\n {\n mv_pred_t *ps_mv_nmb_start = ps_dec->ps_mv_cur + (u1_num_mbs << 4);\n\n mv_pred_t s_mvPred =\n {\n { 0, 0, 0, 0 },\n { -1, -1 }, 0, 0};\n            ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0,\n (UWORD8)(ps_dec->u1_cur_mb_fld_dec_flag << 1), 4,\n 4);\n }\n\n /*if num _cores is set to 3,compute bs will be done in another thread*/\n if(ps_dec->u4_num_cores < 3)\n {\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n                ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info,\n\n                                      (UWORD16)(u1_num_mbs >> u1_mbaff));\n         }\n         u1_num_mbs++;\n        ps_dec->u2_total_mbs_coded++;\n \n         /****************************************************************/\n         /* Check for End Of Row                                         */\n /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || (!uc_more_data_flag);\n        ps_cur_mb_info->u1_end_of_slice = (!uc_more_data_flag);\n\n /*H264_DEC_DEBUG_PRINT(\"Pic: %d Mb_X=%d Mb_Y=%d\",\n         ps_slice->i4_poc >> ps_slice->u1_field_pic_flag,\n         ps_dec->u2_mbx,ps_dec->u2_mby + (1 - ps_cur_mb_info->u1_topmb));\n         H264_DEC_DEBUG_PRINT(\"u1_tfr_n_mb || (!uc_more_data_flag): %d\", u1_tfr_n_mb || (!uc_more_data_flag));*/\n if(u1_tfr_n_mb || (!uc_more_data_flag))\n {\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n\n                                             u1_num_mbs_next, u1_tfr_n_mb,\n                                             u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n\n }\n }\n while(uc_more_data_flag);\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n\n - (u2_first_mb_in_slice << u1_mbaff);\n\n return ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool BitReaderCore::ReadBitsInternal(int num_bits, uint64_t* out) {\n  DCHECK_GE(num_bits, 0);\n\n  if (num_bits == 0) {\n    *out = 0;\n    return true;\n  }\n\n  if (num_bits > nbits_ && !Refill(num_bits)) {\n     nbits_ = 0;\n     reg_ = 0;\n     return false;\n   }\n \n  bits_read_ += num_bits;\n\n  if (num_bits == kRegWidthInBits) {\n    *out = reg_;\n    reg_ = 0;\n    nbits_ = 0;\n    return true;\n  }\n\n  *out = reg_ >> (kRegWidthInBits - num_bits);\n  reg_ <<= num_bits;\n  nbits_ -= num_bits;\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void SyncBackendHost::Core::DoInitialize(const DoInitializeOptions& options) {\n  DCHECK(!sync_loop_);\n  sync_loop_ = options.sync_loop;\n  DCHECK(sync_loop_);\n\n  if (options.delete_sync_data_folder) {\n    DeleteSyncDataFolder();\n  }\n\n  bool success = file_util::CreateDirectory(sync_data_folder_path_);\n  DCHECK(success);\n\n  DCHECK(!registrar_);\n  registrar_ = options.registrar;\n  DCHECK(registrar_);\n\n  sync_manager_.reset(new sync_api::SyncManager(name_));\n  sync_manager_->AddObserver(this);\n  success = sync_manager_->Init(\n      sync_data_folder_path_,\n      options.event_handler,\n      options.service_url.host() + options.service_url.path(),\n      options.service_url.EffectiveIntPort(),\n      options.service_url.SchemeIsSecure(),\n      BrowserThread::GetBlockingPool(),\n      options.make_http_bridge_factory_fn.Run(),\n      options.registrar /* as ModelSafeWorkerRegistrar */,\n      options.extensions_activity_monitor,\n       options.registrar /* as SyncManager::ChangeDelegate */,\n       MakeUserAgentForSyncApi(),\n       options.credentials,\n      true,\n       new BridgedSyncNotifier(\n           options.chrome_sync_notification_bridge,\n           options.sync_notifier_factory->CreateSyncNotifier()),\n      options.restored_key_for_bootstrapping,\n      options.testing_mode,\n      &encryptor_,\n      options.unrecoverable_error_handler,\n      options.report_unrecoverable_error_function);\n  LOG_IF(ERROR, !success) << \"Syncapi initialization failed!\";\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kSyncThrowUnrecoverableError)) {\n    sync_manager_->ThrowUnrecoverableError();\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void lsi_execute_script(LSIState *s)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    uint32_t insn;\n    uint32_t addr, addr_high;\n    int opcode;\n    int insn_processed = 0;\n\n    s->istat1 |= LSI_ISTAT1_SRUN;\nagain:\n \n     s->istat1 |= LSI_ISTAT1_SRUN;\n again:\n    insn_processed++;\n     insn = read_dword(s, s->dsp);\n     if (!insn) {\n         /* If we receive an empty opcode increment the DSP by 4 bytes\n        s->dbc = insn & 0xffffff;\n        s->rbc = s->dbc;\n        /* ??? Set ESA.  */\n        s->ia = s->dsp - 8;\n        if (insn & (1 << 29)) {\n            /* Indirect addressing.  */\n            addr = read_dword(s, addr);\n        } else if (insn & (1 << 28)) {\n            uint32_t buf[2];\n            int32_t offset;\n            /* Table indirect addressing.  */\n\n            /* 32-bit Table indirect */\n            offset = sextract32(addr, 0, 24);\n            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);\n            /* byte count is stored in bits 0:23 only */\n            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;\n            s->rbc = s->dbc;\n            addr = cpu_to_le32(buf[1]);\n\n            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of\n             * table, bits [31:24] */\n            if (lsi_dma_40bit(s))\n                addr_high = cpu_to_le32(buf[0]) >> 24;\n            else if (lsi_dma_ti64bit(s)) {\n                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;\n                switch (selector) {\n                case 0 ... 0x0f:\n                    /* offset index into scratch registers since\n                     * TI64 mode can use registers C to R */\n                    addr_high = s->scratch[2 + selector];\n                    break;\n                case 0x10:\n                    addr_high = s->mmrs;\n                    break;\n                case 0x11:\n                    addr_high = s->mmws;\n                    break;\n                case 0x12:\n                    addr_high = s->sfs;\n                    break;\n                case 0x13:\n                    addr_high = s->drs;\n                    break;\n                case 0x14:\n                    addr_high = s->sbms;\n                    break;\n                case 0x15:\n                    addr_high = s->dbms;\n                    break;\n                default:\n                    qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Illegal selector specified (0x%x > 0x15) \"\n                          \"for 64-bit DMA block move\", selector);\n                    break;\n                }\n            }\n        } else if (lsi_dma_64bit(s)) {\n            /* fetch a 3rd dword if 64-bit direct move is enabled and\n               only if we're not doing table indirect or indirect addressing */\n            s->dbms = read_dword(s, s->dsp);\n            s->dsp += 4;\n            s->ia = s->dsp - 12;\n        }\n        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\n            trace_lsi_execute_script_blockmove_badphase(\n                    scsi_phase_name(s->sstat1),\n                    scsi_phase_name(insn >> 24));\n            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\n            break;\n        }\n        s->dnad = addr;\n        s->dnad64 = addr_high;\n        switch (s->sstat1 & 0x7) {\n        case PHASE_DO:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 1);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_DI:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 0);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_CMD:\n            lsi_do_command(s);\n            break;\n        case PHASE_ST:\n            lsi_do_status(s);\n            break;\n        case PHASE_MO:\n            lsi_do_msgout(s);\n            break;\n        case PHASE_MI:\n            lsi_do_msgin(s);\n            break;\n        default:\n            qemu_log_mask(LOG_UNIMP, \"lsi_scsi: Unimplemented phase %s\\n\",\n                          scsi_phase_name(s->sstat1));\n        }\n        s->dfifo = s->dbc & 0xff;\n        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\n        s->sbc = s->dbc;\n        s->rbc -= s->dbc;\n        s->ua = addr + s->dbc;\n        break;\n\n    case 1: /* IO or Read/Write instruction.  */\n        opcode = (insn >> 27) & 7;\n        if (opcode < 5) {\n            uint32_t id;\n\n            if (insn & (1 << 25)) {\n                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));\n            } else {\n                id = insn;\n            }\n            id = (id >> 16) & 0xf;\n            if (insn & (1 << 26)) {\n                addr = s->dsp + sextract32(addr, 0, 24);\n            }\n            s->dnad = addr;\n            switch (opcode) {\n            case 0: /* Select */\n                s->sdid = id;\n                if (s->scntl1 & LSI_SCNTL1_CON) {\n                    trace_lsi_execute_script_io_alreadyreselected();\n                    s->dsp = s->dnad;\n                    break;\n                }\n                s->sstat0 |= LSI_SSTAT0_WOA;\n                s->scntl1 &= ~LSI_SCNTL1_IARB;\n                if (!scsi_device_find(&s->bus, 0, id, 0)) {\n                    lsi_bad_selection(s, id);\n                    break;\n                }\n                trace_lsi_execute_script_io_selected(id,\n                                             insn & (1 << 3) ? \" ATN\" : \"\");\n                /* ??? Linux drivers compain when this is set.  Maybe\n                   it only applies in low-level mode (unimplemented).\n                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */\n                s->select_tag = id << 8;\n                s->scntl1 |= LSI_SCNTL1_CON;\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                }\n                s->sbcl |= LSI_SBCL_BSY;\n                lsi_set_phase(s, PHASE_MO);\n                s->waiting = LSI_NOWAIT;\n                break;\n            case 1: /* Disconnect */\n                trace_lsi_execute_script_io_disconnect();\n                s->scntl1 &= ~LSI_SCNTL1_CON;\n                /* FIXME: this is not entirely correct; the target need not ask\n                 * for reselection until it has to send data, while here we force a\n                 * reselection as soon as the bus is free.  The correct flow would\n                 * reselect before lsi_transfer_data and disconnect as soon as\n                 * DMA ends.\n                 */\n                if (!s->current) {\n                    lsi_request *p = get_pending_req(s);\n                    if (p) {\n                        lsi_reselect(s, p);\n                    }\n                }\n                break;\n            case 2: /* Wait Reselect */\n                if (s->istat0 & LSI_ISTAT0_SIGP) {\n                    s->dsp = s->dnad;\n                } else if (!lsi_irq_on_rsl(s)) {\n                        lsi_wait_reselect(s);\n                }\n                break;\n            case 3: /* Set */\n                trace_lsi_execute_script_io_set(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                    lsi_set_phase(s, PHASE_MO);\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl |= LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 9)) {\n                    qemu_log_mask(LOG_UNIMP,\n                        \"lsi_scsi: Target mode not implemented\\n\");\n                }\n                if (insn & (1 << 10))\n                    s->carry = 1;\n                break;\n            case 4: /* Clear */\n                trace_lsi_execute_script_io_clear(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl &= ~LSI_SOCL_ATN;\n                    s->sbcl &= ~LSI_SBCL_ATN;\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl &= ~LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 10))\n                    s->carry = 0;\n                break;\n            }\n        } else {\n            uint8_t op0;\n            uint8_t op1;\n            uint8_t data8;\n            int reg;\n            int operator;\n\n            static const char *opcode_names[3] =\n                {\"Write\", \"Read\", \"Read-Modify-Write\"};\n            static const char *operator_names[8] =\n                {\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\n\n            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);\n            data8 = (insn >> 8) & 0xff;\n            opcode = (insn >> 27) & 7;\n            operator = (insn >> 24) & 7;\n            trace_lsi_execute_script_io_opcode(\n                    opcode_names[opcode - 5], reg,\n                    operator_names[operator], data8, s->sfbr,\n                    (insn & (1 << 23)) ? \" SFBR\" : \"\");\n            op0 = op1 = 0;\n            switch (opcode) {\n            case 5: /* From SFBR */\n                op0 = s->sfbr;\n                op1 = data8;\n                break;\n            case 6: /* To SFBR */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                op1 = data8;\n                break;\n            case 7: /* Read-modify-write */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                if (insn & (1 << 23)) {\n                    op1 = s->sfbr;\n                } else {\n                    op1 = data8;\n                }\n                break;\n            }\n\n            switch (operator) {\n            case 0: /* move */\n                op0 = op1;\n                break;\n            case 1: /* Shift left */\n                op1 = op0 >> 7;\n                op0 = (op0 << 1) | s->carry;\n                s->carry = op1;\n                break;\n            case 2: /* OR */\n                op0 |= op1;\n                break;\n            case 3: /* XOR */\n                op0 ^= op1;\n                break;\n            case 4: /* AND */\n                op0 &= op1;\n                break;\n            case 5: /* SHR */\n                op1 = op0 & 1;\n                op0 = (op0 >> 1) | (s->carry << 7);\n                s->carry = op1;\n                break;\n            case 6: /* ADD */\n                op0 += op1;\n                s->carry = op0 < op1;\n                break;\n            case 7: /* ADC */\n                op0 += op1 + s->carry;\n                if (s->carry)\n                    s->carry = op0 <= op1;\n                else\n                    s->carry = op0 < op1;\n                break;\n            }\n\n            switch (opcode) {\n            case 5: /* From SFBR */\n            case 7: /* Read-modify-write */\n                lsi_reg_writeb(s, reg, op0);\n                break;\n            case 6: /* To SFBR */\n                s->sfbr = op0;\n                break;\n            }\n        }\n        break;\n\n    case 2: /* Transfer Control.  */\n        {\n            int cond;\n            int jmp;\n\n            if ((insn & 0x002e0000) == 0) {\n                trace_lsi_execute_script_tc_nop();\n                break;\n            }\n            if (s->sist1 & LSI_SIST1_STO) {\n                trace_lsi_execute_script_tc_delayedselect_timeout();\n                lsi_stop_script(s);\n                break;\n            }\n            cond = jmp = (insn & (1 << 19)) != 0;\n            if (cond == jmp && (insn & (1 << 21))) {\n                trace_lsi_execute_script_tc_compc(s->carry == jmp);\n                cond = s->carry != 0;\n            }\n            if (cond == jmp && (insn & (1 << 17))) {\n                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),\n                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));\n                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n            }\n            if (cond == jmp && (insn & (1 << 18))) {\n                uint8_t mask;\n\n                mask = (~insn >> 8) & 0xff;\n                trace_lsi_execute_script_tc_compd(\n                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);\n                cond = (s->sfbr & mask) == (insn & mask);\n            }\n            if (cond == jmp) {\n                if (insn & (1 << 23)) {\n                    /* Relative address.  */\n                    addr = s->dsp + sextract32(addr, 0, 24);\n                }\n                switch ((insn >> 27) & 7) {\n                case 0: /* Jump */\n                    trace_lsi_execute_script_tc_jump(addr);\n                    s->adder = addr;\n                    s->dsp = addr;\n                    break;\n                case 1: /* Call */\n                    trace_lsi_execute_script_tc_call(addr);\n                    s->temp = s->dsp;\n                    s->dsp = addr;\n                    break;\n                case 2: /* Return */\n                    trace_lsi_execute_script_tc_return(s->temp);\n                    s->dsp = s->temp;\n                    break;\n                case 3: /* Interrupt */\n                    trace_lsi_execute_script_tc_interrupt(s->dsps);\n                    if ((insn & (1 << 20)) != 0) {\n                        s->istat0 |= LSI_ISTAT0_INTF;\n                        lsi_update_irq(s);\n                    } else {\n                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n                    }\n                    break;\n                default:\n                    trace_lsi_execute_script_tc_illegal();\n                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);\n                    break;\n                }\n            } else {\n                trace_lsi_execute_script_tc_cc_failed();\n            }\n        }\n        break;\n\n    case 3:\n        if ((insn & (1 << 29)) == 0) {\n            /* Memory move.  */\n            uint32_t dest;\n            /* ??? The docs imply the destination address is loaded into\n               the TEMP register.  However the Linux drivers rely on\n               the value being presrved.  */\n            dest = read_dword(s, s->dsp);\n            s->dsp += 4;\n            lsi_memcpy(s, dest, addr, insn & 0xffffff);\n        } else {\n            uint8_t data[7];\n            int reg;\n            int n;\n            int i;\n\n            if (insn & (1 << 28)) {\n                addr = s->dsa + sextract32(addr, 0, 24);\n            }\n            n = (insn & 7);\n            reg = (insn >> 16) & 0xff;\n            if (insn & (1 << 24)) {\n                pci_dma_read(pci_dev, addr, data, n);\n                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);\n                for (i = 0; i < n; i++) {\n                    lsi_reg_writeb(s, reg + i, data[i]);\n                }\n            } else {\n                trace_lsi_execute_script_mm_store(reg, n, addr);\n                for (i = 0; i < n; i++) {\n                    data[i] = lsi_reg_readb(s, reg + i);\n                }\n                pci_dma_write(pci_dev, addr, data, n);\n            }\n        }\n    }\n    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {\n        /* Some windows drivers make the device spin waiting for a memory\n           location to change.  If we have been executed a lot of code then\n           assume this is the case and force an unexpected device disconnect.\n           This is apparently sufficient to beat the drivers into submission.\n         */\n        if (!(s->sien0 & LSI_SIST0_UDC)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: inf. loop with UDC masked\");\n        }\n        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n        lsi_disconnect(s);\n    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\n        if (s->dcntl & LSI_DCNTL_SSM) {\n             }\n         }\n     }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-835"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int user_match(const struct key *key, const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int UnpackWPG2Raster(Image *image,int bpp)\n{\n  int XorMe = 0;\n\n  int\n    RunCount;\n\n  size_t\n    x,\n    y;\n\n  ssize_t\n    i,\n    ldblk;\n\n  unsigned int\n    SampleSize=1;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    SampleBuffer[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  x=0;\n  y=0;\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));\n  if(BImgBuff==NULL)\n    return(-2);\n\n  while( y< image->rows)\n    {\n      bbuf=ReadBlobByte(image);\n\n      switch(bbuf)\n        {\n        case 0x7D:\n          SampleSize=ReadBlobByte(image);  /* DSZ */\n          if(SampleSize>8)\n            return(-2);\n          if(SampleSize<1)\n            return(-2);\n          break;\n        case 0x7E:\n          (void) FormatLocaleFile(stderr,\n            \"\\nUnsupported WPG token XOR, please report!\");\n          XorMe=!XorMe;\n          break;\n        case 0x7F:\n          RunCount=ReadBlobByte(image);   /* BLK */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0);\n            }\n          break;\n        case 0xFD:\n          RunCount=ReadBlobByte(image);   /* EXT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i<= RunCount;i++)\n            for(bbuf=0; bbuf < SampleSize; bbuf++)\n              InsertByte6(SampleBuffer[bbuf]);\n          break;\n        case 0xFE:\n          RunCount=ReadBlobByte(image);  /* RST */\n          if (RunCount < 0)\n            break;\n          if(x!=0)\n            {\n              (void) FormatLocaleFile(stderr,\n                \"\\nUnsupported WPG2 unaligned token RST x=%.20g, please report!\\n\"\n                ,(double) x);\n              return(-3);\n            }\n          {\n            /* duplicate the previous row RunCount x */\n            for(i=0;i<=RunCount;i++)\n              {\n                InsertRow(BImgBuff,(ssize_t) (image->rows >= y ? y : image->rows-1),\n                          image,bpp);\n                y++;\n              }\n          }\n          break;\n        case 0xFF:\n          RunCount=ReadBlobByte(image);   /* WHT */\n          if (RunCount < 0)\n            break;\n          for (i=0; i < SampleSize*(RunCount+1); i++)\n          {\n            InsertByte6(0xFF);\n          }\n          break;\n        default:\n          RunCount=bbuf & 0x7F;\n\n          if(bbuf & 0x80)     /* REP */\n            {\n              for(i=0; i < SampleSize; i++)\n                SampleBuffer[i]=ReadBlobByte(image);\n              for(i=0;i<=RunCount;i++)\n                for(bbuf=0;bbuf<SampleSize;bbuf++)\n                  InsertByte6(SampleBuffer[bbuf]);\n            }\n          else {      /* NRP */\n            for(i=0; i< SampleSize*(RunCount+1);i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte6(bbuf);\n              }\n          }\n        }\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static AttachedClientHosts* GetInstance() {\n    return Singleton<AttachedClientHosts>::get();\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "cJSON *cJSON_CreateStringArray( const char **strings, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateString( strings[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static const MediaQueryEvaluator& printEval()\n{\n    DEFINE_STATIC_LOCAL(const MediaQueryEvaluator, staticPrintEval, (\"print\"));\n    return staticPrintEval;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                     ++ptr;\n                 }\n \n                if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {\n                     conn_set_state(c, conn_closing);\n                     return 1;\n                 }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "BasePrefsChange::~BasePrefsChange() {\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior,\n                                      UpdateFromElementBehavior update_behavior,\n                                      const KURL& url,\n                                      ReferrerPolicy referrer_policy,\n                                      UpdateType update_type) {\n  pending_task_.reset();\n  std::unique_ptr<IncrementLoadEventDelayCount> load_delay_counter;\n  load_delay_counter.swap(delay_until_do_update_from_element_);\n\n  Document& document = element_->GetDocument();\n  if (!document.IsActive())\n    return;\n\n  AtomicString image_source_url = element_->ImageSourceURL();\n  ImageResourceContent* new_image_content = nullptr;\n  if (!url.IsNull() && !url.IsEmpty()) {\n    ResourceLoaderOptions resource_loader_options;\n    resource_loader_options.initiator_info.name = GetElement()->localName();\n    ResourceRequest resource_request(url);\n    if (update_behavior == kUpdateForcedReload) {\n      resource_request.SetCacheMode(mojom::FetchCacheMode::kBypassCache);\n      resource_request.SetPreviewsState(WebURLRequest::kPreviewsNoTransform);\n    }\n\n    if (referrer_policy != kReferrerPolicyDefault) {\n      resource_request.SetHTTPReferrer(SecurityPolicy::GenerateReferrer(\n           referrer_policy, url, document.OutgoingReferrer()));\n     }\n \n     if (IsHTMLPictureElement(GetElement()->parentNode()) ||\n        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull())\n       resource_request.SetRequestContext(\n           WebURLRequest::kRequestContextImageSet);\n \n     bool page_is_being_dismissed =\n         document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;\n    if (page_is_being_dismissed) {\n      resource_request.SetHTTPHeaderField(HTTPNames::Cache_Control,\n                                          \"max-age=0\");\n      resource_request.SetKeepalive(true);\n      resource_request.SetRequestContext(WebURLRequest::kRequestContextPing);\n    }\n\n    FetchParameters params(resource_request, resource_loader_options);\n    ConfigureRequest(params, bypass_behavior, *element_,\n                     document.GetClientHintsPreferences());\n\n    if (update_behavior != kUpdateForcedReload && document.GetFrame())\n      document.GetFrame()->MaybeAllowImagePlaceholder(params);\n\n    new_image_content = ImageResourceContent::Fetch(params, document.Fetcher());\n\n    if (page_is_being_dismissed)\n      new_image_content = nullptr;\n\n    ClearFailedLoadURL();\n  } else {\n    if (!image_source_url.IsNull()) {\n      DispatchErrorEvent();\n    }\n    NoImageResourceToLoad();\n  }\n\n  ImageResourceContent* old_image_content = image_content_.Get();\n  if (old_image_content != new_image_content)\n    RejectPendingDecodes(update_type);\n\n  if (update_behavior == kUpdateSizeChanged && element_->GetLayoutObject() &&\n      element_->GetLayoutObject()->IsImage() &&\n      new_image_content == old_image_content) {\n    ToLayoutImage(element_->GetLayoutObject())->IntrinsicSizeChanged();\n  } else {\n    if (pending_load_event_.IsActive())\n      pending_load_event_.Cancel();\n\n    if (pending_error_event_.IsActive() && new_image_content)\n      pending_error_event_.Cancel();\n\n    UpdateImageState(new_image_content);\n\n    UpdateLayoutObject();\n    if (new_image_content) {\n      new_image_content->AddObserver(this);\n    }\n    if (old_image_content) {\n      old_image_content->RemoveObserver(this);\n    }\n  }\n\n  if (LayoutImageResource* image_resource = GetLayoutImageResource())\n    image_resource->ResetAnimation();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static ssize_t disk_alignment_offset_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", queue_alignment_offset(disk->queue));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long Segment::LoadCluster(\n    long long& pos,\n    long& len)\n{\n    for (;;)\n    {\n        const long result = DoLoadCluster(pos, len);\n \n        if (result <= 1)\n            return result;\n     }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GDataFileSystem::OnCopyDocumentCompleted(\n    const FilePath& dir_path,\n    const FileOperationCallback& callback,\n    GDataErrorCode status,\n    scoped_ptr<base::Value> data) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!callback.is_null());\n\n  GDataFileError error = util::GDataToGDataFileError(status);\n  if (error != GDATA_FILE_OK) {\n    callback.Run(error);\n    return;\n  }\n\n  scoped_ptr<DocumentEntry> doc_entry(DocumentEntry::ExtractAndParse(*data));\n  if (!doc_entry.get()) {\n    callback.Run(GDATA_FILE_ERROR_FAILED);\n     return;\n   }\n \n  GDataEntry* entry = GDataEntry::FromDocumentEntry(\n      NULL, doc_entry.get(), directory_service_.get());\n   if (!entry) {\n     callback.Run(GDATA_FILE_ERROR_FAILED);\n     return;\n  }\n\n  directory_service_->root()->AddEntry(entry);\n  MoveEntryFromRootDirectory(dir_path,\n                             callback,\n                             GDATA_FILE_OK,\n                             entry->GetFilePath());\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "long arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret;\n\tunsigned long __user *datap = (unsigned long __user *) data;\n\n\tswitch (request) {\n\t\tcase PTRACE_PEEKUSR:\n\t\t\tret = ptrace_read_user(child, addr, datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_POKEUSR:\n\t\t\tret = ptrace_write_user(child, addr, data);\n\t\t\tbreak;\n\n\t\tcase PTRACE_GETREGS:\n\t\t\tret = copy_regset_to_user(child,\n\t\t\t\t\t\t  &user_arm_view, REGSET_GPR,\n\t\t\t\t\t\t  0, sizeof(struct pt_regs),\n\t\t\t\t\t\t  datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETREGS:\n\t\t\tret = copy_regset_from_user(child,\n\t\t\t\t\t\t    &user_arm_view, REGSET_GPR,\n\t\t\t\t\t\t    0, sizeof(struct pt_regs),\n\t\t\t\t\t\t    datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_GETFPREGS:\n\t\t\tret = copy_regset_to_user(child,\n\t\t\t\t\t\t  &user_arm_view, REGSET_FPR,\n\t\t\t\t\t\t  0, sizeof(union fp_state),\n\t\t\t\t\t\t  datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETFPREGS:\n\t\t\tret = copy_regset_from_user(child,\n\t\t\t\t\t\t    &user_arm_view, REGSET_FPR,\n\t\t\t\t\t\t    0, sizeof(union fp_state),\n\t\t\t\t\t\t    datap);\n\t\t\tbreak;\n\n#ifdef CONFIG_IWMMXT\n\t\tcase PTRACE_GETWMMXREGS:\n\t\t\tret = ptrace_getwmmxregs(child, datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETWMMXREGS:\n\t\t\tret = ptrace_setwmmxregs(child, datap);\n\t\t\tbreak;\n #endif\n \n \t\tcase PTRACE_GET_THREAD_AREA:\n\t\t\tret = put_user(task_thread_info(child)->tp_value,\n \t\t\t\t       datap);\n \t\t\tbreak;\n \n\t\tcase PTRACE_SET_SYSCALL:\n\t\t\ttask_thread_info(child)->syscall = data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\n#ifdef CONFIG_CRUNCH\n\t\tcase PTRACE_GETCRUNCHREGS:\n\t\t\tret = ptrace_getcrunchregs(child, datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETCRUNCHREGS:\n\t\t\tret = ptrace_setcrunchregs(child, datap);\n\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_VFP\n\t\tcase PTRACE_GETVFPREGS:\n\t\t\tret = copy_regset_to_user(child,\n\t\t\t\t\t\t  &user_arm_view, REGSET_VFP,\n\t\t\t\t\t\t  0, ARM_VFPREGS_SIZE,\n\t\t\t\t\t\t  datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETVFPREGS:\n\t\t\tret = copy_regset_from_user(child,\n\t\t\t\t\t\t    &user_arm_view, REGSET_VFP,\n\t\t\t\t\t\t    0, ARM_VFPREGS_SIZE,\n\t\t\t\t\t\t    datap);\n\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t\tcase PTRACE_GETHBPREGS:\n\t\t\tif (ptrace_get_breakpoints(child) < 0)\n\t\t\t\treturn -ESRCH;\n\n\t\t\tret = ptrace_gethbpregs(child, addr,\n\t\t\t\t\t\t(unsigned long __user *)data);\n\t\t\tptrace_put_breakpoints(child);\n\t\t\tbreak;\n\t\tcase PTRACE_SETHBPREGS:\n\t\t\tif (ptrace_get_breakpoints(child) < 0)\n\t\t\t\treturn -ESRCH;\n\n\t\t\tret = ptrace_sethbpregs(child, addr,\n\t\t\t\t\t\t(unsigned long __user *)data);\n\t\t\tptrace_put_breakpoints(child);\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tret = ptrace_request(child, request, addr, data);\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void AppModalDialog::CompleteDialog() {\n  AppModalDialogQueue::GetInstance()->ShowNextDialog();\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {\n size_t oldSize = mSize;\n\n size_t offset = 0;\n while (mSize >= 10 && offset <= mSize - 10) {\n if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {\n break;\n }\n\n size_t dataSize;\n if (iTunesHack) {\n            dataSize = U32_AT(&mData[offset + 4]);\n } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {\n return false;\n }\n\n if (dataSize > mSize - 10 - offset) {\n return false;\n }\n\n uint16_t flags = U16_AT(&mData[offset + 8]);\n uint16_t prevFlags = flags;\n\n if (flags & 1) {\n\n if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {\n return false;\n }\n            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);\n            mSize -= 4;\n            dataSize -= 4;\n\n\n             flags &= ~1;\n         }\n \n        if (flags & 2) {\n \n size_t readOffset = offset + 11;\n size_t writeOffset = offset + 11;\n for (size_t i = 0; i + 1 < dataSize; ++i) {\n if (mData[readOffset - 1] == 0xff\n && mData[readOffset] == 0x00) {\n ++readOffset;\n --mSize;\n --dataSize;\n }\n\n                 mData[writeOffset++] = mData[readOffset++];\n             }\n            memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);\n \n            flags &= ~2;\n         }\n         if (flags != prevFlags || iTunesHack) {\n             WriteSyncsafeInteger(&mData[offset + 4], dataSize);\n             mData[offset + 8] = flags >> 8;\n            mData[offset + 9] = flags & 0xff;\n }\n\n        offset += 10 + dataSize;\n }\n\n    memset(&mData[mSize], 0, oldSize - mSize);\n\n return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n \tint leftLimit = -1, rightLimit;\n \tint i, restoreAlphaBlending = 0;\n \n\tif (border < 0) {\n \t\t/* Refuse to fill to a non-solid border */\n \t\treturn;\n \t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int __init ip_vs_control_init(void)\n{\n\tint ret;\n\tint idx;\n\n\tEnterFunction(2);\n\n\tret = nf_register_sockopt(&ip_vs_sockopts);\n\tif (ret) {\n\t\tpr_err(\"cannot register sockopt.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ip_vs_genl_register();\n\tif (ret) {\n\t\tpr_err(\"cannot register Generic Netlink interface.\\n\");\n\t\tnf_unregister_sockopt(&ip_vs_sockopts);\n\t\treturn ret;\n\t}\n\n\tproc_net_fops_create(&init_net, \"ip_vs\", 0, &ip_vs_info_fops);\n\tproc_net_fops_create(&init_net, \"ip_vs_stats\",0, &ip_vs_stats_fops);\n\n\tsysctl_header = register_sysctl_paths(net_vs_ctl_path, vs_vars);\n\n\t/* Initialize ip_vs_svc_table, ip_vs_svc_fwm_table, ip_vs_rtable */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++)  {\n\t\tINIT_LIST_HEAD(&ip_vs_svc_table[idx]);\n\t\tINIT_LIST_HEAD(&ip_vs_svc_fwm_table[idx]);\n\t}\n\tfor(idx = 0; idx < IP_VS_RTAB_SIZE; idx++)  {\n\t\tINIT_LIST_HEAD(&ip_vs_rtable[idx]);\n\t}\n\n\tip_vs_new_estimator(&ip_vs_stats);\n\n\t/* Hook the defense timer */\n\tschedule_delayed_work(&defense_work, DEFENSE_TIMER_PERIOD);\n\n\tLeaveFunction(2);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void XMLHttpRequest::genericError()\n {\n     clearResponse();\n     clearRequest();\n    m_error = true;\n \n    changeState(DONE);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int pat_parse_meth(const char *text, struct pattern *pattern, int mflags, char **err)\n{\n\tint len, meth;\n\n\tlen  = strlen(text);\n\tmeth = find_http_meth(text, len);\n\n\tpattern->val.i = meth;\n\tif (meth == HTTP_METH_OTHER) {\n\t\tpattern->ptr.str = (char *)text;\n\t\tpattern->len = len;\n\t}\n\telse {\n\t\tpattern->ptr.str = NULL;\n\t\tpattern->len = 0;\n\t}\n\treturn 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,\n                                       mojo::ScopedSharedBufferHandle handle) {\n  DVLOG(1) << __func__ << \" buffer_id: \" << buffer_id;\n  DCHECK(io_thread_checker_.CalledOnValidThread());\n  DCHECK(handle.is_valid());\n \n   base::SharedMemoryHandle memory_handle;\n   size_t memory_size = 0;\n  bool read_only_flag = false;\n \n   const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n   DCHECK_EQ(MOJO_RESULT_OK, result);\n   DCHECK_GT(memory_size, 0u);\n \n   std::unique_ptr<base::SharedMemory> shm(\n       new base::SharedMemory(memory_handle, true /* read_only */));\n   if (!shm->Map(memory_size)) {\n    DLOG(ERROR) << \"OnBufferCreated: Map failed.\";\n    return;\n  }\n  const bool inserted =\n      client_buffers_\n          .insert(std::make_pair(buffer_id,\n                                 new ClientBuffer(std::move(shm), memory_size)))\n          .second;\n  DCHECK(inserted);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n \t\tmutex_unlock(&current->signal->cred_guard_mutex);\n \t\tabort_creds(bprm->cred);\n \t}\n \tkfree(bprm);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void InputMethodChangedHandler(\n      void* object,\n      const chromeos::InputMethodDescriptor& current_input_method) {\n    if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {\n      LOG(ERROR) << \"Not on UI thread\";\n       return;\n     }\n \n    InputMethodLibraryImpl* input_method_library =\n        static_cast<InputMethodLibraryImpl*>(object);\n    input_method_library->ChangeCurrentInputMethod(current_input_method);\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void setup_ksp_vsid(struct task_struct *p, unsigned long sp)\n{\n#ifdef CONFIG_PPC_STD_MMU_64\n\tunsigned long sp_vsid;\n\tunsigned long llp = mmu_psize_defs[mmu_linear_psize].sllp;\n\n\tif (mmu_has_feature(MMU_FTR_1T_SEGMENT))\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_1T)\n\t\t\t<< SLB_VSID_SHIFT_1T;\n\telse\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_256M)\n\t\t\t<< SLB_VSID_SHIFT;\n\tsp_vsid |= SLB_VSID_KERNEL | llp;\n\tp->thread.ksp_vsid = sp_vsid;\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n VisualizerContext * pContext = (VisualizerContext *)self;\n int retsize;\n\n if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {\n return -EINVAL;\n }\n\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Visualizer_init(pContext);\n break;\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Visualizer_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL ||\n *replySize != sizeof(effect_config_t)) {\n return -EINVAL;\n }\n Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n case EFFECT_CMD_RESET:\n Visualizer_reset(pContext);\n break;\n case EFFECT_CMD_ENABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != VISUALIZER_STATE_ACTIVE) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_GET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || replySize == NULL ||\n *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {\n return -EINVAL;\n }\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));\n effect_param_t *p = (effect_param_t *)pReplyData;\n        p->status = 0;\n *replySize = sizeof(effect_param_t) + sizeof(uint32_t);\n if (p->psize != sizeof(uint32_t)) {\n            p->status = -EINVAL;\n break;\n }\n switch (*(uint32_t *)p->data) {\n case VISUALIZER_PARAM_CAPTURE_SIZE:\n            ALOGV(\"get mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n *((uint32_t *)p->data + 1) = pContext->mCaptureSize;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_SCALING_MODE:\n            ALOGV(\"get mScalingMode = %\" PRIu32, pContext->mScalingMode);\n *((uint32_t *)p->data + 1) = pContext->mScalingMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_MEASUREMENT_MODE:\n            ALOGV(\"get mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n default:\n            p->status = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n return -EINVAL;\n }\n *(int32_t *)pReplyData = 0;\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {\n *(int32_t *)pReplyData = -EINVAL;\n\n             break;\n         }\n         switch (*(uint32_t *)p->data) {\n        case VISUALIZER_PARAM_CAPTURE_SIZE:\n            pContext->mCaptureSize = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n            break;\n         case VISUALIZER_PARAM_SCALING_MODE:\n             pContext->mScalingMode = *((uint32_t *)p->data + 1);\n             ALOGV(\"set mScalingMode = %\" PRIu32, pContext->mScalingMode);\n             break;\n        case VISUALIZER_PARAM_LATENCY:\n            pContext->mLatency = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mLatency = %\" PRIu32, pContext->mLatency);\n            break;\n         case VISUALIZER_PARAM_MEASUREMENT_MODE:\n             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);\n             ALOGV(\"set mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n break;\n default:\n *(int32_t *)pReplyData = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n\n case VISUALIZER_CMD_CAPTURE: {\n uint32_t captureSize = pContext->mCaptureSize;\n if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {\n            ALOGV(\"VISUALIZER_CMD_CAPTURE() error *replySize %\" PRIu32 \" captureSize %\" PRIu32,\n *replySize, captureSize);\n return -EINVAL;\n }\n if (pContext->mState == VISUALIZER_STATE_ACTIVE) {\n const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n\n if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&\n (pContext->mBufferUpdateTime.tv_sec != 0) &&\n (deltaMs > MAX_STALL_TIME_MS)) {\n                    ALOGV(\"capture going to idle\");\n                    pContext->mBufferUpdateTime.tv_sec = 0;\n                    memset(pReplyData, 0x80, captureSize);\n } else {\n int32_t latencyMs = pContext->mLatency;\n                latencyMs -= deltaMs;\n\n                 if (latencyMs < 0) {\n                     latencyMs = 0;\n                 }\n                const uint32_t deltaSmpl =\n                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;\n                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;\n \n                 if (capturePoint < 0) {\n                     uint32_t size = -capturePoint;\n                     if (size > captureSize) {\n                        size = captureSize;\n }\n                    memcpy(pReplyData,\n                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,\n                           size);\n                    pReplyData = (char *)pReplyData + size;\n                    captureSize -= size;\n                    capturePoint = 0;\n }\n                memcpy(pReplyData,\n                       pContext->mCaptureBuf + capturePoint,\n                       captureSize);\n }\n\n            pContext->mLastCaptureIdx = pContext->mCaptureIdx;\n } else {\n            memset(pReplyData, 0x80, captureSize);\n }\n\n } break;\n\n case VISUALIZER_CMD_MEASURE: {\n if (pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {\n if (replySize == NULL) {\n                ALOGV(\"VISUALIZER_CMD_MEASURE() error replySize NULL\");\n } else {\n                ALOGV(\"VISUALIZER_CMD_MEASURE() error *replySize %\" PRIu32\n \" < (sizeof(int32_t) * MEASUREMENT_COUNT) %\" PRIu32,\n *replySize,\n uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);\n }\n            android_errorWriteLog(0x534e4554, \"30229821\");\n return -EINVAL;\n }\n uint16_t peakU16 = 0;\n float sumRmsSquared = 0.0f;\n uint8_t nbValidMeasurements = 0;\n const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {\n            ALOGV(\"Discarding measurements, last measurement is %\" PRId32 \"ms old\", delayMs);\n for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {\n                pContext->mPastMeasurements[i].mIsValid = false;\n                pContext->mPastMeasurements[i].mPeakU16 = 0;\n                pContext->mPastMeasurements[i].mRmsSquared = 0;\n }\n            pContext->mMeasurementBufferIdx = 0;\n } else {\n for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {\n if (pContext->mPastMeasurements[i].mIsValid) {\n if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {\n                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;\n }\n                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;\n                    nbValidMeasurements++;\n }\n }\n }\n float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);\n int32_t* pIntReplyData = (int32_t*)pReplyData;\n if (rms < 0.000016f) {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB\n } else {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));\n }\n if (peakU16 == 0) {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB\n } else {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));\n }\n        ALOGV(\"VISUALIZER_CMD_MEASURE peak=%\" PRIu16 \" (%\" PRId32 \"mB), rms=%.1f (%\" PRId32 \"mB)\",\n                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],\n                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);\n }\n break;\n\n default:\n        ALOGW(\"Visualizer_command invalid command %\" PRIu32, cmdCode);\n return -EINVAL;\n }\n\n return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "parserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\n\t/*\n\t * Portability note:\n\t * Here we find the address of the ar_verf credentials.\n\t * Originally, this calculation was\n\t *\tdp = (uint32_t *)&rp->rm_reply.rp_acpt.ar_verf\n\t * On the wire, the rp_acpt field starts immediately after\n\t * the (32 bit) rp_stat field.  However, rp_acpt (which is a\n\t * \"struct accepted_reply\") contains a \"struct opaque_auth\",\n\t * whose internal representation contains a pointer, so on a\n\t * 64-bit machine the compiler inserts 32 bits of padding\n\t * before rp->rm_reply.rp_acpt.ar_verf.  So, we cannot use\n\t * the internal representation to parse the on-the-wire\n\t * representation.  Instead, we skip past the rp_stat field,\n\t * which is an \"enum\" and so occupies one 32-bit word.\n\t */\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\t/*\n \t * skip past the ar_verf credentials.\n \t */\n \tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\tND_TCHECK2(dp[0], 0);\n \n \t/*\n \t * now we can check the ar_stat field\n \t */\n \tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n \tif (astat != SUNRPC_SUCCESS) {\n \t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t/* suppress trunc string */\n\t\treturn (NULL);\n\t}\n\t/* successful return */\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void PDFiumEngine::GetTextRunInfo(int page_index,\n                                  int start_char_index,\n                                  uint32_t* out_len,\n                                  double* out_font_size,\n                                  pp::FloatRect* out_bounds) {\n  DCHECK(PageIndexInBounds(page_index));\n  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,\n                                            out_font_size, out_bounds);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void Document::UnregisterNodeListWithIdNameCache(const LiveNodeListBase* list) {\n  node_lists_.Remove(list, kInvalidateOnIdNameAttrChange);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n    struct mfi_ctrl_info info;\n    size_t dcmd_size = sizeof(info);\n    BusChild *kid;\n    int num_pd_disks = 0;\n\n    memset(&info, 0x0, dcmd_size);\n    if (cmd->iov_size < dcmd_size) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_size);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n    /*\n     * For some reason the firmware supports\n     * only up to 8 device ports.\n     * Despite supporting a far larger number\n     * of devices for the physical devices.\n     * So just display the first 8 devices\n     * in the device port list, independent\n     * of how many logical devices are actually\n     * present.\n     */\n    info.host.type = MFI_INFO_HOST_PCIE;\n    info.device.type = MFI_INFO_DEV_SAS3G;\n    info.device.port_count = 8;\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n        SCSIDevice *sdev = SCSI_DEVICE(kid->child);\n        uint16_t pd_id;\n\n        if (num_pd_disks < 8) {\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n            info.device.port_addr[num_pd_disks] =\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n        }\n        num_pd_disks++;\n    }\n\n    memcpy(info.product_name, base_class->product_name, 24);\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n    memcpy(info.image_component[0].name, \"APP\", 3);\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n             base_class->product_version);\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n    info.image_component_count = 1;\n    if (pci_dev->has_rom) {\n        uint8_t biosver[32];\n        uint8_t *ptr;\n \n         ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n         memcpy(biosver, ptr + 0x41, 31);\n         memcpy(info.image_component[1].name, \"BIOS\", 4);\n         memcpy(info.image_component[1].version, biosver,\n                strlen((const char *)biosver));\n    }\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n    info.max_arms = 32;\n    info.max_spans = 8;\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n    info.max_lds = MFI_MAX_LD;\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n    if (!megasas_is_jbod(s))\n        info.lds_present = cpu_to_le16(num_pd_disks);\n    info.pd_present = cpu_to_le16(num_pd_disks);\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n                                   MFI_INFO_HW_MEM |\n                                   MFI_INFO_HW_FLASH);\n    info.memory_size = cpu_to_le16(512);\n    info.nvram_size = cpu_to_le16(32);\n    info.flash_size = cpu_to_le16(16);\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n                               MFI_INFO_LDOPS_IO_POLICY |\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n                               MFI_INFO_LDOPS_READ_POLICY);\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n    info.stripe_sz_ops.min = 3;\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n    info.properties.rebuild_rate = 30;\n    info.properties.patrol_read_rate = 30;\n    info.properties.bgi_rate = 30;\n    info.properties.cc_rate = 30;\n    info.properties.recon_rate = 30;\n    info.properties.cache_flush_interval = 4;\n    info.properties.spinup_drv_cnt = 2;\n    info.properties.spinup_delay = 6;\n    info.properties.ecc_bucket_size = 15;\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n    info.properties.expose_encl_devices = 1;\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n                                       MFI_INFO_PDMIX_SATA |\n                                       MFI_INFO_PDMIX_LD);\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n    return MFI_STAT_OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "_tiffReadProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\t/* tmsize_t is 64bit on 64bit systems, but the WinAPI ReadFile takes\n\t * 32bit sizes, so we loop through the data in suitable 32bit sized\n\t * chunks */\n\tuint8* ma;\n\tuint64 mb;\n\tDWORD n;\n\tDWORD o;\n\ttmsize_t p;\n\tma=(uint8*)buf;\n\tmb=size;\n\tp=0;\n\twhile (mb>0)\n\t{\n\t\tn=0x80000000UL;\n\t\tif ((uint64)n>mb)\n\t\t\tn=(DWORD)mb;\n\t\tif (!ReadFile(fd,(LPVOID)ma,n,&o,NULL))\n\t\t\treturn(0);\n\t\tma+=o;\n\t\tmb-=o;\n\t\tp+=o;\n\t\tif (o!=n)\n\t\t\tbreak;\n\t}\n\treturn(p);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-369"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n     size_t noff, size_t doff, int *flags)\n {\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n \t\tuint8_t desc[20];\n \t\tconst char *btype;\n \t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void AutomationProvider::UninstallExtension(int extension_handle,\n                                            bool* success) {\n  *success = false;\n  const Extension* extension = GetExtension(extension_handle);\n  ExtensionService* service = profile_->GetExtensionService();\n  if (extension && service) {\n    ExtensionUnloadNotificationObserver observer;\n    service->UninstallExtension(extension->id(), false);\n    *success = observer.did_receive_unload_notification();\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BrowserWindowGtk::FocusBookmarksToolbar() {\n  NOTIMPLEMENTED();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CrosLibrary::TestApi::SetBrightnessLibrary(\n    BrightnessLibrary* library, bool own) {\n  library_->brightness_lib_.SetImpl(library, own);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "kg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,\n             conf_state, qop_state, toktype)\n    krb5_context context;\n    OM_uint32 *minor_status;\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    int bodysize;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_error_code code;\n     int conflen = 0;\n     int signalg;\n     int sealalg;\n     gss_buffer_desc token;\n     krb5_checksum cksum;\n     krb5_checksum md5cksum;\n    krb5_data plaind;\n    char *data_ptr;\n    unsigned char *plain;\n    unsigned int cksum_len = 0;\n    size_t plainlen;\n    int direction;\n     krb5_ui_4 seqnum;\n     OM_uint32 retval;\n     size_t sumlen;\n     krb5_keyusage sign_usage = KG_USAGE_SIGN;\n \n     if (toktype == KG_TOK_SEAL_MSG) {\n         message_buffer->length = 0;\n         message_buffer->value = NULL;\n     }\n \n    /* get the sign and seal algorithms */\n    signalg = ptr[0] + (ptr[1]<<8);\n    sealalg = ptr[2] + (ptr[3]<<8);\n     /* Sanity checks */\n \n    if ((ptr[4] != 0xff) || (ptr[5] != 0xff)) {\n         *minor_status = 0;\n         return GSS_S_DEFECTIVE_TOKEN;\n     }\n \n     if ((toktype != KG_TOK_SEAL_MSG) &&\n         (sealalg != 0xffff)) {\n         *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* in the current spec, there is only one valid seal algorithm per\n       key type, so a simple comparison is ok */\n\n    if ((toktype == KG_TOK_SEAL_MSG) &&\n        !((sealalg == 0xffff) ||\n          (sealalg == ctx->sealalg))) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* there are several mappings of seal algorithms to sign algorithms,\n       but few enough that we can try them all. */\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_SEAL_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n         return GSS_S_DEFECTIVE_TOKEN;\n     }\n \n     /* get the token parameters */\n \n     if ((code = kg_get_seq_num(context, ctx->seq, ptr+14, ptr+6, &direction,\n                               &seqnum))) {\n        *minor_status = code;\n        return(GSS_S_BAD_SIG);\n    }\n\n    /* decode the message, if SEAL */\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        size_t tmsglen = bodysize-(14+cksum_len);\n        if (sealalg != 0xffff) {\n            if ((plain = (unsigned char *) xmalloc(tmsglen)) == NULL) {\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                int i;\n                store_32_be(seqnum, bigend_seqnum);\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code)\n                {\n                    xfree(plain);\n                    *minor_status = code;\n                    return(GSS_S_FAILURE);\n                }\n\n                assert (enc_key->length == 16);\n                for (i = 0; i <= 15; i++)\n                    ((char *) enc_key->contents)[i] ^=0xf0;\n                code = kg_arcfour_docrypt (enc_key, 0,\n                                           &bigend_seqnum[0], 4,\n                                           ptr+14+cksum_len, tmsglen,\n                                           plain);\n                krb5_free_keyblock (context, enc_key);\n            } else {\n                code = kg_decrypt(context, ctx->enc, KG_USAGE_SEAL, NULL,\n                                  ptr+14+cksum_len, plain, tmsglen);\n            }\n            if (code) {\n                xfree(plain);\n                *minor_status = code;\n                return(GSS_S_FAILURE);\n            }\n        } else {\n            plain = ptr+14+cksum_len;\n        }\n\n         plainlen = tmsglen;\n \n         conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n        token.length = tmsglen - conflen - plain[tmsglen-1];\n \n         if (token.length) {\n             if ((token.value = (void *) gssalloc_malloc(token.length)) == NULL) {\n                if (sealalg != 0xffff)\n                    xfree(plain);\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            memcpy(token.value, plain+conflen, token.length);\n        } else {\n            token.value = NULL;\n        }\n    } else if (toktype == KG_TOK_SIGN_MSG) {\n        token = *message_buffer;\n        plain = token.value;\n        plainlen = token.length;\n    } else {\n        token.length = 0;\n        token.value = NULL;\n        plain = token.value;\n        plainlen = token.length;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the the cksum */\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort ();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code)\n        return(code);\n    md5cksum.length = sumlen;\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (signalg == 0)\n            cksum.length = 8;\n        else\n            cksum.length = 16;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n\n    case SGN_ALG_MD2_5:\n        if (!ctx->seed_init &&\n            (code = kg_make_seed(context, ctx->subkey, ctx->seed))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (! (data_ptr = xmalloc(sizeof(ctx->seed) + 8 + plainlen))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n        (void) memcpy(data_ptr, ptr-2, 8);\n        (void) memcpy(data_ptr+8, ctx->seed, sizeof(ctx->seed));\n        (void) memcpy(data_ptr+8+sizeof(ctx->seed), plain, plainlen);\n        plaind.length = 8 + sizeof(ctx->seed) + plainlen;\n        plaind.data = data_ptr;\n        krb5_free_checksum_contents(context, &md5cksum);\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, 8);\n        /* Falls through to defective-token??  */\n\n    default:\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    }\n\n    krb5_free_checksum_contents(context, &md5cksum);\n    if (sealalg != 0xffff)\n        xfree(plain);\n \n     /* compare the computed checksum against the transmitted checksum */\n \n    if (code) {\n         if (toktype == KG_TOK_SEAL_MSG)\n             gssalloc_free(token.value);\n         *minor_status = 0;\n        return(GSS_S_BAD_SIG);\n    }\n\n\n    /* it got through unscathed.  Make sure the context is unexpired */\n\n    if (toktype == KG_TOK_SEAL_MSG)\n        *message_buffer = token;\n\n    if (conf_state)\n        *conf_state = (sealalg != 0xffff);\n\n    if (qop_state)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    /* do sequencing checks */\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        if (toktype == KG_TOK_SEAL_MSG) {\n            gssalloc_free(token.value);\n            message_buffer->value = NULL;\n            message_buffer->length = 0;\n        }\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        return(GSS_S_BAD_SIG);\n    }\n\n    retval = g_order_check(&(ctx->seqstate), (gssint_uint64)seqnum);\n\n    /* success or ordering violation */\n\n    *minor_status = 0;\n    return(retval);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "usage(void)\n {\n \tfprintf(stderr,\n \t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n \t    \"       ssh-agent [-c | -s] -k\\n\");\n \texit(1);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-426"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {\n\n\tint i;\n\n\t/* now allocate and fill the correct message structure according to the message type */\n\t/* messageContent points to the begining of the ZRTP message */\n\tuint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);\n\n\tswitch (zrtpPacket->messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\t{\n\t\t\t\t/* allocate a Hello message structure */\n\t\t\t\tbzrtpHelloMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));\n\n\t\t\t\t/* fill it */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->clientIdentifier, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\t\t\t\tmemcpy(messageData->H3, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->S = ((*messageContent)>>6)&0x01;\n\t\t\t\tmessageData->M = ((*messageContent)>>5)&0x01;\n\t\t\t\tmessageData->P = ((*messageContent)>>4)&0x01;\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->hc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->ac = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->sc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\n\t\t\t\t/* Check message length according to value in hc, cc, ac, kc and sc */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* parse the variable length part: algorithms types */\n\t\t\t\tfor (i=0; i<messageData->hc; i++) {\n\t\t\t\t\tmessageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->cc; i++) {\n\t\t\t\t\tmessageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->ac; i++) {\n\t\t\t\t\tmessageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->kc; i++) {\n\t\t\t\t\tmessageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->sc; i++) {\n\t\t\t\t\tmessageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);\n\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\t\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK :\n\t\t\t{\n\t\t\t\t/* check message length */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\n\t\tcase MSGTYPE_COMMIT:\n\t\t\t{\n\t\t\t\tuint8_t checkH3[32];\n\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\t\t\t\tuint16_t variableLength = 0;\n\n\t\t\t\t/* allocate a commit message structure */\n\t\t\t\tbzrtpCommitMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H2, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */\n\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\t/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t}\n\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t/* Check H3 = SHA256(H2) */\n\t\t\t\tbctoolbox_sha256(messageData->H2, 32, 32, checkH3);\n\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t}\n\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\tbctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\t/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */\n\t\t\t\tswitch(messageData->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC25 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC38 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\t\t\t\tvariableLength = 32; /* hvi is 32 bytes length in DH Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Prsh :\n\t\t\t\t\t\tvariableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Mult :\n\t\t\t\t\t\tvariableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfree(messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tmessageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\tmessageContent += 4;\n\n\t\t\t\t/* if it is a multistream or preshared commit, get the 16 bytes nonce */\n\t\t\t\tif ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\tmemcpy(messageData->nonce, messageContent, 16);\n\t\t\t\t\tmessageContent +=16;\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\tmemcpy(messageData->keyID, messageContent, 8);\n\t\t\t\t\t\tmessageContent +=8;\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, get the hvi */\n\t\t\t\t\tmemcpy(messageData->hvi, messageContent, 32);\n\t\t\t\t\tmessageContent +=32;\n\t\t\t\t}\n\n\t\t\t\t/* get the MAC and attach the message data to the packet structure */\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_COMMIT */\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tbzrtpDHPartMessage_t *messageData;\n\n\t\t\t\t/*check message length, depends on the selected key agreement algo set in zrtpContext */\n\t\t\t\tuint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);\n\t\t\t\tif (pvLength == 0) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* allocate a DHPart message structure and pv */\n\t\t\t\tmessageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));\n\t\t\t\tmessageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H1, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */\n\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n \t\t\t\t\t\tfree (messageData);\n \t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n \t\t\t\t\t}\n \t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n \t\t\t\t\tuint8_t checkH2[32];\n \t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->rs1ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->rs2ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->auxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pbxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pv, messageContent, pvLength);\n\t\t\t\tmessageContent +=pvLength;\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\n \t\t\t\t/* attach the message structure to the packet one */\n \t\t\t\tzrtpPacket->messageData = (void *)messageData;\n \n\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n \t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n \t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n \t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tuint8_t *confirmMessageKey = NULL;\n\t\t\t\tuint8_t *confirmMessageMacKey = NULL;\n\t\t\t\tbzrtpConfirmMessage_t *messageData;\n\t\t\t\tuint16_t cipherTextLength;\n\t\t\t\tuint8_t computedHmac[8];\n\t\t\t\tuint8_t *confirmPlainMessageBuffer;\n\t\t\t\tuint8_t *confirmPlainMessage;\n\n\t\t\t\t/* we shall first decrypt and validate the message, check we have the keys to do it */\n\t\t\t\tif (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyi;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyi;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyr;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* allocate a confirm message structure */\n\t\t\t\tmessageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));\n\n\t\t\t\t/* get the mac and the IV */\n\t\t\t\tmemcpy(messageData->confirm_mac, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->CFBIV, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\n\n\t\t\t\t\n\t\t\t\t/* get the cipher text length */\n\t\t\t\tcipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */\n\n\t\t\t\t/* validate the mac over the cipher text */\n\t\t\t\tzrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);\n\t\t\t\t\n\t\t\t\tif (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;\n\t\t\t\t}\n\n\t\t\t\t/* get plain message */\n\t\t\t\tconfirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));\n\t\t\t\tzrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);\n\t\t\t\tconfirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */\n\n\t\t\t\t/* parse it */\n\t\t\t\tmemcpy(messageData->H0, confirmPlainMessage, 32);\n\t\t\t\tconfirmPlainMessage +=33; /* +33 because next 8 bits are unused */\n\n\t\t\t\t/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */\n\t\t\t\tif (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\t\t/* compute the H1=SHA256(H0) we never received */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\n\t\t\t\t\t/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */\n\t\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) {\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t} else { /* we are in DHM mode */\n\t\t\t\t\t/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpDHPartMessage_t *peerDHPartMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H1 = SHA256(H0) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\t\t\t\t\tif (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the DHPart message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmessageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);\n\t\t\t\tconfirmPlainMessage += 2;\n\t\t\t\tmessageData->E = ((*confirmPlainMessage)&0x08)>>3;\n\t\t\t\tmessageData->V = ((*confirmPlainMessage)&0x04)>>2;\n\t\t\t\tmessageData->A = ((*confirmPlainMessage)&0x02)>>1;\n\t\t\t\tmessageData->D = (*confirmPlainMessage)&0x01;\n\t\t\t\tconfirmPlainMessage += 1;\n\n\t\t\t\tmessageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);\n\t\t\t\tconfirmPlainMessage += 4;\n\n\n\t\t\t\t/* if sig_len indicate a signature, parse it */\n\t\t\t\tif (messageData->sig_len>0) {\n\t\t\t\t\tmemcpy(messageData->signatureBlockType, confirmPlainMessage, 4);\n\t\t\t\t\tconfirmPlainMessage += 4;\n\t\t\t\t\t/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */\n\t\t\t\t\tmessageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));\n\t\t\t\t\tmemcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));\n\t\t\t\t} else {\n\t\t\t\t\tmessageData->signatureBlock  = NULL;\n\t\t\t\t}\n\n\t\t\t\t/* free plain buffer */\n\t\t\t\tfree(confirmPlainMessageBuffer);\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to check correct packet repetition */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK:\n\t\t\t/* nothing to do for this one */\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\t\t\n\t\tcase MSGTYPE_PING:\n\t\t\t{\n\t\t\t\t/* allocate a ping message structure */\n\t\t\t\tbzrtpPingMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->endpointHash, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_PING */\n\n\t}\n\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void PrintPreviewDataService::GetDataEntry(\n    const std::string& preview_ui_addr_str,\n     int index,\n     scoped_refptr<base::RefCountedBytes>* data_bytes) {\n   *data_bytes = NULL;\n  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);\n   if (it != data_store_map_.end())\n     it->second->GetPreviewDataForIndex(index, data_bytes);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual void TearDown() {\n    vp9_worker_end(&worker_);\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MagickExport Image *SpliceImage(const Image *image,\n  const RectangleInfo *geometry,ExceptionInfo *exception)\n{\n#define SpliceImageTag  \"Splice/Image\"\n\n  CacheView\n    *image_view,\n    *splice_view;\n\n  Image\n    *splice_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n     splice_geometry;\n \n   ssize_t\n     y;\n \n   /*\n    Allocate splice image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  splice_geometry=(*geometry);\n  splice_image=CloneImage(image,image->columns+splice_geometry.width,\n    image->rows+splice_geometry.height,MagickTrue,exception);\n  if (splice_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(splice_image,DirectClass,exception) == MagickFalse)\n    {\n      splice_image=DestroyImage(splice_image);\n      return((Image *) NULL);\n    }\n  if ((IsPixelInfoGray(&splice_image->background_color) == MagickFalse) &&\n      (IsGrayColorspace(splice_image->colorspace) != MagickFalse))\n    (void) SetImageColorspace(splice_image,sRGBColorspace,exception);\n  if ((splice_image->background_color.alpha_trait != UndefinedPixelTrait) &&\n      (splice_image->alpha_trait == UndefinedPixelTrait))\n    (void) SetImageAlpha(splice_image,OpaqueAlpha,exception);\n  (void) SetImageBackgroundColor(splice_image,exception);\n  /*\n    Respect image geometry.\n  */\n  switch (image->gravity)\n  {\n    default:\n    case UndefinedGravity:\n    case NorthWestGravity:\n      break;\n    case NorthGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      break;\n    }\n    case NorthEastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      break;\n    }\n    case WestGravity:\n    {\n      splice_geometry.y+=(ssize_t) splice_geometry.width/2;\n      break;\n    }\n    case CenterGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      splice_geometry.y+=(ssize_t) splice_geometry.height/2;\n      break;\n    }\n    case EastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      splice_geometry.y+=(ssize_t) splice_geometry.height/2;\n      break;\n    }\n    case SouthWestGravity:\n    {\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n    case SouthGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n    case SouthEastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n  }\n  /*\n    Splice image.\n   */\n   status=MagickTrue;\n   progress=0;\n   image_view=AcquireVirtualCacheView(image,exception);\n   splice_view=AcquireAuthenticCacheView(splice_image,exception);\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,splice_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) splice_geometry.y; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n \n     if (status == MagickFalse)\n       continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n     q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,\n       exception);\n     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n       {\n         status=MagickFalse;\n         continue;\n       }\n    for (x=0; x < splice_geometry.x; x++)\n     {\n       register ssize_t\n         i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    for ( ; x < (ssize_t) (splice_geometry.x+splice_geometry.width); x++)\n      q+=GetPixelChannels(splice_image);\n    for ( ; x < (ssize_t) splice_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    if (SyncCacheViewAuthenticPixels(splice_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransposeImage)\n#endif\n        proceed=SetImageProgress(image,SpliceImageTag,progress++,\n          splice_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,splice_image,1,1)\n#endif\n  for (y=(ssize_t) (splice_geometry.y+splice_geometry.height);\n       y < (ssize_t) splice_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n \n     if (status == MagickFalse)\n       continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y-(ssize_t) splice_geometry.height,\n      image->columns,1,exception);\n    if ((y < 0) || (y >= (ssize_t) splice_image->rows))\n       continue;\n     q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,\n       exception);\n     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n       {\n         status=MagickFalse;\n         continue;\n       }\n    for (x=0; x < splice_geometry.x; x++)\n     {\n       register ssize_t\n         i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    for ( ; x < (ssize_t) (splice_geometry.x+splice_geometry.width); x++)\n      q+=GetPixelChannels(splice_image);\n    for ( ; x < (ssize_t) splice_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    if (SyncCacheViewAuthenticPixels(splice_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransposeImage)\n#endif\n        proceed=SetImageProgress(image,SpliceImageTag,progress++,\n          splice_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  splice_view=DestroyCacheView(splice_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    splice_image=DestroyImage(splice_image);\n  return(splice_image);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)\n{\n    ExceptionCode ignoredExceptionCode;\n    RefPtr<Node> nextChild;\n    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {\n        nextChild = child->nextSibling();\n        element->removeChild(child.get(), ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n        fragment->insertBefore(child, element, ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n    }\n    fragment->removeChild(element, ignoredExceptionCode);\n    ASSERT(!ignoredExceptionCode);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "nfs4_state_start(void)\n{\n\tint ret;\n\n\tret = set_callback_cred();\n\tif (ret)\n\t\treturn ret;\n\n\tlaundry_wq = alloc_workqueue(\"%s\", WQ_UNBOUND, 0, \"nfsd4\");\n\tif (laundry_wq == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_cleanup_cred;\n\t}\n\tret = nfsd4_create_callback_queue();\n\tif (ret)\n\t\tgoto out_free_laundry;\n\n\tset_max_delegations();\n\treturn 0;\n\nout_free_laundry:\n\tdestroy_workqueue(laundry_wq);\nout_cleanup_cred:\n\tcleanup_callback_cred();\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-404"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)\n{\n    RenderStyle* oldStyle = style();\n \n     setReplaced(newStyle.isDisplayInlineType());\n \n    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()) {\n         if (newStyle.position() == StaticPosition)\n            removePositionedObjects(0, NewContainingBlock);\n        else if (oldStyle->position() == StaticPosition) {\n            RenderObject* cb = parent();\n            while (cb && (cb->style()->position() == StaticPosition || (cb->isInline() && !cb->isReplaced())) && !cb->isRenderView()) {\n                if (cb->style()->position() == RelativePosition && cb->isInline() && !cb->isReplaced()) {\n                    cb = cb->containingBlock();\n                    break;\n                }\n                cb = cb->parent();\n            }\n\n            if (cb->isRenderBlock())\n                toRenderBlock(cb)->removePositionedObjects(this, NewContainingBlock);\n        }\n    }\n\n    RenderBox::styleWillChange(diff, newStyle);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ProcRenderAddGlyphs (ClientPtr client)\n{\n    GlyphSetPtr     glyphSet;\n    REQUEST(xRenderAddGlyphsReq);\n    GlyphNewRec\t    glyphsLocal[NLOCALGLYPH];\n    GlyphNewPtr\t    glyphsBase, glyphs, glyph_new;\n    int\t\t    remain, nglyphs;\n    CARD32\t    *gids;\n    xGlyphInfo\t    *gi;\n    CARD8\t    *bits;\n    unsigned int    size;\n    int\t\t    err;\n    int\t\t    i, screen;\n    PicturePtr\t    pSrc = NULL, pDst = NULL;\n    PixmapPtr\t    pSrcPix = NULL, pDstPix = NULL;\n    CARD32\t    component_alpha;\n\n    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);\n    err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,\n\t\t\t    client, DixAddAccess);\n    if (err != Success)\n    {\n\tclient->errorValue = stuff->glyphset;\n\treturn err;\n    }\n\n    err = BadAlloc;\n    nglyphs = stuff->nglyphs;\n    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))\n\t    return BadAlloc;\n\n    component_alpha = NeedsComponent (glyphSet->format->format);\n\n    if (nglyphs <= NLOCALGLYPH) {\n\tmemset (glyphsLocal, 0, sizeof (glyphsLocal));\n\tglyphsBase = glyphsLocal;\n    }\n    else\n    {\n\tglyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));\n\tif (!glyphsBase)\n\t    return BadAlloc;\n    }\n\n    remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);\n\n    glyphs = glyphsBase;\n\n    gids = (CARD32 *) (stuff + 1);\n     gi = (xGlyphInfo *) (gids + nglyphs);\n     bits = (CARD8 *) (gi + nglyphs);\n     remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;\n     for (i = 0; i < nglyphs; i++)\n     {\n \tsize_t padded_width;\n\tsize = gi[i].height * padded_width;\n\tif (remain < size)\n\t    break;\n\n\terr = HashGlyph (&gi[i], bits, size, glyph_new->sha1);\n\tif (err)\n\t    goto bail;\n\n\tglyph_new->glyph = FindGlyphByHash (glyph_new->sha1,\n\t\t\t\t\t    glyphSet->fdepth);\n\n\tif (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)\n\t{\n\t    glyph_new->found = TRUE;\n\t}\n\telse\n\t{\n\t    GlyphPtr glyph;\n\n\t    glyph_new->found = FALSE;\n\t    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);\n\t    if (! glyph)\n\t    {\n\t\terr = BadAlloc;\n\t\tgoto bail;\n\t    }\n\n\t    for (screen = 0; screen < screenInfo.numScreens; screen++)\n\t    {\n\t\tint\t    width = gi[i].width;\n\t\tint\t    height = gi[i].height;\n\t\tint\t    depth = glyphSet->format->depth;\n\t\tScreenPtr   pScreen;\n\t\tint\t    error;\n\n\t\t/* Skip work if it's invisibly small anyway */\n\t\tif (!width || !height)\n\t\t    break;\n\n\t\tpScreen = screenInfo.screens[screen];\n\t\tpSrcPix = GetScratchPixmapHeader (pScreen,\n\t\t\t\t\t\t  width, height,\n\t\t\t\t\t\t  depth, depth,\n\t\t\t\t\t\t  -1, bits);\n\t\tif (! pSrcPix)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tpSrc = CreatePicture (0, &pSrcPix->drawable,\n\t\t\t\t      glyphSet->format, 0, NULL,\n\t\t\t\t      serverClient, &error);\n\t\tif (! pSrc)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tpDstPix = (pScreen->CreatePixmap) (pScreen,\n\t\t\t\t\t\t   width, height, depth,\n\t\t\t\t\t\t   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);\n\n\t\tif (!pDstPix)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tGlyphPicture (glyph)[screen] = pDst =\n\t\t\tCreatePicture (0, &pDstPix->drawable,\n\t\t\t\t       glyphSet->format,\n\t\t\t\t       CPComponentAlpha, &component_alpha,\n\t\t\t\t       serverClient, &error);\n\n\t\t/* The picture takes a reference to the pixmap, so we\n\t\t   drop ours. */\n\t\t(pScreen->DestroyPixmap) (pDstPix);\n\t\tpDstPix = NULL;\n\n\t\tif (! pDst)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tCompositePicture (PictOpSrc,\n\t\t\t\t  pSrc,\n\t\t\t\t  None,\n\t\t\t\t  pDst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  width, height);\n\n\t\tFreePicture ((pointer) pSrc, 0);\n\t\tpSrc = NULL;\n\t\tFreeScratchPixmapHeader (pSrcPix);\n\t\tpSrcPix = NULL;\n\t    }\n\n\t    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);\n\t}\n\n\tglyph_new->id = gids[i];\n\t\n\tif (size & 3)\n\t    size += 4 - (size & 3);\n\tbits += size;\n\tremain -= size;\n    }\n    if (remain || i < nglyphs)\n    {\n\terr = BadLength;\n\tgoto bail;\n    }\n    if (!ResizeGlyphSet (glyphSet, nglyphs))\n    {\n\terr = BadAlloc;\n\tgoto bail;\n    }\n    for (i = 0; i < nglyphs; i++)\n\tAddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);\n\n    if (glyphsBase != glyphsLocal)\n\tfree(glyphsBase);\n    return Success;\nbail:\n    if (pSrc)\n\tFreePicture ((pointer) pSrc, 0);\n    if (pSrcPix)\n\tFreeScratchPixmapHeader (pSrcPix);\n    for (i = 0; i < nglyphs; i++)\n\tif (glyphs[i].glyph && ! glyphs[i].found)\n\t    free(glyphs[i].glyph);\n    if (glyphsBase != glyphsLocal)\n\tfree(glyphsBase);\n    return err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)\n{\n\tstruct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,\n                                                struct ctdb_tcp);\n         ctdb_sock_addr sock;\n        int lock_fd, i;\n       const char *lock_path = \"/tmp/.ctdb_socket_lock\";\n        struct flock lock;\n        int one = 1;\n        int sock_size;\n\tstruct tevent_fd *fde;\n\n\t/* If there are no nodes, then it won't be possible to find\n\t * the first one.  Log a failure and short circuit the whole\n\t * process.\n\t */\n\tif (ctdb->num_nodes == 0) {\n\t\tDEBUG(DEBUG_CRIT,(\"No nodes available to attempt bind to - is the nodes file empty?\\n\"));\n\t\treturn -1;\n\t}\n\n\t/* in order to ensure that we don't get two nodes with the\n\t   same adddress, we must make the bind() and listen() calls\n\t   atomic. The SO_REUSEADDR setsockopt only prevents double\n\t   binds if the first socket is in LISTEN state  */\n\tlock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);\n\tif (lock_fd == -1) {\n\t\tDEBUG(DEBUG_CRIT,(\"Unable to open %s\\n\", lock_path));\n\t\treturn -1;\n\t}\n\n\tlock.l_type = F_WRLCK;\n\tlock.l_whence = SEEK_SET;\n\tlock.l_start = 0;\n\tlock.l_len = 1;\n\tlock.l_pid = 0;\n\n\tif (fcntl(lock_fd, F_SETLKW, &lock) != 0) {\n\t\tDEBUG(DEBUG_CRIT,(\"Unable to lock %s\\n\", lock_path));\n\t\tclose(lock_fd);\n\t\treturn -1;\n\t}\n\n\tfor (i=0; i < ctdb->num_nodes; i++) {\n\t\tif (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {\n\t\t\tcontinue;\n\t\t}\n\t\tZERO_STRUCT(sock);\n\t\tif (ctdb_tcp_get_address(ctdb,\n\t\t\t\tctdb->nodes[i]->address.address, \n\t\t\t\t&sock) != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tswitch (sock.sa.sa_family) {\n\t\tcase AF_INET:\n\t\t\tsock.ip.sin_port = htons(ctdb->nodes[i]->address.port);\n\t\t\tsock_size = sizeof(sock.ip);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tsock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);\n\t\t\tsock_size = sizeof(sock.ip6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG(DEBUG_ERR, (__location__ \" unknown family %u\\n\",\n\t\t\t\tsock.sa.sa_family));\n\t\t\tcontinue;\n\t\t}\n#ifdef HAVE_SOCK_SIN_LEN\n\t\tsock.ip.sin_len = sock_size;\n#endif\n\n\t\tctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);\n\t\tif (ctcp->listen_fd == -1) {\n\t\t\tctdb_set_error(ctdb, \"socket failed\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_close_on_exec(ctcp->listen_fd);\n\n\t        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));\n\n\t\tif (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\tDEBUG(DEBUG_DEBUG,(__location__ \" Failed to bind() to socket. %s(%d)\\n\",\n\t\t\t\t\tstrerror(errno), errno));\n\t\t} else {\n\t\t\tDEBUG(DEBUG_ERR,(__location__ \" Failed to bind() to socket. %s(%d)\\n\",\n\t\t\t\t\tstrerror(errno), errno));\n\t\t}\n\t}\n\t\n\tif (i == ctdb->num_nodes) {\n\t\tDEBUG(DEBUG_CRIT,(\"Unable to bind to any of the node addresses - giving up\\n\"));\n\t\tgoto failed;\n\t}\n\tctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);\n\tctdb->address.port    = ctdb->nodes[i]->address.port;\n\tctdb->name = talloc_asprintf(ctdb, \"%s:%u\", \n\t\t\t\t     ctdb->address.address, \n\t\t\t\t     ctdb->address.port);\n\tctdb->pnn = ctdb->nodes[i]->pnn;\n\tDEBUG(DEBUG_INFO,(\"ctdb chose network address %s:%u pnn %u\\n\", \n\t\t ctdb->address.address, \n\t\t ctdb->address.port, \n\t\t ctdb->pnn));\n\t\n\tif (listen(ctcp->listen_fd, 10) == -1) {\n\t\tgoto failed;\n\t}\n\n\tfde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,\n\t\t\t   ctdb_listen_event, ctdb);\n\ttevent_fd_set_auto_close(fde);\n\n\tclose(lock_fd);\n\n\treturn 0;\n\t\nfailed:\n\tclose(lock_fd);\n\tclose(ctcp->listen_fd);\n\tctcp->listen_fd = -1;\n\treturn -1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "load_mac_face( FT_Library           library,\n                 FT_Stream            stream,\n                 FT_Long              face_index,\n                 FT_Face             *aface,\n                 const FT_Open_Args  *args )\n  {\n    FT_Error error;\n    FT_UNUSED( args );\n\n\n    error = IsMacBinary( library, stream, face_index, aface );\n    if ( FT_ERROR_BASE( error ) == FT_Err_Unknown_File_Format )\n    {\n\n#undef  FT_COMPONENT\n#define FT_COMPONENT  trace_raccess\n\n      FT_TRACE3(( \"Try as dfont: %s ...\", args->pathname ));\n\n      error = IsMacResource( library, stream, 0, face_index, aface );\n\n      FT_TRACE3(( \"%s\\n\", error ? \"failed\" : \"successful\" ));\n\n#undef  FT_COMPONENT\n#define FT_COMPONENT  trace_objs\n\n    }\n\n    if ( ( FT_ERROR_BASE( error ) == FT_Err_Unknown_File_Format      ||\n           FT_ERROR_BASE( error ) == FT_Err_Invalid_Stream_Operation ) &&\n         ( args->flags & FT_OPEN_PATHNAME )                            )\n      error = load_face_in_embedded_rfork( library, stream,\n                                           face_index, aface, args );\n    return error;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MaxTextExtent],\n    text[MaxTextExtent];\n\n  Image\n    *image;\n\n  IndexPacket\n    *indexes;\n\n  long\n    x_offset,\n    y_offset;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    pixel;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     image->columns=width;\n     image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)\n      if (depth >= 64)\n        break;\n     image->depth=depth;\n     status=SetImageExtent(image,image->columns,image->rows);\n     if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->matte=MagickFalse;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->matte=MagickTrue;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->colorspace=(ColorspaceType) type;\n    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n    (void) SetImageBackgroundColor(image);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        blue,\n        green,\n        index,\n        opacity,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      index=0.0;\n      opacity=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",&x_offset,\n                  &y_offset,&red,&opacity);\n                green=red;\n                blue=red;\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,&y_offset,&red);\n            green=red;\n            blue=red;\n            break;\n          }\n          case CMYKColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\n                break;\n              }\n            (void) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&index);\n            break;\n          }\n          default:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&opacity);\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n              &x_offset,&y_offset,&red,&green,&blue);\n            break;\n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            index*=0.01*range;\n            opacity*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),\n          range);\n        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+\n          0.5),range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          continue;\n        SetPixelRed(q,pixel.red);\n        SetPixelGreen(q,pixel.green);\n        SetPixelBlue(q,pixel.blue);\n        if (image->colorspace == CMYKColorspace)\n          {\n            indexes=GetAuthenticIndexQueue(image);\n            SetPixelIndex(indexes,pixel.index);\n          }\n        if (image->matte != MagickFalse)\n          SetPixelAlpha(q,pixel.opacity);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static struct page *alloc_gigantic_page(struct hstate *h, gfp_t gfp_mask,\n\t\tint nid, nodemask_t *nodemask) { return NULL; }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "dissect_DEVMODE_CTR(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tguint32 size;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DEVMODE_CTR, NULL, \"Devicemode container\");\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, subtree, di, drep,\n\t\t\t\t    hf_devmodectr_size, &size);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\tdissect_DEVMODE, NDR_POINTER_UNIQUE, \"Devicemode\", -1);\n\n\treturn offset;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n \n \tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n \tif (ret < 0) {\n\t\tops->destroy(dev);\n \t\tmutex_lock(&kvm->lock);\n \t\tlist_del(&dev->vm_node);\n \t\tmutex_unlock(&kvm->lock);\n \t\treturn ret;\n \t}\n \n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BookmarksIOFunction::ShowSelectFileDialog(\n     ui::SelectFileDialog::Type type,\n     const base::FilePath& default_path) {\n   AddRef();\n\n  WebContents* web_contents = dispatcher()->delegate()->\n      GetAssociatedWebContents();\n\n  select_file_dialog_ = ui::SelectFileDialog::Create(\n      this, new ChromeSelectFilePolicy(web_contents));\n  ui::SelectFileDialog::FileTypeInfo file_type_info;\n  file_type_info.extensions.resize(1);\n  file_type_info.extensions[0].push_back(FILE_PATH_LITERAL(\"html\"));\n  if (type == ui::SelectFileDialog::SELECT_OPEN_FILE)\n    file_type_info.support_drive = true;\n  select_file_dialog_->SelectFile(type,\n                                  string16(),\n                                  default_path,\n                                  &file_type_info,\n                                  0,\n                                  FILE_PATH_LITERAL(\"\"),\n                                  NULL,\n                                  NULL);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool AXObject::isDescendantOfLeafNode() const {\n  updateCachedAttributeValuesIfNeeded();\n  return m_cachedIsDescendantOfLeafNode;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int _nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_statfs_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_statfs_res res = {\n\t\t.fsstat = fsstat,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_STATFS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fsstat->fattr);\n\treturn  nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MagickExport MagickBooleanType ThrowMagickException(ExceptionInfo *exception,\n  const char *module,const char *function,const size_t line,\n  const ExceptionType severity,const char *tag,const char *format,...)\n{\n  MagickBooleanType\n    status;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  status=ThrowMagickExceptionList(exception,module,function,line,severity,tag,\n    format,operands);\n  va_end(operands);\n  return(status);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "_WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n     uint32_t hmi_tmp = 0;\n     uint8_t *hmi_base = hmi_data;\n     uint16_t hmi_bpm = 0;\n     uint16_t hmi_division = 0;\n \n     uint32_t *hmi_track_offset = NULL;\n     uint32_t i = 0;\n    uint32_t j = 0;\n    uint8_t *hmi_addr = NULL;\n    uint32_t *hmi_track_header_length = NULL;\n    struct _mdi *hmi_mdi = NULL;\n    uint32_t tempo_f = 5000000.0;\n    uint32_t *hmi_track_end = NULL;\n    uint8_t hmi_tracks_ended = 0;\n    uint8_t *hmi_running_event = NULL;\n    uint32_t setup_ret = 0;\n    uint32_t *hmi_delta = NULL;\n\n    uint32_t smallest_delta = 0;\n    uint32_t subtract_delta = 0;\n\n    uint32_t sample_count = 0;\n    float sample_count_f = 0;\n    float sample_remainder = 0;\n\n    float samples_per_delta_f = 0.0;\n\n    struct _note {\n        uint32_t length;\n         uint8_t channel;\n     } *note;\n \n    UNUSED(hmi_size);\n \n     if (memcmp(hmi_data, \"HMI-MIDISONG061595\", 18)) {\n         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);\n        return NULL;\n    }\n\n    hmi_bpm = hmi_data[212];\n\n    hmi_division = 60;\n\n    hmi_track_cnt = hmi_data[228];\n\n    hmi_mdi = _WM_initMDI();\n\n    _WM_midi_setup_divisions(hmi_mdi, hmi_division);\n\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / hmi_bpm) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / hmi_bpm);\n    }\n    samples_per_delta_f = _WM_GetSamplesPerTick(hmi_division, (uint32_t)tempo_f);\n\n    _WM_midi_setup_tempo(hmi_mdi, (uint32_t)tempo_f);\n\n    hmi_track_offset = (uint32_t *)malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_track_header_length = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_track_end = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_delta = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    note = malloc(sizeof(struct _note) * 128 * hmi_track_cnt);\n    hmi_running_event = malloc(sizeof(uint8_t) * 128 * hmi_track_cnt);\n\n    hmi_data += 370;\n\n    smallest_delta = 0xffffffff;\n\n    if (hmi_size < (370 + (hmi_track_cnt * 17))) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n        goto _hmi_end;\n    }\n\n    hmi_track_offset[0] = *hmi_data; // To keep Xcode happy\n\n    for (i = 0; i < hmi_track_cnt; i++) {\n        hmi_track_offset[i] = *hmi_data++;\n        hmi_track_offset[i] += (*hmi_data++ << 8);\n        hmi_track_offset[i] += (*hmi_data++ << 16);\n        hmi_track_offset[i] += (*hmi_data++ << 24);\n\n        if (hmi_size < (hmi_track_offset[i] + 0x5a + 4)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n            goto _hmi_end;\n        }\n\n        hmi_addr = hmi_base + hmi_track_offset[i];\n\n        if (memcmp(hmi_addr, \"HMI-MIDITRACK\", 13)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);\n            goto _hmi_end;\n        }\n\n        hmi_track_header_length[i] = hmi_addr[0x57];\n        hmi_track_header_length[i] += (hmi_addr[0x58] << 8);\n        hmi_track_header_length[i] += (hmi_addr[0x59] << 16);\n        hmi_track_header_length[i] += (hmi_addr[0x5a] << 24);\n\n        hmi_addr += hmi_track_header_length[i];\n        hmi_track_offset[i] += hmi_track_header_length[i];\n\n        hmi_delta[i] = 0;\n        if (*hmi_addr > 0x7f) {\n            do {\n                hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);\n                hmi_addr++;\n                hmi_track_offset[i]++;\n            } while (*hmi_addr > 0x7f);\n        }\n        hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);\n        hmi_track_offset[i]++;\n        hmi_addr++;\n\n        if (hmi_delta[i] < smallest_delta) {\n            smallest_delta = hmi_delta[i];\n        }\n\n        hmi_track_end[i] = 0;\n        hmi_running_event[i] = 0;\n\n        for (j = 0; j < 128; j++) {\n            hmi_tmp = (128 * i) + j;\n            note[hmi_tmp].length = 0;\n            note[hmi_tmp].channel = 0;\n        }\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;\n    hmi_mdi->extra_info.approx_total_samples += sample_count;\n\n    while (hmi_tracks_ended < hmi_track_cnt) {\n        smallest_delta = 0;\n        for (i = 0; i < hmi_track_cnt; i++) {\n            if (hmi_track_end[i]) continue;\n\n            for (j = 0; j < 128; j++) {\n                hmi_tmp = (128 * i) + j;\n                if (note[hmi_tmp].length) {\n                    note[hmi_tmp].length -= subtract_delta;\n                    if (note[hmi_tmp].length) {\n                        if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {\n                            smallest_delta = note[hmi_tmp].length;\n                        }\n                    } else {\n                        _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                    }\n                }\n            }\n\n            if (hmi_delta[i]) {\n                hmi_delta[i] -= subtract_delta;\n                if (hmi_delta[i]) {\n                    if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {\n                        smallest_delta = hmi_delta[i];\n                    }\n                    continue;\n                }\n            }\n\n             do {\n                 hmi_data = hmi_base + hmi_track_offset[i];\n                 hmi_delta[i] = 0;\n \n                 if (hmi_data[0] == 0xfe) {\n                     if (hmi_data[1] == 0x10) {\n                         hmi_tmp = (hmi_data[4] + 5);\n                         hmi_data += hmi_tmp;\n                         hmi_track_offset[i] += hmi_tmp;\n                     } else if (hmi_data[1] == 0x15) {\n                         hmi_data += 4;\n                         hmi_track_offset[i] += 4;\n                     }\n                     hmi_data += 4;\n                     hmi_track_offset[i] += 4;\n                 } else {\n                    if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,hmi_running_event[i])) == 0) {\n                         goto _hmi_end;\n                     }\n                     if ((hmi_data[0] == 0xff) && (hmi_data[1] == 0x2f) && (hmi_data[2] == 0x00)) {\n                        hmi_track_end[i] = 1;\n                        hmi_tracks_ended++;\n                        for(j = 0; j < 128; j++) {\n                            hmi_tmp = (128 * i) + j;\n                            if (note[hmi_tmp].length) {\n                                _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                                note[hmi_tmp].length = 0;\n                            }\n                        }\n                        goto _hmi_next_track;\n                    }\n                    if ((*hmi_data == 0xF0) || (*hmi_data == 0xF7)) {\n                        hmi_running_event[i] = 0;\n                    } else if (*hmi_data < 0xF0) {\n                        if (*hmi_data >= 0x80) {\n                            hmi_running_event[i] = *hmi_data;\n                        }\n                    }\n                    if ((hmi_running_event[i] & 0xf0) == 0x90) {\n                        if (*hmi_data > 127) {\n                            hmi_tmp = hmi_data[1];\n                        } else {\n                            hmi_tmp = *hmi_data;\n                        }\n                        hmi_tmp += (i * 128);\n\n                        note[hmi_tmp].channel = hmi_running_event[i] & 0xf;\n \n                         hmi_data += setup_ret;\n                         hmi_track_offset[i] += setup_ret;\n \n                         note[hmi_tmp].length = 0;\n                        if (*hmi_data > 0x7f) {\n                             do {\n                                 note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                                 hmi_data++;\n                                 hmi_track_offset[i]++;\n                             } while (*hmi_data > 0x7F);\n                         }\n                         note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                         hmi_data++;\n                         hmi_track_offset[i]++;\n \n                         if (note[hmi_tmp].length) {\n                            if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {\n                                smallest_delta = note[hmi_tmp].length;\n                            }\n                        } else {\n                            _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                        }\n\n                     } else {\n                         hmi_data += setup_ret;\n                         hmi_track_offset[i] += setup_ret;\n                     }\n                 }\n \n                if (*hmi_data > 0x7f) {\n                     do {\n                         hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                         hmi_data++;\n                         hmi_track_offset[i]++;\n                     } while (*hmi_data > 0x7F);\n                 }\n                 hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                 hmi_data++;\n                 hmi_track_offset[i]++;\n             } while (!hmi_delta[i]);\n             if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {\n                smallest_delta = hmi_delta[i];\n            }\n\n        _hmi_next_track:\n            hmi_tmp = 0;\n            UNUSED(hmi_tmp);\n        }\n\n        subtract_delta = smallest_delta;\n        sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n        sample_count = (uint32_t) sample_count_f;\n        sample_remainder = sample_count_f - (float) sample_count;\n\n        hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;\n        hmi_mdi->extra_info.approx_total_samples += sample_count;\n    }\n\n    if ((hmi_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _hmi_end;\n    }\n\n    hmi_mdi->extra_info.current_sample = 0;\n    hmi_mdi->current_event = &hmi_mdi->events[0];\n    hmi_mdi->samples_to_mix = 0;\n    hmi_mdi->note = NULL;\n\n    _WM_ResetToStart(hmi_mdi);\n\n_hmi_end:\n    free(hmi_track_offset);\n    free(hmi_track_header_length);\n    free(hmi_track_end);\n    free(hmi_delta);\n    free(note);\n    free(hmi_running_event);\n\n    if (hmi_mdi->reverb) return (hmi_mdi);\n    _WM_freeMDI(hmi_mdi);\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int paravirt_disable_iospace(void)\n{\n\treturn request_resource(&ioport_resource, &reserve_ioports);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int kvm_io_bus_sort_cmp(const void *p1, const void *p2)\n{\n\treturn kvm_io_bus_cmp(p1, p2);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)\n{\n\tstruct iphdr *iph;\n\tint room;\n\tstruct icmp_bxm icmp_param;\n\tstruct rtable *rt = skb_rtable(skb_in);\n\tstruct ipcm_cookie ipc;\n\t__be32 saddr;\n\tu8  tos;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tif (!rt)\n\t\tgoto out;\n\tnet = dev_net(rt->dst.dev);\n\n\t/*\n\t *\tFind the original header. It is expected to be valid, of course.\n\t *\tCheck this, icmp_send is called from the most obscure devices\n\t *\tsometimes.\n\t */\n\tiph = ip_hdr(skb_in);\n\n\tif ((u8 *)iph < skb_in->head ||\n\t    (skb_in->network_header + sizeof(*iph)) > skb_in->tail)\n\t\tgoto out;\n\n\t/*\n\t *\tNo replies to physical multicast/broadcast\n\t */\n\tif (skb_in->pkt_type != PACKET_HOST)\n\t\tgoto out;\n\n\t/*\n\t *\tNow check at the protocol level\n\t */\n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto out;\n\n\t/*\n\t *\tOnly reply to fragment 0. We byte re-order the constant\n\t *\tmask for efficiency.\n\t */\n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\tgoto out;\n\n\t/*\n\t *\tIf we send an ICMP error to an ICMP error a mess would result..\n\t */\n\tif (icmp_pointers[type].error) {\n\t\t/*\n\t\t *\tWe are an error, check if we are replying to an\n\t\t *\tICMP error\n\t\t */\n\t\tif (iph->protocol == IPPROTO_ICMP) {\n\t\t\tu8 _inner_type, *itp;\n\n\t\t\titp = skb_header_pointer(skb_in,\n\t\t\t\t\t\t skb_network_header(skb_in) +\n\t\t\t\t\t\t (iph->ihl << 2) +\n\t\t\t\t\t\t offsetof(struct icmphdr,\n\t\t\t\t\t\t\t  type) -\n\t\t\t\t\t\t skb_in->data,\n\t\t\t\t\t\t sizeof(_inner_type),\n\t\t\t\t\t\t &_inner_type);\n\t\t\tif (itp == NULL)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t *\tAssume any unknown ICMP type is an error. This\n\t\t\t *\tisn't specified by the RFC, but think about it..\n\t\t\t */\n\t\t\tif (*itp > NR_ICMP_TYPES ||\n\t\t\t    icmp_pointers[*itp].error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\n\t/*\n\t *\tConstruct source address and options.\n\t */\n\n\tsaddr = iph->daddr;\n\tif (!(rt->rt_flags & RTCF_LOCAL)) {\n\t\tstruct net_device *dev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (rt_is_input_route(rt) &&\n\t\t    net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)\n\t\t\tdev = dev_get_by_index_rcu(net, rt->rt_iif);\n\n\t\tif (dev)\n\t\t\tsaddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);\n\t\telse\n\t\t\tsaddr = 0;\n\t\trcu_read_unlock();\n\t}\n\n\ttos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |\n \t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n \t\t\t\t\t  iph->tos;\n \n\tif (ip_options_echo(&icmp_param.replyopts, skb_in))\n \t\tgoto out_unlock;\n \n \n\t/*\n\t *\tPrepare data for ICMP header.\n\t */\n\n\ticmp_param.data.icmph.type\t = type;\n\ticmp_param.data.icmph.code\t = code;\n\ticmp_param.data.icmph.un.gateway = info;\n\ticmp_param.data.icmph.checksum\t = 0;\n\ticmp_param.skb\t  = skb_in;\n \ticmp_param.offset = skb_network_offset(skb_in);\n \tinet_sk(sk)->tos = tos;\n \tipc.addr = iph->saddr;\n\tipc.opt = &icmp_param.replyopts;\n \tipc.tx_flags = 0;\n \n \trt = icmp_route_lookup(net, skb_in, iph, saddr, tos,\n\t\t\t       type, code, &icmp_param);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\n\tif (!icmpv4_xrlim_allow(net, rt, type, code))\n\t\tgoto ende;\n\n\t/* RFC says return as much as we can without exceeding 576 bytes. */\n\n \troom = dst_mtu(&rt->dst);\n \tif (room > 576)\n \t\troom = 576;\n\troom -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;\n \troom -= sizeof(struct icmphdr);\n \n \ticmp_param.data_len = skb_in->len - icmp_param.offset;\n\tif (icmp_param.data_len > room)\n\t\ticmp_param.data_len = room;\n\ticmp_param.head_len = sizeof(struct icmphdr);\n\n\ticmp_push_reply(&icmp_param, &ipc, &rt);\nende:\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout:;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "raptor_libxml_xmlStructuredError_handler_parsing(void *user_data,\n                                                 xmlErrorPtr err)\n{\n  raptor_sax2* sax2 = NULL;\n\n  /* user_data may point to a raptor_sax2* */\n  if(user_data) {\n    sax2 = (raptor_sax2*)user_data;\n    if(sax2->magic != RAPTOR_LIBXML_MAGIC)\n      sax2 = NULL;\n  }\n  \n  /* err->ctxt->userData may point to a raptor_sax2* */\n  if(err && err->ctxt) {\n    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr)err->ctxt;\n    if(ctxt->userData) {\n      sax2 = (raptor_sax2*)ctxt->userData;\n      if(sax2->magic != RAPTOR_LIBXML_MAGIC)\n        sax2 = NULL;\n    }\n  }\n\n  if(sax2)\n    raptor_libxml_xmlStructuredError_handler_common(sax2->world, sax2->locator,\n                                                    err);\n  else\n    raptor_libxml_xmlStructuredError_handler_common(NULL, NULL, err);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void RenderFrameImpl::didFailLoad(blink::WebLocalFrame* frame,\n                                  const blink::WebURLError& error,\n                                  blink::WebHistoryCommitType commit_type) {\n  TRACE_EVENT1(\"navigation\", \"RenderFrameImpl::didFailLoad\",\n               \"id\", routing_id_);\n  DCHECK(!frame_ || frame_ == frame);\n  WebDataSource* ds = frame->dataSource();\n  DCHECK(ds);\n\n  FOR_EACH_OBSERVER(RenderViewObserver, render_view_->observers(),\n                    DidFailLoad(frame, error));\n\n  const WebURLRequest& failed_request = ds->request();\n  base::string16 error_description;\n  GetContentClient()->renderer()->GetNavigationErrorStrings(\n      render_view_.get(),\n      frame,\n      failed_request,\n      error,\n      NULL,\n      &error_description);\n  Send(new FrameHostMsg_DidFailLoadWithError(routing_id_,\n                                             failed_request.url(),\n                                             error.reason,\n                                             error_description,\n                                             error.wasIgnoredByHandler));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "virtual void DoCloseFlushPendingWriteTest(SocketStreamEvent* event) {\n    for (size_t i = 0; i < messages_.size(); i++) {\n      std::vector<char> frame;\n      frame.push_back('\\0');\n      frame.insert(frame.end(), messages_[i].begin(), messages_[i].end());\n      frame.push_back('\\xff');\n      EXPECT_TRUE(event->socket->SendData(&frame[0], frame.size()));\n    }\n    event->socket->Close();\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void WebRuntimeFeatures::enableSpeechSynthesis(bool enable)\n{\n    RuntimeEnabledFeatures::setSpeechSynthesisEnabled(enable);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-94"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "JSObject* createSyntaxError(ExecState* exec, const UString& message)\n{\n    return createSyntaxError(exec->lexicalGlobalObject(), message);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void btif_config_flush(void) {\n  assert(config != NULL);\n  assert(alarm_timer != NULL);\n\n \n   alarm_cancel(alarm_timer);\n \n  pthread_mutex_lock(&lock);\n  config_save(config, CONFIG_FILE_PATH);\n  pthread_mutex_unlock(&lock);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md)\n\t{\n\tx->crl->enc.modified = 1;\n\treturn(ASN1_item_sign(ASN1_ITEM_rptr(X509_CRL_INFO),x->crl->sig_alg,\n\t\tx->sig_alg, x->signature, x->crl,pkey,md));\n\t}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "Text* FrameSelectionTest::AppendTextNode(const String& data) {\n  Text* text = GetDocument().createTextNode(data);\n  GetDocument().body()->AppendChild(text);\n  return text;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int nfs4_get_referral(struct inode *dir, const struct qstr *name,\n\t\t\t     struct nfs_fattr *fattr, struct nfs_fh *fhandle)\n{\n\tint status = -ENOMEM;\n\tstruct page *page = NULL;\n\tstruct nfs4_fs_locations *locations = NULL;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (locations == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_proc_fs_locations(dir, name, locations, page);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Make sure server returned a different fsid for the referral */\n\tif (nfs_fsid_equal(&NFS_SERVER(dir)->fsid, &locations->fattr.fsid)) {\n\t\tdprintk(\"%s: server did not return a different fsid for\"\n\t\t\t\" a referral at %s\\n\", __func__, name->name);\n\t\tstatus = -EIO;\n\t\tgoto out;\n\t}\n\t/* Fixup attributes for the nfs_lookup() call to nfs_fhget() */\n\tnfs_fixup_referral_attributes(&locations->fattr);\n\n\t/* replace the lookup nfs_fattr with the locations nfs_fattr */\n\tmemcpy(fattr, &locations->fattr, sizeof(struct nfs_fattr));\n\tmemset(fhandle, 0, sizeof(struct nfs_fh));\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(locations);\n\treturn status;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fsync)\n\t\treturn -EINVAL;\n\treturn sfd->file->f_op->fsync(sfd->file, start, end, datasync);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void coroutine_fn v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n     struct stat stbuf;\n     V9fsFidState *fidp;\n     V9fsPDU *pdu = opaque;\n \n     v9fs_stat_init(&v9stat);\n     err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n        goto out_nofid;\n    }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "MagickExport MagickBooleanType LevelizeImage(Image *image,\n  const double black_point,const double white_point,const double gamma,\n  ExceptionInfo *exception)\n{\n#define LevelizeImageTag  \"Levelize/Image\"\n#define LevelizeValue(x) ClampToQuantum(((MagickRealType) gamma_pow((double) \\\n  (QuantumScale*(x)),gamma))*(white_point-black_point)+black_point)\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate and initialize levels map.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      /*\n        Level colormap.\n      */\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].red=(double) LevelizeValue(image->colormap[i].red);\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].green=(double) LevelizeValue(\n          image->colormap[i].green);\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].blue=(double) LevelizeValue(image->colormap[i].blue);\n      if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)\n        image->colormap[i].alpha=(double) LevelizeValue(\n          image->colormap[i].alpha);\n    }\n  /*\n    Level image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        j;\n\n      if (GetPixelWriteMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (j=0; j < (ssize_t) GetPixelChannels(image); j++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,j);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[j]=LevelizeValue(q[j]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_LevelizeImage)\n#endif\n        proceed=SetImageProgress(image,LevelizeImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t/* caller already checks for length values that are too large */\n\topt_len = opt[1];\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2]));\n\tif (doi_def == NULL) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter < opt_len) {\n\t\tfor (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\ttag_len = tag[1];\n\t\tif (tag_len > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t/* We are already going to do all the verification\n\t\t\t * necessary at the socket layer so from our point of\n\t\t\t * view it is safe to turn these checks off (and less\n\t\t\t * work), however, the CIPSO draft says we should do\n\t\t\t * all the CIPSO validations here but it doesn't\n\t\t\t * really specify _exactly_ what we need to validate\n\t\t\t * ... so, just make it a sysctl tunable. */\n\t\t\tif (cipso_v4_rbm_strictvalid) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len > CIPSO_V4_TAG_RBM_BLEN &&\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len < CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_ENUM_BLEN &&\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&tag[4],\n\t\t\t\t\t\t\ttag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_RNG_BLEN &&\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &tag[4],\n\t\t\t\t\t\t       tag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n \t\tcase CIPSO_V4_TAG_LOCAL:\n \t\t\t/* This is a non-standard tag that we only allow for\n \t\t\t * local connections, so if the incoming interface is\n\t\t\t * not the loopback device drop the packet. */\n\t\t\tif (!(skb->dev->flags & IFF_LOOPBACK)) {\n \t\t\t\terr_offset = opt_iter;\n \t\t\t\tgoto validate_return_locked;\n \t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xsltCopyTextString(xsltTransformContextPtr ctxt, xmlNodePtr target,\n\t           const xmlChar *string, int noescape)\n{\n    xmlNodePtr copy;\n    int len;\n\n    if (string == NULL)\n\treturn(NULL);\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltCopyTextString: copy text %s\\n\",\n\t\t     string));\n#endif\n\n    /*\n    * Play safe and reset the merging mechanism for every new\n    * target node.\n    */\n    if ((target == NULL) || (target->children == NULL)) {\n\tctxt->lasttext = NULL;\n    }\n\n    /* handle coalescing of text nodes here */\n    len = xmlStrlen(string);\n    if ((ctxt->type == XSLT_OUTPUT_XML) &&\n\t(ctxt->style->cdataSection != NULL) &&\n\t(target != NULL) &&\n\t(target->type == XML_ELEMENT_NODE) &&\n\t(((target->ns == NULL) &&\n\t  (xmlHashLookup2(ctxt->style->cdataSection,\n\t\t          target->name, NULL) != NULL)) ||\n\t ((target->ns != NULL) &&\n\t  (xmlHashLookup2(ctxt->style->cdataSection,\n\t                  target->name, target->ns->href) != NULL))))\n    {\n\t/*\n\t* Process \"cdata-section-elements\".\n\t*/\n\tif ((target->last != NULL) &&\n\t    (target->last->type == XML_CDATA_SECTION_NODE))\n\t{\n\t    return(xsltAddTextString(ctxt, target->last, string, len));\n\t}\n\tcopy = xmlNewCDataBlock(ctxt->output, string, len);\n    } else if (noescape) {\n\t/*\n\t* Process \"disable-output-escaping\".\n\t*/\n\tif ((target != NULL) && (target->last != NULL) &&\n\t    (target->last->type == XML_TEXT_NODE) &&\n\t    (target->last->name == xmlStringTextNoenc))\n\t{\n\t    return(xsltAddTextString(ctxt, target->last, string, len));\n\t}\n\tcopy = xmlNewTextLen(string, len);\n\tif (copy != NULL)\n\t    copy->name = xmlStringTextNoenc;\n    } else {\n\t/*\n\t* Default processing.\n\t*/\n\tif ((target != NULL) && (target->last != NULL) &&\n\t    (target->last->type == XML_TEXT_NODE) &&\n\t    (target->last->name == xmlStringText)) {\n\t    return(xsltAddTextString(ctxt, target->last, string, len));\n \t}\n \tcopy = xmlNewTextLen(string, len);\n     }\n     if (copy != NULL) {\n\tif (target != NULL)\n\t    copy = xsltAddChild(target, copy);\n \tctxt->lasttext = copy->content;\n \tctxt->lasttsize = len;\n \tctxt->lasttuse = len;\n    } else {\n\txsltTransformError(ctxt, NULL, target,\n\t\t\t \"xsltCopyTextString: text copy failed\\n\");\n\tctxt->lasttext = NULL;\n    }\n    return(copy);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void WebGL2RenderingContextBase::texImage3D(\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLint border,\n    GLenum format,\n    GLenum type,\n    MaybeShared<DOMArrayBufferView> pixels,\n    GLuint src_offset) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                       \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   TexImageHelperDOMArrayBufferView(\n       kTexImage3D, target, level, internalformat, width, height, depth, border,\n       format, type, 0, 0, 0, pixels.View(), kNullNotReachable, src_offset);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()\n     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,\n                                 kInitialMedianInMs),\n       outstanding_recomputation_timer_(\n          base::MakeUnique<base::Timer>(false /* retain_user_task */,\n                                         false /* is_repeating */)),\n       tick_clock_(new base::DefaultTickClock()),\n       weak_ptr_factory_(this) {}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-311"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int sg_proc_seq_show_devstrs(struct seq_file *s, void *v)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\tSg_device *sdp;\n\tstruct scsi_device *scsidp;\n\tunsigned long iflags;\n\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tsdp = it ? sg_lookup_dev(it->index) : NULL;\n\tscsidp = sdp ? sdp->device : NULL;\n\tif (sdp && scsidp && (!atomic_read(&sdp->detaching)))\n\t\tseq_printf(s, \"%8.8s\\t%16.16s\\t%4.4s\\n\",\n\t\t\t   scsidp->vendor, scsidp->model, scsidp->rev);\n\telse\n\t\tseq_puts(s, \"<no active device>\\n\");\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t tail = (i << 1) + 1;\n\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t\t    __LINE__) == -1)\n\t\t\tgoto out;\n\t\tsize_t ofs = CDF_GETUINT32(p, tail);\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n \t\tif (q > e) {\n \t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n \t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int do_ebt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\tstruct ebt_replace tmp;\n\tstruct ebt_table *t;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tt = find_table_lock(sock_net(sk), tmp.name, &ret, &ebt_mutex);\n\tif (!t)\n\t\treturn ret;\n\n\tswitch(cmd) {\n\tcase EBT_SO_GET_INFO:\n\tcase EBT_SO_GET_INIT_INFO:\n\t\tif (*len != sizeof(struct ebt_replace)){\n\t\t\tret = -EINVAL;\n\t\t\tmutex_unlock(&ebt_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tif (cmd == EBT_SO_GET_INFO) {\n\t\t\ttmp.nentries = t->private->nentries;\n\t\t\ttmp.entries_size = t->private->entries_size;\n\t\t\ttmp.valid_hooks = t->valid_hooks;\n\t\t} else {\n\t\t\ttmp.nentries = t->table->nentries;\n\t\t\ttmp.entries_size = t->table->entries_size;\n\t\t\ttmp.valid_hooks = t->table->valid_hooks;\n\t\t}\n\t\tmutex_unlock(&ebt_mutex);\n\t\tif (copy_to_user(user, &tmp, *len) != 0){\n\t\t\tBUGPRINT(\"c2u Didn't work\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\n\tcase EBT_SO_GET_ENTRIES:\n\tcase EBT_SO_GET_INIT_ENTRIES:\n\t\tret = copy_everything_to_user(t, user, len, cmd);\n\t\tmutex_unlock(&ebt_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&ebt_mutex);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "NetworkNavigationThrottle(\n      base::WeakPtr<protocol::NetworkHandler> network_handler,\n      content::NavigationHandle* navigation_handle)\n      : content::NavigationThrottle(navigation_handle),\n        network_handler_(network_handler) {}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool ResetUnsyncedEntry(syncable::ModelType type,\n                          const std::string& client_tag) {\n    UserShare* share = sync_manager_.GetUserShare();\n    syncable::WriteTransaction trans(\n        FROM_HERE, syncable::UNITTEST, share->directory.get());\n    const std::string hash = BaseNode::GenerateSyncableHash(type, client_tag);\n    syncable::MutableEntry entry(&trans, syncable::GET_BY_CLIENT_TAG,\n                                 hash);\n    EXPECT_TRUE(entry.good());\n    if (!entry.Get(IS_UNSYNCED))\n      return false;\n    entry.Put(IS_UNSYNCED, false);\n    return true;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "stringprep_ucs4_to_utf8 (const uint32_t * str, ssize_t len,\n\t\t\t size_t * items_read, size_t * items_written)\n{\n  return g_ucs4_to_utf8 (str, len, (glong *) items_read,\n\t\t\t (glong *) items_written);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ALWAYS_INLINE bool GLES2DecoderImpl::CheckMultiDrawElementsVertices(\n    const char* function_name,\n    bool instanced,\n    const GLsizei* counts,\n    GLenum type,\n    const int32_t* offsets,\n    const GLsizei* primcounts,\n    GLsizei drawcount,\n    Buffer* element_array_buffer,\n    GLuint* total_max_vertex_accessed,\n    GLsizei* total_max_primcount) {\n  DCHECK_GE(drawcount, 0);\n  for (GLsizei draw_id = 0; draw_id < drawcount; ++draw_id) {\n    GLsizei count = counts[draw_id];\n    GLsizei offset = offsets[draw_id];\n    GLsizei primcount = instanced ? primcounts[draw_id] : 1;\n\n    if (count < 0) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, \"count < 0\");\n      return false;\n    }\n    if (offset < 0) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, \"offset < 0\");\n      return false;\n    }\n    if (primcount < 0) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, \"primcount < 0\");\n      return false;\n    }\n    if (count == 0 || primcount == 0) {\n      continue;\n    }\n\n    GLuint max_vertex_accessed;\n    if (!element_array_buffer->GetMaxValueForRange(\n            offset, count, type,\n            state_.enable_flags.primitive_restart_fixed_index,\n            &max_vertex_accessed)) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, function_name,\n                         \"range out of bounds for buffer\");\n      return false;\n    }\n\n    if (!IsDrawValid(function_name, max_vertex_accessed, instanced,\n                     primcount)) {\n      return false;\n    }\n\n    *total_max_vertex_accessed =\n        std::max(*total_max_vertex_accessed, max_vertex_accessed);\n    *total_max_primcount = std::max(*total_max_primcount, primcount);\n  }\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int nfc_llcp_wks_sap(char *service_name, size_t service_name_len)\n{\n\tint sap, num_wks;\n\n\tpr_debug(\"%s\\n\", service_name);\n\n\tif (service_name == NULL)\n\t\treturn -EINVAL;\n\n\tnum_wks = ARRAY_SIZE(wks);\n\n\tfor (sap = 0; sap < num_wks; sap++) {\n\t\tif (wks[sap] == NULL)\n\t\t\tcontinue;\n\n\t\tif (strncmp(wks[sap], service_name, service_name_len) == 0)\n\t\t\treturn sap;\n\t}\n\n\treturn -EINVAL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ShouldCancelAndIgnore(NavigationHandle* handle) {\n  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int llc_ui_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc;\n\n\tif (unlikely(sk == NULL))\n\t\tgoto out;\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tllc = llc_sk(sk);\n\tdprintk(\"%s: closing local(%02X) remote(%02X)\\n\", __func__,\n\t\tllc->laddr.lsap, llc->daddr.lsap);\n\tif (!llc_send_disc(sk))\n\t\tllc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tllc_sap_remove_socket(llc->sap, sk);\n\trelease_sock(sk);\n\tif (llc->dev)\n\t\tdev_put(llc->dev);\n\tsock_put(sk);\n\tllc_sk_free(sk);\nout:\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void DevToolsUIBindings::RecordEnumeratedHistogram(const std::string& name,\n                                                    int sample,\n                                                    int boundary_value) {\n   if (!(boundary_value >= 0 && boundary_value <= 100 && sample >= 0 &&\n         sample < boundary_value)) {\n    frontend_host_->BadMessageRecieved();\n    return;\n  }\n  if (name == kDevToolsActionTakenHistogram)\n    UMA_HISTOGRAM_ENUMERATION(name, sample, boundary_value);\n  else if (name == kDevToolsPanelShownHistogram)\n    UMA_HISTOGRAM_ENUMERATION(name, sample, boundary_value);\n  else\n    frontend_host_->BadMessageRecieved();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "TabContentsWrapper* CreateTabContentsWithSharedRPH(\n      TabContents* tab_contents) {\n    TabContentsWrapper* retval = Browser::TabContentsFactory(profile(),\n        tab_contents->render_view_host()->site_instance(), MSG_ROUTING_NONE,\n        NULL, NULL);\n    EXPECT_EQ(retval->tab_contents()->GetRenderProcessHost(),\n              tab_contents->GetRenderProcessHost());\n    return retval;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "OMX_ERRORTYPE SoftRaw::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.raw\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mChannelCount = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ssize_t MediaPlayerService::AudioOutput::bufferSize() const\n{\n Mutex::Autolock lock(mLock);\n if (mTrack == 0) return NO_INIT;\n return mTrack->frameCount() * mFrameSize;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int sfgets(void)\n {\n     struct pollfd pfd;\n     int pollret;\n     ssize_t readnb;\n     signed char seen_r = 0;\n    static size_t scanned;\n    static size_t readnbd;\n     \n     if (scanned > (size_t) 0U) {       /* support pipelining */\n         readnbd -= scanned;        \n        memmove(cmd, cmd + scanned, readnbd);   /* safe */\n        scanned = (size_t) 0U;\n    }\n    pfd.fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd.events = POLLIN | POLLERR | POLLHUP;\n#else\n    pfd.events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    while (scanned < cmdsize) {\n        if (scanned >= readnbd) {      /* nothing left in the buffer */\n            pfd.revents = 0;\n            while ((pollret = poll(&pfd, 1U, idletime * 1000UL)) < 0 &&\n                   errno == EINTR);\n            if (pollret == 0) {\n                return -1;\n            }\n            if (pollret <= 0 ||\n                (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n                return -2;\n            }\n            if ((pfd.revents & (POLLIN | POLLPRI)) == 0) {\n                continue;\n            }\n            if (readnbd >= cmdsize) {\n                break;\n            }\n#ifdef WITH_TLS\n            if (tls_cnx != NULL) {\n                while ((readnb = SSL_read\n                        (tls_cnx, cmd + readnbd, cmdsize - readnbd))\n                       < (ssize_t) 0 && errno == EINTR);\n            } else\n#endif\n            {\n                while ((readnb = read(clientfd, cmd + readnbd,\n                                      cmdsize - readnbd)) < (ssize_t) 0 &&\n                       errno == EINTR);\n            }\n            if (readnb <= (ssize_t) 0) {\n                return -2;\n            }\n            readnbd += readnb;\n            if (readnbd > cmdsize) {\n                return -2;\n            }\n        }\n#ifdef RFC_CONFORMANT_LINES\n        if (seen_r != 0) {\n#endif\n            if (cmd[scanned] == '\\n') {\n#ifndef RFC_CONFORMANT_LINES\n                if (seen_r != 0) {\n#endif\n                    cmd[scanned - 1U] = 0;\n#ifndef RFC_CONFORMANT_LINES\n                } else {\n                    cmd[scanned] = 0;\n                }\n#endif\n                if (++scanned >= readnbd) {   /* non-pipelined command */\n                    scanned = readnbd = (size_t) 0U;\n                }\n                return 0;\n            }\n            seen_r = 0;\n#ifdef RFC_CONFORMANT_LINES\n        }\n#endif\n        if (ISCTRLCODE(cmd[scanned])) {\n            if (cmd[scanned] == '\\r') {\n                seen_r = 1;\n            }\n#ifdef RFC_CONFORMANT_PARSER                   /* disabled by default, intentionnaly */\n            else if (cmd[scanned] == 0) {\n                cmd[scanned] = '\\n';\n            }\n#else\n            /* replace control chars with _ */\n            cmd[scanned] = '_';                \n#endif\n        }\n        scanned++;\n    }\n    die(421, LOG_WARNING, MSG_LINE_TOO_LONG);   /* don't remove this */\n    \n    return 0;                         /* to please GCC */\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "DECLAREcpFunc(cpSeparate2ContigByRow)\n{\n\ttsize_t scanlinesizein = TIFFScanlineSize(in);\n\ttsize_t scanlinesizeout = TIFFScanlineSize(out);\n\ttdata_t inbuf;\n\ttdata_t outbuf;\n\tregister uint8 *inp, *outp;\n \tregister uint32 n;\n \tuint32 row;\n \ttsample_t s;\n \n \tinbuf = _TIFFmalloc(scanlinesizein);\n \toutbuf = _TIFFmalloc(scanlinesizeout);\n\tif (!inbuf || !outbuf)\n                goto bad;\n\t_TIFFmemset(inbuf, 0, scanlinesizein);\n\t_TIFFmemset(outbuf, 0, scanlinesizeout);\n\tfor (row = 0; row < imagelength; row++) {\n\t\t/* merge channels */\n\t\tfor (s = 0; s < spp; s++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, s) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tinp = (uint8*)inbuf;\n\t\t\toutp = ((uint8*)outbuf) + s;\n\t\t\tfor (n = imagewidth; n-- > 0;) {\n\t\t\t\t*outp = *inp++;\n\t\t\t\toutp += spp;\n\t\t\t}\n\t\t}\n\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0) {\n\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t    (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 1;\nbad:\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void RegisterPropertiesCallback(IBusPanelService* panel,\n                                         IBusPropList* prop_list,\n                                         gpointer user_data) {\n    g_return_if_fail(user_data);\n    InputMethodStatusConnection* self\n        = static_cast<InputMethodStatusConnection*>(user_data);\n    self->RegisterProperties(prop_list);\n   }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_read_guest(vcpu->kvm, gpa, val, bytes);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void CL_Init( void ) {\n\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n\tCon_Init ();\n\n\tif(!com_fullyInitialized)\n\t{\n\t\tCL_ClearState();\n\t\tclc.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\t\tcl_oldGameSet = qfalse;\n\t}\n\n\tcls.realtime = 0;\n\n\tCL_InitInput ();\n\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\n\tcl_motd = Cvar_Get (\"cl_motd\", \"1\", 0);\n#endif\n\n\tcl_timeout = Cvar_Get (\"cl_timeout\", \"200\", 0);\n\n\tcl_timeNudge = Cvar_Get (\"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get (\"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_showSend = Cvar_Get (\"cl_showSend\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get (\"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_freezeDemo = Cvar_Get (\"cl_freezeDemo\", \"0\", CVAR_TEMP );\n\trcon_client_password = Cvar_Get (\"rconPassword\", \"\", CVAR_TEMP );\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_timedemo = Cvar_Get (\"timedemo\", \"0\", 0);\n\tcl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\n\tcl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\n\tcl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\n\tcl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\n\tcl_forceavidemo = Cvar_Get (\"cl_forceavidemo\", \"0\", 0);\n\n\trconAddress = Cvar_Get (\"rconAddress\", \"\", 0);\n\n\tcl_yawspeed = Cvar_Get (\"cl_yawspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_pitchspeed = Cvar_Get (\"cl_pitchspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_anglespeedkey = Cvar_Get (\"cl_anglespeedkey\", \"1.5\", 0);\n\n\tcl_maxpackets = Cvar_Get (\"cl_maxpackets\", \"30\", CVAR_ARCHIVE );\n\tcl_packetdup = Cvar_Get (\"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get (\"cl_run\", \"1\", CVAR_ARCHIVE);\n\tcl_sensitivity = Cvar_Get (\"sensitivity\", \"5\", CVAR_ARCHIVE);\n\tcl_mouseAccel = Cvar_Get (\"cl_mouseAccel\", \"0\", CVAR_ARCHIVE);\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\n\n\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\n\tCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\n\n\tcl_showMouseRate = Cvar_Get (\"cl_showmouserate\", \"0\", 0);\n \n \tcl_allowDownload = Cvar_Get (\"cl_allowDownload\", \"0\", CVAR_ARCHIVE);\n #ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n #endif\n \n \tcl_conXOffset = Cvar_Get (\"cl_conXOffset\", \"0\", 0);\n#ifdef __APPLE__\n\tcl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"0\", CVAR_ARCHIVE);\n#else\n\tcl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"1\", CVAR_ARCHIVE);\n#endif\n\n\tcl_serverStatusResendTime = Cvar_Get (\"cl_serverStatusResendTime\", \"750\", 0);\n\n\tCvar_Get (\"cg_autoswitch\", \"1\", CVAR_ARCHIVE);\n\n\tm_pitch = Cvar_Get (\"m_pitch\", \"0.022\", CVAR_ARCHIVE);\n\tm_yaw = Cvar_Get (\"m_yaw\", \"0.022\", CVAR_ARCHIVE);\n\tm_forward = Cvar_Get (\"m_forward\", \"0.25\", CVAR_ARCHIVE);\n\tm_side = Cvar_Get (\"m_side\", \"0.25\", CVAR_ARCHIVE);\n#ifdef __APPLE__\n\tm_filter = Cvar_Get (\"m_filter\", \"1\", CVAR_ARCHIVE);\n#else\n\tm_filter = Cvar_Get (\"m_filter\", \"0\", CVAR_ARCHIVE);\n#endif\n\n\tj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\n\tj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\n\tj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\n\tj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\n\tj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\n\n\tj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\n\tj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\n\tj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\n\tj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\n\tj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\n\n\tCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\n\tcl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\n\n\tCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\n\n\tcl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\n\n\tcl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\n\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\n\n\tCvar_Get (\"name\", \"UnnamedPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tcl_rate = Cvar_Get (\"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"model\", \"sarge\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"headmodel\", \"sarge\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"team_model\", \"james\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"team_headmodel\", \"*james\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"g_redTeam\", \"Stroggs\", CVAR_SERVERINFO | CVAR_ARCHIVE);\n\tCvar_Get (\"g_blueTeam\", \"Pagans\", CVAR_SERVERINFO | CVAR_ARCHIVE);\n\tCvar_Get (\"color1\",  \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"color2\", \"5\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"teamtask\", \"0\", CVAR_USERINFO );\n\tCvar_Get (\"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\tCvar_Get (\"password\", \"\", CVAR_USERINFO);\n\tCvar_Get (\"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n#ifdef USE_MUMBLE\n\tcl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\n\tcl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n\n#ifdef USE_VOIP\n\tcl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\n\tcl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\n\tcl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\n\tcl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\n\tcl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\n\tcl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\n\tcl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\n\n\tcl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\n\tCvar_CheckRange( cl_voip, 0, 1, qtrue );\n\tcl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\n\n\n\tCvar_Get (\"cg_viewsize\", \"100\", CVAR_ARCHIVE );\n\tCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\n\n\tCmd_AddCommand (\"cmd\", CL_ForwardToServer_f);\n\tCmd_AddCommand (\"configstrings\", CL_Configstrings_f);\n\tCmd_AddCommand (\"clientinfo\", CL_Clientinfo_f);\n\tCmd_AddCommand (\"snd_restart\", CL_Snd_Restart_f);\n\tCmd_AddCommand (\"vid_restart\", CL_Vid_Restart_f);\n\tCmd_AddCommand (\"disconnect\", CL_Disconnect_f);\n\tCmd_AddCommand (\"record\", CL_Record_f);\n\tCmd_AddCommand (\"demo\", CL_PlayDemo_f);\n\tCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\n\tCmd_AddCommand (\"cinematic\", CL_PlayCinematic_f);\n\tCmd_AddCommand (\"stoprecord\", CL_StopRecord_f);\n\tCmd_AddCommand (\"connect\", CL_Connect_f);\n\tCmd_AddCommand (\"reconnect\", CL_Reconnect_f);\n\tCmd_AddCommand (\"localservers\", CL_LocalServers_f);\n\tCmd_AddCommand (\"globalservers\", CL_GlobalServers_f);\n\tCmd_AddCommand (\"rcon\", CL_Rcon_f);\n\tCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\n\tCmd_AddCommand (\"ping\", CL_Ping_f );\n\tCmd_AddCommand (\"serverstatus\", CL_ServerStatus_f );\n\tCmd_AddCommand (\"showip\", CL_ShowIP_f );\n\tCmd_AddCommand (\"fs_openedList\", CL_OpenedPK3List_f );\n\tCmd_AddCommand (\"fs_referencedList\", CL_ReferencedPK3List_f );\n\tCmd_AddCommand (\"model\", CL_SetModel_f );\n\tCmd_AddCommand (\"video\", CL_Video_f );\n\tCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\n\tif( !com_dedicated->integer ) {\n\t\tCmd_AddCommand (\"sayto\", CL_Sayto_f );\n\t\tCmd_SetCommandCompletionFunc( \"sayto\", CL_CompletePlayerName );\n\t}\n\tCL_InitRef();\n\n\tSCR_Init ();\n\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\tCL_GenerateQKey();\n\tCvar_Get( \"cl_guid\", \"\", CVAR_USERINFO | CVAR_ROM );\n\tCL_UpdateGUID( NULL, 0 );\n\n\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-269"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg, int off,\n\t\t\t       int size, bool strict_alignment_once)\n{\n\tbool strict = env->strict_alignment || strict_alignment_once;\n\tconst char *pointer_desc = \"\";\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\t/* Special case, because of NET_IP_ALIGN. Given metadata sits\n\t\t * right in front, treat it the very same way.\n\t\t */\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_FLOW_KEYS:\n\t\tpointer_desc = \"flow keys \";\n\t\tbreak;\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\t/* The stack spill tracking logic in check_stack_write()\n\t\t * and check_stack_read() relies on stack accesses being\n\t\t * aligned.\n\t\t */\n\t\tstrict = true;\n\t\tbreak;\n\tcase PTR_TO_SOCKET:\n\t\tpointer_desc = \"sock \";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static ssize_t exitcode_proc_write(struct file *file,\n \t\tconst char __user *buffer, size_t count, loff_t *pos)\n {\n \tchar *end, buf[sizeof(\"nnnnn\\0\")];\n \tint tmp;\n \n\tif (copy_from_user(buf, buffer, count))\n \t\treturn -EFAULT;\n \n \ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\n\tuml_exitcode = tmp;\n\treturn count;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline void ipip_ecn_decapsulate(const struct iphdr *outer_iph,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct iphdr *inner_iph = ip_hdr(skb);\n\n\tif (INET_ECN_is_ce(outer_iph->tos))\n\t\tIP_ECN_set_ce(inner_iph);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void GfxState::textShift(double tx, double ty) {\n  double dx, dy;\n\n  textTransformDelta(tx, ty, &dx, &dy);\n  curX += dx;\n  curY += dy;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "EncodedJSValue JSC_HOST_CALL JSWebKitMutationObserverConstructor::constructJSWebKitMutationObserver(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n \n     JSObject* object = exec->argument(0).getObject();\n     if (!object) {\n        setDOMException(exec, TYPE_MISMATCH_ERR);\n        return JSValue::encode(jsUndefined());\n    }\n\n    JSWebKitMutationObserverConstructor* jsConstructor = jsCast<JSWebKitMutationObserverConstructor*>(exec->callee());\n    RefPtr<MutationCallback> callback = JSMutationCallback::create(object, jsConstructor->globalObject());\n    return JSValue::encode(asObject(toJS(exec, jsConstructor->globalObject(), WebKitMutationObserver::create(callback.release()))));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Maybe<bool> CollectValuesOrEntriesImpl(\n\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n    int count = 0;\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n \n    for (int i = 0; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n \n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n \n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n \n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n      if (get_entries) {\n        value = MakeEntryPair(isolate, index, value);\n       }\n       values_or_entries->set(count++, *value);\n     }\n \n *nof_items = count;\n return Just(true);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-704"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ScriptProcessorHandler::Process(size_t frames_to_process) {\n\n  AudioBus* input_bus = Input(0).Bus();\n  AudioBus* output_bus = Output(0).Bus();\n\n  unsigned double_buffer_index = this->DoubleBufferIndex();\n  bool is_double_buffer_index_good =\n      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&\n      double_buffer_index < output_buffers_.size();\n  DCHECK(is_double_buffer_index_good);\n  if (!is_double_buffer_index_good)\n    return;\n\n  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();\n  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();\n\n  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();\n  bool buffers_are_good =\n      output_buffer && BufferSize() == output_buffer->length() &&\n      buffer_read_write_index_ + frames_to_process <= BufferSize();\n\n  if (internal_input_bus_->NumberOfChannels())\n    buffers_are_good = buffers_are_good && input_buffer &&\n                       BufferSize() == input_buffer->length();\n\n  DCHECK(buffers_are_good);\n  if (!buffers_are_good)\n    return;\n\n  bool is_frames_to_process_good = frames_to_process &&\n                                   BufferSize() >= frames_to_process &&\n                                   !(BufferSize() % frames_to_process);\n  DCHECK(is_frames_to_process_good);\n  if (!is_frames_to_process_good)\n    return;\n\n  unsigned number_of_output_channels = output_bus->NumberOfChannels();\n\n  bool channels_are_good =\n      (number_of_input_channels == number_of_input_channels_) &&\n      (number_of_output_channels == number_of_output_channels_);\n  DCHECK(channels_are_good);\n  if (!channels_are_good)\n    return;\n\n  for (unsigned i = 0; i < number_of_input_channels; ++i)\n    internal_input_bus_->SetChannelMemory(\n        i,\n        input_buffer->getChannelData(i).View()->Data() +\n            buffer_read_write_index_,\n        frames_to_process);\n\n  if (number_of_input_channels)\n    internal_input_bus_->CopyFrom(*input_bus);\n\n  for (unsigned i = 0; i < number_of_output_channels; ++i) {\n    memcpy(output_bus->Channel(i)->MutableData(),\n           output_buffer->getChannelData(i).View()->Data() +\n               buffer_read_write_index_,\n           sizeof(float) * frames_to_process);\n  }\n\n  buffer_read_write_index_ =\n      (buffer_read_write_index_ + frames_to_process) % BufferSize();\n\n  if (!buffer_read_write_index_) {\n    MutexTryLocker try_locker(process_event_lock_);\n    if (!try_locker.Locked()) {\n      output_buffer->Zero();\n    } else if (Context()->GetExecutionContext()) {\n      if (Context()->HasRealtimeConstraint()) {\n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n            ->PostTask(BLINK_FROM_HERE,\n                       CrossThreadBind(\n                           &ScriptProcessorHandler::FireProcessEvent,\n                           CrossThreadUnretained(this), double_buffer_index_));\n       } else {\n        std::unique_ptr<WaitableEvent> waitable_event =\n            WTF::MakeUnique<WaitableEvent>();\n \n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n            ->PostTask(BLINK_FROM_HERE,\n                       CrossThreadBind(\n                           &ScriptProcessorHandler::\n                               FireProcessEventForOfflineAudioContext,\n                           CrossThreadUnretained(this), double_buffer_index_,\n                           CrossThreadUnretained(waitable_event.get())));\n \n        waitable_event->Wait();\n      }\n    }\n\n    SwapBuffers();\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int AdjustTree(\n  Rtree *pRtree,                    /* Rtree table */\n  RtreeNode *pNode,                 /* Adjust ancestry of this node. */\n  RtreeCell *pCell                  /* This cell was just inserted */\n){\n  RtreeNode *p = pNode;\n  while( p->pParent ){\n    RtreeNode *pParent = p->pParent;\n    RtreeCell cell;\n    int iCell;\n\n    if( nodeParentIndex(pRtree, p, &iCell) ){\n      return SQLITE_CORRUPT_VTAB;\n    }\n\n    nodeGetCell(pRtree, pParent, iCell, &cell);\n    if( !cellContains(pRtree, &cell, pCell) ){\n      cellUnion(pRtree, &cell, pCell);\n      nodeOverwriteCell(pRtree, pParent, &cell, iCell);\n    }\n \n    p = pParent;\n  }\n  return SQLITE_OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static inline TCGMemOp mo_64_32(TCGMemOp ot)\n{\n#ifdef TARGET_X86_64\n    return ot == MO_64 ? MO_64 : MO_32;\n#else\n    return MO_32;\n#endif\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-94"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void SetBeforeConnectResult(int result) {\n    before_connect_result_ = result;\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n     int flip, int recursion_level, int *printed_something,\n     int *need_separator, int *returnval)\n {\n\tuint32_t soffset, offset = ms->offset;\n \tuint32_t lhs;\n \tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n \tunion VALUETYPE *p = &ms->ms_value;\n \tstruct mlist ml;\n \n\tif (recursion_level >= 20) {\n \t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n \t\treturn -1;\n \t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%\"\n\t\t    SIZE_T_FORMAT \"u, \" \"nbytes=%\" SIZE_T_FORMAT \"u)\\n\",\n\t\t    m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[0] << 8) | p->hs[1];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[1] << 8) | p->hs[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[0] << 24) | (p->hl[1] << 16) |\n\t\t\t    (p->hl[2] << 8) | p->hl[3];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[3] << 24) | (p->hl[2] << 16) |\n\t\t\t    (p->hl[1] << 8) | p->hl[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[1] << 24) | (p->hl[0] << 16) |\n\t\t\t    (p->hl[3] << 8) | p->hl[2];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n \tcase FILE_INDIRECT:\n \t\tif (offset == 0)\n \t\t\treturn 0;\n \t\tif (nbytes < offset)\n \t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n \t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n \t\t    recursion_level, BINTEST, text);\n \t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n \t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n \t\tif (rv == 1) {\n \t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n \t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n \tcase FILE_USE:\n \t\tif (nbytes < offset)\n \t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n \t\t\tflip = !flip;\n \t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n \t\t\treturn -1;\n \t\t}\n \n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;\n\treturn 1;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n \t}\n \n \treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n \tRETVAL_STRINGL(replaced, (int)new_len, 0);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void btif_hl_proc_dch_close_cfm(tBTA_HL *p_data)\n\n{\n btif_hl_mdl_cb_t *p_dcb;\n btif_hl_mcl_cb_t *p_mcb;\n    UINT8                   app_idx, mcl_idx, mdl_idx;\n\n    BTIF_TRACE_DEBUG(\"%s\", __FUNCTION__);\n if (btif_hl_find_mdl_idx_using_handle(p_data->dch_close_cfm.mdl_handle,\n &app_idx, &mcl_idx, &mdl_idx ))\n {\n        p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);\n        btif_hl_release_socket(app_idx,mcl_idx,mdl_idx);\n        btif_hl_clean_mdl_cb(p_dcb);\n        p_mcb =  BTIF_HL_GET_MCL_CB_PTR(app_idx,mcl_idx);\n if (!btif_hl_num_dchs_in_use(p_mcb->mcl_handle))\n            btif_hl_start_cch_timer(app_idx, mcl_idx);\n        BTIF_TRACE_DEBUG(\" local DCH close success mdl_idx=%d\", mdl_idx);\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-284"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n \t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. */\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-476"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "R_API int r_bin_is_string(RBin *bin, ut64 va) {\n\tRBinString *string;\n\tRListIter *iter;\n\tRList *list;\n\tif (!(list = r_bin_get_strings (bin))) {\n\t\treturn false;\n\t}\n\tr_list_foreach (list, iter, string) {\n\t\tif (string->vaddr == va) {\n\t\t\treturn true;\n\t\t}\n\t\tif (string->vaddr > va) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int _yr_scan_verify_re_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  CALLBACK_ARGS callback_args;\n  RE_EXEC_FUNC exec;\n\n  int forward_matches = -1;\n  int backward_matches = -1;\n  int flags = 0;\n\n  if (STRING_IS_GREEDY_REGEXP(ac_match->string))\n    flags |= RE_FLAGS_GREEDY;\n\n  if (STRING_IS_NO_CASE(ac_match->string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  if (STRING_IS_DOT_ALL(ac_match->string))\n    flags |= RE_FLAGS_DOT_ALL;\n\n  if (STRING_IS_FAST_REGEXP(ac_match->string))\n    exec = yr_re_fast_exec;\n  else\n    exec = yr_re_exec;\n\n  if (STRING_IS_ASCII(ac_match->string))\n  {\n    forward_matches = exec(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n         NULL,\n         NULL);\n   }\n\n  if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)\n  {\n    flags |= RE_FLAGS_WIDE;\n    forward_matches = exec(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n         NULL,\n         NULL);\n   }\n\n  switch(forward_matches)\n  {\n    case -1:\n      return ERROR_SUCCESS;\n    case -2:\n      return ERROR_INSUFFICIENT_MEMORY;\n    case -3:\n      return ERROR_TOO_MANY_MATCHES;\n    case -4:\n      return ERROR_TOO_MANY_RE_FIBERS;\n    case -5:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  if (forward_matches == 0 && ac_match->backward_code == NULL)\n    return ERROR_SUCCESS;\n\n  callback_args.string = ac_match->string;\n  callback_args.context = context;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);\n\n  if (ac_match->backward_code != NULL)\n  {\n     backward_matches = exec(\n         ac_match->backward_code,\n         data + offset,\n         offset,\n         flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n         _yr_scan_match_callback,\n        (void*) &callback_args);\n\n    switch(backward_matches)\n    {\n      case -2:\n        return ERROR_INSUFFICIENT_MEMORY;\n      case -3:\n        return ERROR_TOO_MANY_MATCHES;\n      case -4:\n        return ERROR_TOO_MANY_RE_FIBERS;\n      case -5:\n        return ERROR_INTERNAL_FATAL_ERROR;\n    }\n  }\n  else\n  {\n    FAIL_ON_ERROR(_yr_scan_match_callback(\n        data + offset, 0, flags, &callback_args));\n  }\n\n  return ERROR_SUCCESS;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "findoprnd(ITEM *ptr, int32 *pos)\n {\n \tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n \t{\n \t\tptr[*pos].left = 0;\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = 1;\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void AutoFillManager::ParseForms(const std::vector<FormData>& forms) {\n  std::vector<FormStructure*> non_queryable_forms;\n  for (std::vector<FormData>::const_iterator iter = forms.begin();\n       iter != forms.end(); ++iter) {\n    scoped_ptr<FormStructure> form_structure(new FormStructure(*iter));\n    if (!form_structure->ShouldBeParsed(false))\n      continue;\n\n    if (form_structure->ShouldBeParsed(true))\n      form_structures_.push_back(form_structure.release());\n    else\n      non_queryable_forms.push_back(form_structure.release());\n  }\n\n  if (!form_structures_.empty() && !disable_download_manager_requests_)\n    download_manager_.StartQueryRequest(form_structures_, *metric_logger_);\n\n  for (std::vector<FormStructure*>::const_iterator iter =\n           non_queryable_forms.begin();\n       iter != non_queryable_forms.end(); ++iter) {\n    form_structures_.push_back(*iter);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "rdpsnd_process_training(STREAM in)\n{\n \tuint16 tick;\n \tuint16 packsize;\n \tSTREAM out;\n \n \tin_uint16_le(in, tick);\n \tin_uint16_le(in, packsize);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_training(), tick=0x%04x\", (unsigned) tick);\n\n\tout = rdpsnd_init_packet(SNDC_TRAINING, 4);\n\tout_uint16_le(out, tick);\n\tout_uint16_le(out, packsize);\n\ts_mark_end(out);\n\trdpsnd_send(out);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void sco_sock_init(struct sock *sk, struct sock *parent)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent)\n\t\tsk->sk_type = parent->sk_type;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void _WM_do_meta_cuepoint(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\tint dumpable = 0;\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n \tif (task->mm)\n \t\tdumpable = get_dumpable(task->mm);\n \trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n \t\trcu_read_unlock();\n \t\treturn -EPERM;\n \t}\n\trcu_read_unlock();\n\n\treturn security_ptrace_access_check(task, mode);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int flashsv_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame, AVPacket *avpkt)\n{\n    int buf_size       = avpkt->size;\n    FlashSVContext *s  = avctx->priv_data;\n    int h_blocks, v_blocks, h_part, v_part, i, j, ret;\n    GetBitContext gb;\n    int last_blockwidth = s->block_width;\n    int last_blockheight= s->block_height;\n\n    /* no supplementary picture */\n    if (buf_size == 0)\n        return 0;\n    if (buf_size < 4)\n        return -1;\n\n    init_get_bits(&gb, avpkt->data, buf_size * 8);\n\n    /* start to parse the bitstream */\n    s->block_width  = 16 * (get_bits(&gb,  4) + 1);\n    s->image_width  =       get_bits(&gb, 12);\n    s->block_height = 16 * (get_bits(&gb,  4) + 1);\n    s->image_height =       get_bits(&gb, 12);\n\n    if (   last_blockwidth != s->block_width\n        || last_blockheight!= s->block_height)\n        av_freep(&s->blocks);\n\n    if (s->ver == 2) {\n        skip_bits(&gb, 6);\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"iframe\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (get_bits1(&gb)) {\n            avpriv_request_sample(avctx, \"Custom palette\");\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n\n    /* calculate number of blocks and size of border (partial) blocks */\n    h_blocks = s->image_width  / s->block_width;\n    h_part   = s->image_width  % s->block_width;\n    v_blocks = s->image_height / s->block_height;\n    v_part   = s->image_height % s->block_height;\n\n    /* the block size could change between frames, make sure the buffer\n     * is large enough, if not, get a larger one */\n    if (s->block_size < s->block_width * s->block_height) {\n        int tmpblock_size = 3 * s->block_width * s->block_height;\n\n        s->tmpblock = av_realloc(s->tmpblock, tmpblock_size);\n        if (!s->tmpblock) {\n            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");\n            return AVERROR(ENOMEM);\n        }\n        if (s->ver == 2) {\n            s->deflate_block_size = calc_deflate_block_size(tmpblock_size);\n            if (s->deflate_block_size <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't determine deflate buffer size.\\n\");\n                return -1;\n            }\n            s->deflate_block = av_realloc(s->deflate_block, s->deflate_block_size);\n            if (!s->deflate_block) {\n                av_log(avctx, AV_LOG_ERROR, \"Can't allocate deflate buffer.\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n    }\n    s->block_size = s->block_width * s->block_height;\n\n    /* initialize the image size once */\n    if (avctx->width == 0 && avctx->height == 0) {\n        avcodec_set_dimensions(avctx, s->image_width, s->image_height);\n    }\n\n    /* check for changes of image width and image height */\n    if (avctx->width != s->image_width || avctx->height != s->image_height) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame width or height differs from first frame!\\n\");\n        av_log(avctx, AV_LOG_ERROR, \"fh = %d, fv %d  vs  ch = %d, cv = %d\\n\",\n               avctx->height, avctx->width, s->image_height, s->image_width);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* we care for keyframes only in Screen Video v2 */\n    s->is_keyframe = (avpkt->flags & AV_PKT_FLAG_KEY) && (s->ver == 2);\n    if (s->is_keyframe) {\n        s->keyframedata = av_realloc(s->keyframedata, avpkt->size);\n        memcpy(s->keyframedata, avpkt->data, avpkt->size);\n    }\n    if(s->ver == 2 && !s->blocks)\n        s->blocks = av_mallocz((v_blocks + !!v_part) * (h_blocks + !!h_part)\n                                * sizeof(s->blocks[0]));\n\n    av_dlog(avctx, \"image: %dx%d block: %dx%d num: %dx%d part: %dx%d\\n\",\n            s->image_width, s->image_height, s->block_width, s->block_height,\n            h_blocks, v_blocks, h_part, v_part);\n\n    if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)\n        return ret;\n\n    /* loop over all block columns */\n    for (j = 0; j < v_blocks + (v_part ? 1 : 0); j++) {\n\n        int y_pos  = j * s->block_height; // vertical position in frame\n        int cur_blk_height = (j < v_blocks) ? s->block_height : v_part;\n\n        /* loop over all block rows */\n        for (i = 0; i < h_blocks + (h_part ? 1 : 0); i++) {\n            int x_pos = i * s->block_width; // horizontal position in frame\n            int cur_blk_width = (i < h_blocks) ? s->block_width : h_part;\n            int has_diff = 0;\n\n            /* get the size of the compressed zlib chunk */\n            int size = get_bits(&gb, 16);\n\n            s->color_depth    = 0;\n            s->zlibprime_curr = 0;\n            s->zlibprime_prev = 0;\n            s->diff_start     = 0;\n            s->diff_height    = cur_blk_height;\n\n            if (8 * size > get_bits_left(&gb)) {\n                av_frame_unref(&s->frame);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ver == 2 && size) {\n                skip_bits(&gb, 3);\n                s->color_depth    = get_bits(&gb, 2);\n                has_diff          = get_bits1(&gb);\n                s->zlibprime_curr = get_bits1(&gb);\n                s->zlibprime_prev = get_bits1(&gb);\n\n                if (s->color_depth != 0 && s->color_depth != 2) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"%dx%d invalid color depth %d\\n\", i, j, s->color_depth);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                if (has_diff) {\n                    if (!s->keyframe) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"inter frame without keyframe\\n\");\n                        return AVERROR_INVALIDDATA;\n                     }\n                     s->diff_start  = get_bits(&gb, 8);\n                     s->diff_height = get_bits(&gb, 8);\n                     av_log(avctx, AV_LOG_DEBUG,\n                            \"%dx%d diff start %d height %d\\n\",\n                            i, j, s->diff_start, s->diff_height);\n                    size -= 2;\n                }\n\n                if (s->zlibprime_prev)\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_prev\\n\", i, j);\n\n                if (s->zlibprime_curr) {\n                    int col = get_bits(&gb, 8);\n                    int row = get_bits(&gb, 8);\n                    av_log(avctx, AV_LOG_DEBUG, \"%dx%d zlibprime_curr %dx%d\\n\", i, j, col, row);\n                    size -= 2;\n                    avpriv_request_sample(avctx, \"zlibprime_curr\");\n                    return AVERROR_PATCHWELCOME;\n                }\n                if (!s->blocks && (s->zlibprime_curr || s->zlibprime_prev)) {\n                    av_log(avctx, AV_LOG_ERROR, \"no data available for zlib \"\n                           \"priming\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                size--; // account for flags byte\n            }\n\n            if (has_diff) {\n                int k;\n                int off = (s->image_height - y_pos - 1) * s->frame.linesize[0];\n\n                for (k = 0; k < cur_blk_height; k++)\n                    memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,\n                           s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,\n                           cur_blk_width * 3);\n            }\n\n            /* skip unchanged blocks, which have size 0 */\n            if (size) {\n                if (flashsv_decode_block(avctx, avpkt, &gb, size,\n                                         cur_blk_width, cur_blk_height,\n                                         x_pos, y_pos,\n                                         i + j * (h_blocks + !!h_part)))\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"error in decompression of block %dx%d\\n\", i, j);\n            }\n        }\n    }\n    if (s->is_keyframe && s->ver == 2) {\n        if (!s->keyframe) {\n            s->keyframe = av_malloc(s->frame.linesize[0] * avctx->height);\n            if (!s->keyframe) {\n                av_log(avctx, AV_LOG_ERROR, \"Cannot allocate image data\\n\");\n                return AVERROR(ENOMEM);\n            }\n        }\n        memcpy(s->keyframe, s->frame.data[0], s->frame.linesize[0] * avctx->height);\n    }\n\n    if ((ret = av_frame_ref(data, &s->frame)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    if ((get_bits_count(&gb) / 8) != buf_size)\n        av_log(avctx, AV_LOG_ERROR, \"buffer not fully consumed (%d != %d)\\n\",\n               buf_size, (get_bits_count(&gb) / 8));\n\n    /* report that the buffer was completely consumed */\n    return buf_size;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n \tstruct inet_request_sock *ireq;\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct tcp6_sock *newtcp6sk;\n \tstruct inet_sock *newinet;\n \tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n \t   but we make one more one thing there: reattach optmem\n \t   to newsk.\n \t */\n\tif (np->opt)\n\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n \n \ttcp_ca_openreq_child(newsk, dst);\n \n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_atomic(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_atomic(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void usb_audio_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_card *card;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn;\n\n\tcard = chip->card;\n\n\tmutex_lock(&register_mutex);\n\tif (atomic_inc_return(&chip->shutdown) == 1) {\n\t\tstruct snd_usb_stream *as;\n\t\tstruct snd_usb_endpoint *ep;\n\t\tstruct usb_mixer_interface *mixer;\n\n\t\t/* wait until all pending tasks done;\n\t\t * they are protected by snd_usb_lock_shutdown()\n\t\t */\n\t\twait_event(chip->shutdown_wait,\n\t\t\t   !atomic_read(&chip->usage_count));\n\t\tsnd_card_disconnect(card);\n\t\t/* release the pcm resources */\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_usb_stream_disconnect(as);\n\t\t}\n\t\t/* release the endpoint resources */\n\t\tlist_for_each_entry(ep, &chip->ep_list, list) {\n\t\t\tsnd_usb_endpoint_release(ep);\n\t\t}\n\t\t/* release the midi resources */\n\t\tlist_for_each(p, &chip->midi_list) {\n\t\t\tsnd_usbmidi_disconnect(p);\n\t\t}\n\t\t/* release mixer resources */\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\t\tsnd_usb_mixer_disconnect(mixer);\n\t\t}\n\t}\n\n\tchip->num_interfaces--;\n\tif (chip->num_interfaces <= 0) {\n\t\tusb_chip[chip->index] = NULL;\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_card_free_when_closed(card);\n\t} else {\n\t\tmutex_unlock(&register_mutex);\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t Camera3Device::checkStatusOkToCaptureLocked() {\n switch (mStatus) {\n case STATUS_ERROR:\n            CLOGE(\"Device has encountered a serious error\");\n return INVALID_OPERATION;\n case STATUS_UNINITIALIZED:\n            CLOGE(\"Device not initialized\");\n return INVALID_OPERATION;\n case STATUS_UNCONFIGURED:\n case STATUS_CONFIGURED:\n case STATUS_ACTIVE:\n break;\n default:\n            SET_ERR_L(\"Unexpected status: %d\", mStatus);\n return INVALID_OPERATION;\n }\n return OK;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref)\n{\n    int   is_valid;\n    long  start;\n    char *c, buf[16];\n    \n    memset(buf, 0, sizeof(buf));\n    is_valid = 0;\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    if (fgets(buf, 16, fp) == NULL) {\n      ERR(\"Failed to load xref string.\");\n      exit(EXIT_FAILURE);\n    }\n\n    if (strncmp(buf, \"xref\", strlen(\"xref\")) == 0)\n      is_valid = 1;\n    else\n    {  \n        /* PDFv1.5+ allows for xref data to be stored in streams vs plaintext */\n        fseek(fp, xref->start, SEEK_SET);\n        c = get_object_from_here(fp, NULL, &xref->is_stream);\n\n        if (c && xref->is_stream)\n        {\n            free(c);\n            pdf->has_xref_streams = 1;\n            is_valid = 1;\n        }\n    }\n\n    fseek(fp, start, SEEK_SET);\n    return is_valid;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "mem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tif (log_op)\n\t\tfclose(log_op);\n\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t/* \"/tmp/\" + prog_name + \"_mem.\" + PID + \".log\" + '\\0\" */\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n \t}\n \n \tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen(log_name, \"a\");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n \t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\n\t\t/* We don't want any children to inherit the log file */\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\n\t\t/* Make the log output line buffered. This was to ensure that\n\t\t * children didn't inherit the buffer, but the CLOEXEC above\n\t\t * should resolve that. */\n\t\tsetlinebuf(log_op);\n\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\n\tfree(log_name);\n\n\tterminate_banner = banner;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-59"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t/* Can't properly set mode on creation because of the umask */\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t/*\n\t * Non-directores become opaque when copied up.\n\t */\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n \n out_cleanup:\n \tovl_cleanup(wdir, newdentry);\n\tgoto out;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void uint8ArrayAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValueFast(info, WTF::getPtr(imp->uint8ArrayAttribute()), imp);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void ip_rt_build_flow_key(struct flowi4 *fl4, const struct sock *sk,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tif (skb)\n\t\tbuild_skb_flow_key(fl4, skb, sk);\n\telse\n\t\tbuild_sk_flow_key(fl4, sk);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-17"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void kvm_arch_memslots_updated(struct kvm *kvm)\n{\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool ChromeClientImpl::tabsToLinks()\n{\n    return m_webView->tabsToLinks();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void RemapIndices(const ssize_t *map, const unsigned char *source,\n  unsigned char *target)\n{\n  register ssize_t\n    i;\n\n  for (i = 0; i < 16; i++)\n  {\n    if (map[i] == -1)\n      target[i] = 3;\n    else\n      target[i] = source[map[i]];\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t MPEG4Source::fragmentedRead(\n MediaBuffer **out, const ReadOptions *options) {\n\n    ALOGV(\"MPEG4Source::fragmentedRead\");\n\n    CHECK(mStarted);\n\n *out = NULL;\n\n int64_t targetSampleTimeUs = -1;\n\n int64_t seekTimeUs;\n ReadOptions::SeekMode mode;\n if (options && options->getSeekTo(&seekTimeUs, &mode)) {\n\n int numSidxEntries = mSegments.size();\n if (numSidxEntries != 0) {\n int64_t totalTime = 0;\n off64_t totalOffset = mFirstMoofOffset;\n for (int i = 0; i < numSidxEntries; i++) {\n const SidxEntry *se = &mSegments[i];\n if (totalTime + se->mDurationUs > seekTimeUs) {\n if ((mode == ReadOptions::SEEK_NEXT_SYNC) ||\n (mode == ReadOptions::SEEK_CLOSEST_SYNC &&\n (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {\n                        totalTime += se->mDurationUs;\n                        totalOffset += se->mSize;\n }\n break;\n }\n                totalTime += se->mDurationUs;\n                totalOffset += se->mSize;\n }\n        mCurrentMoofOffset = totalOffset;\n        mCurrentSamples.clear();\n        mCurrentSampleIndex = 0;\n        parseChunk(&totalOffset);\n        mCurrentTime = totalTime * mTimescale / 1000000ll;\n }\n\n if (mBuffer != NULL) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n }\n\n off64_t offset = 0;\n size_t size;\n uint32_t cts = 0;\n bool isSyncSample = false;\n bool newBuffer = false;\n if (mBuffer == NULL) {\n        newBuffer = true;\n\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n Sample lastSample = mCurrentSamples[mCurrentSamples.size() - 1];\n off64_t nextMoof = mNextMoofOffset; // lastSample.offset + lastSample.size;\n            mCurrentMoofOffset = nextMoof;\n            mCurrentSamples.clear();\n            mCurrentSampleIndex = 0;\n            parseChunk(&nextMoof);\n if (mCurrentSampleIndex >= mCurrentSamples.size()) {\n return ERROR_END_OF_STREAM;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n        offset = smpl->offset;\n        size = smpl->size;\n        cts = mCurrentTime;\n        mCurrentTime += smpl->duration;\n        isSyncSample = (mCurrentSampleIndex == 0); // XXX\n\n status_t err = mGroup->acquire_buffer(&mBuffer);\n\n if (err != OK) {\n            CHECK(mBuffer == NULL);\n            ALOGV(\"acquire_buffer returned %d\", err);\n return err;\n }\n if (size > mBuffer->size()) {\n            ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());\n return ERROR_BUFFER_TOO_SMALL;\n }\n }\n\n const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];\n const sp<MetaData> bufmeta = mBuffer->meta_data();\n    bufmeta->clear();\n if (smpl->encryptedsizes.size()) {\n        bufmeta->setData(kKeyPlainSizes, 0,\n                smpl->clearsizes.array(), smpl->clearsizes.size() * 4);\n        bufmeta->setData(kKeyEncryptedSizes, 0,\n                smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);\n        bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16); // use 16 or the actual size?\n        bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);\n        bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);\n        bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);\n }\n\n if (!mIsAVC || mWantsNALFragments) {\n if (newBuffer) {\n if (!isInRange((size_t)0u, mBuffer->size(), size)) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGE(\"fragmentedRead ERROR_MALFORMED size %zu\", size);\n return ERROR_MALFORMED;\n }\n\n ssize_t num_bytes_read =\n                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);\n\n if (num_bytes_read < (ssize_t)size) {\n                mBuffer->release();\n                mBuffer = NULL;\n\n                ALOGE(\"i/o error\");\n return ERROR_IO;\n }\n\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n            mBuffer->meta_data()->setInt64(\n                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n                mBuffer->meta_data()->setInt64(\n                        kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n }\n\n if (!mIsAVC) {\n *out = mBuffer;\n            mBuffer = NULL;\n\n return OK;\n }\n\n\n        CHECK(mBuffer->range_length() >= mNALLengthSize);\n\n const uint8_t *src =\n (const uint8_t *)mBuffer->data() + mBuffer->range_offset();\n\n size_t nal_size = parseNALSize(src);\n if (mNALLengthSize > SIZE_MAX - nal_size) {\n            ALOGE(\"b/24441553, b/24445122\");\n }\n\n if (mBuffer->range_length() - mNALLengthSize < nal_size) {\n            ALOGE(\"incomplete NAL unit.\");\n\n            mBuffer->release();\n            mBuffer = NULL;\n\n return ERROR_MALFORMED;\n }\n\n MediaBuffer *clone = mBuffer->clone();\n        CHECK(clone != NULL);\n        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);\n\n        CHECK(mBuffer != NULL);\n        mBuffer->set_range(\n                mBuffer->range_offset() + mNALLengthSize + nal_size,\n                mBuffer->range_length() - mNALLengthSize - nal_size);\n\n if (mBuffer->range_length() == 0) {\n            mBuffer->release();\n            mBuffer = NULL;\n }\n\n *out = clone;\n\n return OK;\n } else {\n        ALOGV(\"whole NAL\");\n ssize_t num_bytes_read = 0;\n int32_t drm = 0;\n bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);\n void *data = NULL;\n bool isMalFormed = false;\n if (usesDRM) {\n if (mBuffer == NULL || !isInRange((size_t)0u, mBuffer->size(), size)) {\n                isMalFormed = true;\n } else {\n                data = mBuffer->data();\n }\n } else {\n int32_t max_size;\n if (mFormat == NULL\n || !mFormat->findInt32(kKeyMaxInputSize, &max_size)\n || !isInRange((size_t)0u, (size_t)max_size, size)) {\n                isMalFormed = true;\n } else {\n                data = mSrcBuffer;\n }\n }\n\n if (isMalFormed || data == NULL) {\n            ALOGE(\"isMalFormed size %zu\", size);\n if (mBuffer != NULL) {\n                mBuffer->release();\n                mBuffer = NULL;\n }\n return ERROR_MALFORMED;\n }\n        num_bytes_read = mDataSource->readAt(offset, data, size);\n\n if (num_bytes_read < (ssize_t)size) {\n            mBuffer->release();\n            mBuffer = NULL;\n\n            ALOGE(\"i/o error\");\n return ERROR_IO;\n }\n\n if (usesDRM) {\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, size);\n\n } else {\n uint8_t *dstData = (uint8_t *)mBuffer->data();\n size_t srcOffset = 0;\n size_t dstOffset = 0;\n\n while (srcOffset < size) {\n                isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);\n size_t nalLength = 0;\n if (!isMalFormed) {\n                    nalLength = parseNALSize(&mSrcBuffer[srcOffset]);\n                    srcOffset += mNALLengthSize;\n                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength)\n || !isInRange((size_t)0u, mBuffer->size(), dstOffset, (size_t)4u)\n || !isInRange((size_t)0u, mBuffer->size(), dstOffset + 4, nalLength);\n }\n\n if (isMalFormed) {\n                    ALOGE(\"Video is malformed; nalLength %zu\", nalLength);\n                    mBuffer->release();\n                    mBuffer = NULL;\n return ERROR_MALFORMED;\n }\n\n if (nalLength == 0) {\n\n                     continue;\n                 }\n \n                CHECK(dstOffset + 4 <= mBuffer->size());\n \n                 dstData[dstOffset++] = 0;\n                 dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 0;\n                dstData[dstOffset++] = 1;\n                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);\n                srcOffset += nalLength;\n                dstOffset += nalLength;\n }\n            CHECK_EQ(srcOffset, size);\n            CHECK(mBuffer != NULL);\n            mBuffer->set_range(0, dstOffset);\n }\n\n        mBuffer->meta_data()->setInt64(\n                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);\n\n if (targetSampleTimeUs >= 0) {\n            mBuffer->meta_data()->setInt64(\n                    kKeyTargetTime, targetSampleTimeUs);\n }\n\n if (isSyncSample) {\n            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n }\n\n ++mCurrentSampleIndex;\n\n *out = mBuffer;\n        mBuffer = NULL;\n\n return OK;\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int tls1_enc(SSL *s, SSL3_RECORD *recs, unsigned int n_recs, int send)\n{\n    EVP_CIPHER_CTX *ds;\n    size_t reclen[SSL_MAX_PIPELINES];\n    unsigned char buf[SSL_MAX_PIPELINES][EVP_AEAD_TLS1_AAD_LEN];\n    int bs, i, j, k, pad = 0, ret, mac_size = 0;\n    const EVP_CIPHER *enc;\n    unsigned int ctr;\n\n    if (send) {\n        if (EVP_MD_CTX_md(s->write_hash)) {\n            int n = EVP_MD_CTX_size(s->write_hash);\n            OPENSSL_assert(n >= 0);\n        }\n        ds = s->enc_write_ctx;\n        if (s->enc_write_ctx == NULL)\n            enc = NULL;\n        else {\n            int ivlen;\n            enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\n            /* For TLSv1.1 and later explicit IV */\n            if (SSL_USE_EXPLICIT_IV(s)\n                && EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)\n                ivlen = EVP_CIPHER_iv_length(enc);\n            else\n                ivlen = 0;\n            if (ivlen > 1) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    if (recs[ctr].data != recs[ctr].input) {\n                        /*\n                         * we can't write into the input stream: Can this ever\n                         * happen?? (steve)\n                         */\n                        SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);\n                        return -1;\n                    } else if (RAND_bytes(recs[ctr].input, ivlen) <= 0) {\n                        SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);\n                        return -1;\n                    }\n                }\n            }\n        }\n    } else {\n        if (EVP_MD_CTX_md(s->read_hash)) {\n            int n = EVP_MD_CTX_size(s->read_hash);\n            OPENSSL_assert(n >= 0);\n        }\n        ds = s->enc_read_ctx;\n        if (s->enc_read_ctx == NULL)\n            enc = NULL;\n        else\n            enc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\n    }\n\n    if ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {\n        for (ctr = 0; ctr < n_recs; ctr++) {\n            memmove(recs[ctr].data, recs[ctr].input, recs[ctr].length);\n            recs[ctr].input = recs[ctr].data;\n        }\n        ret = 1;\n    } else {\n        bs = EVP_CIPHER_block_size(EVP_CIPHER_CTX_cipher(ds));\n\n        if (n_recs > 1) {\n            if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n                  & EVP_CIPH_FLAG_PIPELINE)) {\n                /*\n                 * We shouldn't have been called with pipeline data if the\n                 * cipher doesn't support pipelining\n                 */\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n                return -1;\n            }\n        }\n        for (ctr = 0; ctr < n_recs; ctr++) {\n            reclen[ctr] = recs[ctr].length;\n\n            if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n                & EVP_CIPH_FLAG_AEAD_CIPHER) {\n                unsigned char *seq;\n\n                seq = send ? RECORD_LAYER_get_write_sequence(&s->rlayer)\n                    : RECORD_LAYER_get_read_sequence(&s->rlayer);\n\n                if (SSL_IS_DTLS(s)) {\n                    /* DTLS does not support pipelining */\n                    unsigned char dtlsseq[9], *p = dtlsseq;\n\n                    s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&s->rlayer) :\n                        DTLS_RECORD_LAYER_get_r_epoch(&s->rlayer), p);\n                    memcpy(p, &seq[2], 6);\n                    memcpy(buf[ctr], dtlsseq, 8);\n                } else {\n                    memcpy(buf[ctr], seq, 8);\n                    for (i = 7; i >= 0; i--) { /* increment */\n                        ++seq[i];\n                        if (seq[i] != 0)\n                            break;\n                    }\n                }\n\n                buf[ctr][8] = recs[ctr].type;\n                buf[ctr][9] = (unsigned char)(s->version >> 8);\n                buf[ctr][10] = (unsigned char)(s->version);\n                buf[ctr][11] = recs[ctr].length >> 8;\n                buf[ctr][12] = recs[ctr].length & 0xff;\n                pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD,\n                                          EVP_AEAD_TLS1_AAD_LEN, buf[ctr]);\n                if (pad <= 0)\n                    return -1;\n\n                if (send) {\n                    reclen[ctr] += pad;\n                    recs[ctr].length += pad;\n                }\n\n            } else if ((bs != 1) && send) {\n                i = bs - ((int)reclen[ctr] % bs);\n\n                /* Add weird padding of upto 256 bytes */\n\n                /* we need to add 'i' padding bytes of value j */\n                j = i - 1;\n                for (k = (int)reclen[ctr]; k < (int)(reclen[ctr] + i); k++)\n                    recs[ctr].input[k] = j;\n                reclen[ctr] += i;\n                recs[ctr].length += i;\n            }\n\n            if (!send) {\n                if (reclen[ctr] == 0 || reclen[ctr] % bs != 0)\n                    return 0;\n            }\n        }\n        if (n_recs > 1) {\n            unsigned char *data[SSL_MAX_PIPELINES];\n\n            /* Set the output buffers */\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                data[ctr] = recs[ctr].data;\n            }\n            if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS,\n                                    n_recs, data) <= 0) {\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n            }\n            /* Set the input buffers */\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                data[ctr] = recs[ctr].input;\n            }\n            if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_BUFS,\n                                    n_recs, data) <= 0\n                || EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_LENS,\n                                       n_recs, reclen) <= 0) {\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n                return -1;\n            }\n        }\n\n        i = EVP_Cipher(ds, recs[0].data, recs[0].input, reclen[0]);\n        if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n             & EVP_CIPH_FLAG_CUSTOM_CIPHER)\n            ? (i < 0)\n            : (i == 0))\n            return -1;          /* AEAD can fail to verify MAC */\n        if (send == 0) {\n            if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    recs[ctr].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                }\n            } else if (EVP_CIPHER_mode(enc) == EVP_CIPH_CCM_MODE) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    recs[ctr].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                }\n            }\n         }\n \n         ret = 1;\n        if (!SSL_USE_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)\n             mac_size = EVP_MD_CTX_size(s->read_hash);\n         if ((bs != 1) && !send) {\n             int tmpret;\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                tmpret = tls1_cbc_remove_padding(s, &recs[ctr], bs, mac_size);\n                /*\n                 * If tmpret == 0 then this means publicly invalid so we can\n                 * short circuit things here. Otherwise we must respect constant\n                 * time behaviour.\n                 */\n                if (tmpret == 0)\n                    return 0;\n                ret = constant_time_select_int(constant_time_eq_int(tmpret, 1),\n                                               ret, -1);\n            }\n        }\n        if (pad && !send) {\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                recs[ctr].length -= pad;\n            }\n        }\n    }\n    return ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void OnDefaultProtocolClientWorkerFinished(\n    const GURL& escaped_url,\n    int render_process_host_id,\n    int render_view_routing_id,\n    bool prompt_user,\n    ui::PageTransition page_transition,\n    bool has_user_gesture,\n    ExternalProtocolHandler::Delegate* delegate,\n    shell_integration::DefaultWebClientState state) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  if (delegate)\n    delegate->FinishedProcessingCheck();\n\n  if (state == shell_integration::IS_DEFAULT) {\n    if (delegate)\n      delegate->BlockRequest();\n    return;\n  }\n\n  if (prompt_user) {\n    RunExternalProtocolDialogWithDelegate(\n        escaped_url, render_process_host_id, render_view_routing_id,\n        page_transition, has_user_gesture, delegate);\n    return;\n  }\n\n  LaunchUrlWithoutSecurityCheckWithDelegate(escaped_url, render_process_host_id,\n                                            render_view_routing_id, delegate);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "FrameImpl::~FrameImpl() {\n  window_tree_host_->Hide();\n  window_tree_host_->compositor()->SetVisible(false);\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xsltProcessingInstructionComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemPIPtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemPIPtr) xsltNewStylePreComp(style, XSLT_FUNC_PI);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_PI);\n#endif\n\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n\n    comp->name = xsltEvalStaticAttrValueTemplate(style, inst,\n\t\t\t\t (const xmlChar *)\"name\",\n\t\t\t\t XSLT_NAMESPACE, &comp->has_name);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int mwifiex_cmd_uap_sta_deauth(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd, u8 *mac)\n{\n\tstruct host_cmd_ds_sta_deauth *sta_deauth = &cmd->params.sta_deauth;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_STA_DEAUTH);\n\tmemcpy(sta_deauth->mac, mac, ETH_ALEN);\n\tsta_deauth->reason = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\n\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_sta_deauth) +\n\t\t\t\tS_DS_GEN);\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-120"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void mark_reg_unknown(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_reg_state *regs, u32 regno)\n{\n\tif (WARN_ON(regno >= MAX_BPF_REG)) {\n\t\tverbose(env, \"mark_reg_unknown(regs, %u)\\n\", regno);\n\t\t/* Something bad happened, let's kill all regs */\n\t\tfor (regno = 0; regno < MAX_BPF_REG; regno++)\n\t\t\t__mark_reg_not_init(regs + regno);\n\t\treturn;\n\t}\n\t__mark_reg_unknown(regs + regno);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCXException(severity,tag) \\\n  { \\\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n    ThrowReaderException(severity,tag); \\\n  }\n\n  Image\n    *image;\n\n  int\n    bits,\n    id,\n    mask;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *r;\n\n  size_t\n    one,\n    pcx_packets;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    packet,\n    pcx_colormap[768],\n    *pixels,\n    *scanline;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCX file.\n  */\n  page_table=(MagickOffsetType *) NULL;\n  if (LocaleCompare(image_info->magick,\"DCX\") == 0)\n    {\n      size_t\n        magic;\n\n      /*\n        Read the DCX page table.\n      */\n      magic=ReadBlobLSBLong(image);\n      if (magic != 987654321)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (id=0; id < 1024; id++)\n      {\n        page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);\n        if (page_table[id] == 0)\n          break;\n      }\n    }\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,1,&pcx_info.identifier);\n  for (id=1; id < 1024; id++)\n  {\n    int\n      bits_per_pixel;\n\n    /*\n      Verify PCX identifier.\n    */\n    pcx_info.version=(unsigned char) ReadBlobByte(image);\n    if ((count == 0) || (pcx_info.identifier != 0x0a))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.encoding=(unsigned char) ReadBlobByte(image);\n    bits_per_pixel=ReadBlobByte(image);\n    if (bits_per_pixel == -1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;\n    pcx_info.left=ReadBlobLSBShort(image);\n    pcx_info.top=ReadBlobLSBShort(image);\n    pcx_info.right=ReadBlobLSBShort(image);\n    pcx_info.bottom=ReadBlobLSBShort(image);\n    pcx_info.horizontal_resolution=ReadBlobLSBShort(image);\n    pcx_info.vertical_resolution=ReadBlobLSBShort(image);\n    /*\n      Read PCX raster colormap.\n    */\n    image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-\n      pcx_info.left)+1UL;\n    image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-\n      pcx_info.top)+1UL;\n    if ((image->columns == 0) || (image->rows == 0) ||\n        (pcx_info.bits_per_pixel == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->depth=pcx_info.bits_per_pixel <= 8 ? 8U : MAGICKCORE_QUANTUM_DEPTH;\n    image->units=PixelsPerInchResolution;\n    image->x_resolution=(double) pcx_info.horizontal_resolution;\n    image->y_resolution=(double) pcx_info.vertical_resolution;\n    image->colors=16;\n    count=ReadBlob(image,3*image->colors,pcx_colormap);\n    pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n    pcx_info.planes=(unsigned char) ReadBlobByte(image);\n    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))\n      if ((pcx_info.version == 3) || (pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        image->colors=(size_t) MagickMin(one << (1UL*\n          (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);\n    if (AcquireImageColormap(image,image->colors) == MagickFalse)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))\n      image->storage_class=DirectClass;\n    p=pcx_colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n    pcx_info.bytes_per_line=ReadBlobLSBShort(image);\n    pcx_info.palette_info=ReadBlobLSBShort(image);\n    for (i=0; i < 58; i++)\n      (void) ReadBlobByte(image);\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     /*\n       Read image data.\n     */\n    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line*pcx_info.planes;\n    if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >\n        (pcx_packets*8U))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,\n      pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));\n    pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));\n    if ((scanline == (unsigned char *) NULL) ||\n        (pixel_info == (MemoryInfo *) NULL))\n      {\n        if (scanline != (unsigned char *) NULL)\n          scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Uncompress image data.\n    */\n    p=pixels;\n    if (pcx_info.encoding == 0)\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        *p++=packet;\n        pcx_packets--;\n      }\n    else\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        if ((packet & 0xc0) != 0xc0)\n          {\n            *p++=packet;\n            pcx_packets--;\n            continue;\n          }\n        count=(ssize_t) (packet & 0x3f);\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for ( ; count != 0; count--)\n        {\n          *p++=packet;\n          pcx_packets--;\n          if (pcx_packets == 0)\n            break;\n        }\n      }\n    if (image->storage_class == DirectClass)\n      image->matte=pcx_info.planes > 3 ? MagickTrue : MagickFalse;\n    else\n      if ((pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        {\n          /*\n            Initialize image colormap.\n          */\n          if (image->colors > 256)\n            ThrowPCXException(CorruptImageError,\"ColormapExceeds256Colors\");\n          if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)\n            {\n              /*\n                Monochrome colormap.\n              */\n              image->colormap[0].red=(Quantum) 0;\n              image->colormap[0].green=(Quantum) 0;\n              image->colormap[0].blue=(Quantum) 0;\n              image->colormap[1].red=QuantumRange;\n              image->colormap[1].green=QuantumRange;\n              image->colormap[1].blue=QuantumRange;\n            }\n          else\n            if (image->colors > 16)\n              {\n                /*\n                  256 color images have their color map at the end of the file.\n                */\n                pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);\n                count=ReadBlob(image,3*image->colors,pcx_colormap);\n                p=pcx_colormap;\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum(*p++);\n                  image->colormap[i].green=ScaleCharToQuantum(*p++);\n                  image->colormap[i].blue=ScaleCharToQuantum(*p++);\n                }\n            }\n        }\n    /*\n      Convert PCX raster image to pixel packets.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      r=scanline;\n      if (image->storage_class == DirectClass)\n        for (i=0; i < pcx_info.planes; i++)\n        {\n          r=scanline+i;\n          for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n          {\n            switch (i)\n            {\n              case 0:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 1:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 2:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 3:\n              default:\n              {\n                *r=(*p++);\n                break;\n              }\n            }\n            r+=pcx_info.planes;\n          }\n        }\n      else\n        if (pcx_info.planes > 1)\n          {\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *r++=0;\n            for (i=0; i < pcx_info.planes; i++)\n            {\n              r=scanline;\n              for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n              {\n                 bits=(*p++);\n                 for (mask=0x80; mask != 0; mask>>=1)\n                 {\n                   if (bits & mask)\n                     *r|=1 << i;\n                   r++;\n                 }\n               }\n            }\n          }\n        else\n          switch (pcx_info.bits_per_pixel)\n          {\n            case 1:\n            {\n              register ssize_t\n                bit;\n\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                for (bit=7; bit >= 0; bit--)\n                  *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                p++;\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)\n                    *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                  p++;\n                }\n              break;\n            }\n            case 2:\n            {\n              for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n              {\n                *r++=(*p >> 6) & 0x3;\n                *r++=(*p >> 4) & 0x3;\n                *r++=(*p >> 2) & 0x3;\n                *r++=(*p) & 0x3;\n                p++;\n              }\n              if ((image->columns % 4) != 0)\n                {\n                  for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)\n                    *r++=(unsigned char) ((*p >> (i*2)) & 0x03);\n                  p++;\n                }\n              break;\n            }\n            case 4:\n            {\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                *r++=(*p >> 4) & 0xf;\n                *r++=(*p) & 0xf;\n                p++;\n              }\n              if ((image->columns % 2) != 0)\n                *r++=(*p++ >> 4) & 0xf;\n              break;\n            }\n            case 8:\n            {\n              (void) CopyMagickMemory(r,p,image->columns);\n              break;\n            }\n            default:\n              break;\n          }\n      /*\n        Transfer image scanline.\n      */\n      r=scanline;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelIndex(indexes+x,*r++)\n        else\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*r++));\n            SetPixelGreen(q,ScaleCharToQuantum(*r++));\n            SetPixelBlue(q,ScaleCharToQuantum(*r++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*r++));\n          }\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (page_table[id] == 0)\n      break;\n    offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,1,&pcx_info.identifier);\n    if ((count != 0) && (pcx_info.identifier == 0x0a))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (page_table != (MagickOffsetType *) NULL)\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void MergeFeaturesFromOriginPolicy(WTF::String& feature_policy,\n                                   const String& origin_policy_string) {\n  if (origin_policy_string.IsEmpty())\n    return;\n\n  std::unique_ptr<OriginPolicy> origin_policy = OriginPolicy::From(\n      StringUTF8Adaptor(origin_policy_string).AsStringPiece());\n  if (!origin_policy)\n    return;\n\n  for (const std::string& policy : origin_policy->GetFeaturePolicies()) {\n    if (!feature_policy.IsEmpty()) {\n      feature_policy.append(',');\n    }\n    feature_policy.append(\n        WTF::String::FromUTF8(policy.data(), policy.length()));\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int jpc_pchglist_insert(jpc_pchglist_t *pchglist, int pchgno, jpc_pchg_t *pchg)\n{\n\tint i;\n\tint newmaxpchgs;\n\tjpc_pchg_t **newpchgs;\n\tif (pchgno < 0) {\n\t\tpchgno = pchglist->numpchgs;\n\t}\n\tif (pchglist->numpchgs >= pchglist->maxpchgs) {\n\t\tnewmaxpchgs = pchglist->maxpchgs + 128;\n\t\tif (!(newpchgs = jas_realloc2(pchglist->pchgs, newmaxpchgs,\n\t\t  sizeof(jpc_pchg_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tpchglist->maxpchgs = newmaxpchgs;\n\t\tpchglist->pchgs = newpchgs;\n\t}\n\tfor (i = pchglist->numpchgs; i > pchgno; --i) {\n\t\tpchglist->pchgs[i] = pchglist->pchgs[i - 1];\n\t}\n\tpchglist->pchgs[pchgno] = pchg;\n\t++pchglist->numpchgs;\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-190"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static unsigned int hiddev_poll(struct file *file, poll_table *wait)\n{\n\tstruct hiddev_list *list = file->private_data;\n\n\tpoll_wait(file, &list->hiddev->wait, wait);\n\tif (list->head != list->tail)\n\t\treturn POLLIN | POLLRDNORM;\n\tif (!list->hiddev->exist)\n\t\treturn POLLERR | POLLHUP;\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool PrintRenderFrameHelper::PrintPagesNative(blink::WebLocalFrame* frame,\n                                              int page_count) {\n  const PrintMsg_PrintPages_Params& params = *print_pages_params_;\n  const PrintMsg_Print_Params& print_params = params.params;\n\n  std::vector<int> printed_pages = GetPrintedPages(params, page_count);\n  if (printed_pages.empty())\n    return false;\n\n  PdfMetafileSkia metafile(print_params.printed_doc_type);\n  CHECK(metafile.Init());\n\n  PrintHostMsg_DidPrintDocument_Params page_params;\n  PrintPageInternal(print_params, printed_pages[0], page_count, frame,\n                    &metafile, &page_params.page_size,\n                    &page_params.content_area);\n  for (size_t i = 1; i < printed_pages.size(); ++i) {\n    PrintPageInternal(print_params, printed_pages[i], page_count, frame,\n                      &metafile, nullptr, nullptr);\n  }\n\n  FinishFramePrinting();\n \n   metafile.FinishDocument();\n \n  if (!CopyMetafileDataToSharedMem(metafile,\n                                   &page_params.metafile_data_handle)) {\n     return false;\n   }\n \n  page_params.data_size = metafile.GetDataSize();\n  page_params.document_cookie = print_params.document_cookie;\n#if defined(OS_WIN)\n  page_params.physical_offsets = printer_printable_area_.origin();\n#endif\n  Send(new PrintHostMsg_DidPrintDocument(routing_id(), page_params));\n  return true;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-787"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\t/* this is just /cgroup/controller, return its contents */\n\t\t\tcgroup = \"/\";\n \t\t}\n \t}\n \n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n \t}\n \n \t/* we'll free this at cg_releasedir */\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &scm;\n \n\terr = scm_send(sock, msg, siocb->scm);\n \tif (err < 0)\n \t\treturn err;\n \n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-287"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xmlParseEntityRef(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n     xmlEntityPtr ent = NULL;\n \n     GROW;\n \n     if (RAW != '&')\n         return(NULL);\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParseEntityRef: no name\\n\");\n        return(NULL);\n    }\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n\treturn(NULL);\n    }\n    NEXT;\n\n    /*\n     * Predefined entites override any extra definition\n     */\n    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {\n        ent = xmlGetPredefinedEntity(name);\n        if (ent != NULL)\n            return(ent);\n    }\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Ask first SAX for entity resolution, otherwise try the\n     * entities which may have stored in the parser context.\n     */\n    if (ctxt->sax != NULL) {\n\tif (ctxt->sax->getEntity != NULL)\n\t    ent = ctxt->sax->getEntity(ctxt->userData, name);\n\tif ((ctxt->wellFormed == 1 ) && (ent == NULL) && \n\t    (ctxt->options & XML_PARSE_OLDSAX))\n\t    ent = xmlGetPredefinedEntity(name);\n\tif ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n\t    (ctxt->userData==ctxt)) {\n \t    ent = xmlSAX2GetEntity(ctxt, name);\n \t}\n     }\n     /*\n      * [ WFC: Entity Declared ]\n      * In a document without any DTD, a document with only an\n     * internal DTD subset which contains no parameter entity\n     * references, or a document with \"standalone='yes'\", the\n     * Name given in the entity reference must match that in an\n     * entity declaration, except that well-formed documents\n     * need not declare any of the following entities: amp, lt,\n     * gt, apos, quot.\n     * The declaration of a parameter entity must precede any\n     * reference to it.\n     * Similarly, the declaration of a general entity must\n     * precede any reference to it which appears in a default\n     * value in an attribute-list declaration. Note that if\n     * entities are declared in the external subset or in\n     * external parameter entities, a non-validating processor\n     * is not obligated to read and process their declarations;\n     * for such documents, the rule that an entity must be\n     * declared is a well-formedness constraint only if\n     * standalone='yes'.\n     */\n    if (ent == NULL) {\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' not defined\\n\", name);\n\t} else {\n\t    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' not defined\\n\", name);\n\t    if ((ctxt->inSubset == 0) &&\n\t\t(ctxt->sax != NULL) &&\n\t\t(ctxt->sax->reference != NULL)) {\n\t\tctxt->sax->reference(ctxt->userData, name);\n\t    }\n\t}\n\tctxt->valid = 0;\n    }\n\n    /*\n     * [ WFC: Parsed Entity ]\n     * An entity reference must not contain the name of an\n     * unparsed entity\n     */\n    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n\t\t \"Entity reference to unparsed entity %s\\n\", name);\n    }\n\n    /*\n     * [ WFC: No External Entity References ]\n     * Attribute values cannot contain direct or indirect\n     * entity references to external entities.\n     */\n    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&\n\t     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,\n\t     \"Attribute references external entity '%s'\\n\", name);\n    }\n    /*\n     * [ WFC: No < in Attribute Values ]\n     * The replacement text of any entity referred to directly or\n     * indirectly in an attribute value (other than \"&lt;\") must\n     * not contain a <. \n     */\n    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&\n\t     (ent != NULL) && (ent->content != NULL) &&\n\t     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t     (xmlStrchr(ent->content, '<'))) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n    \"'<' in entity '%s' is not allowed in attributes values\\n\", name);\n    }\n\n    /*\n     * Internal check, no parameter entities here ...\n     */\n    else {\n\tswitch (ent->etype) {\n\t    case XML_INTERNAL_PARAMETER_ENTITY:\n\t    case XML_EXTERNAL_PARAMETER_ENTITY:\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,\n\t     \"Attempt to reference the parameter entity '%s'\\n\",\n\t\t\t      name);\n\t    break;\n\t    default:\n\t    break;\n\t}\n    }\n\n    /*\n     * [ WFC: No Recursion ]\n     * A parsed entity must not contain a recursive reference\n     * to itself, either directly or indirectly. \n     * Done somewhere else\n     */\n    return(ent);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ppp_receive_mp_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\tu32 mask, seq;\n\tstruct channel *ch;\n\tint mphdrlen = (ppp->flags & SC_MP_SHORTSEQ)? MPHDRLEN_SSN: MPHDRLEN;\n\n\tif (!pskb_may_pull(skb, mphdrlen + 1) || ppp->mrru == 0)\n\t\tgoto err;\t\t/* no good, throw it away */\n\n\t/* Decode sequence number and begin/end bits */\n\tif (ppp->flags & SC_MP_SHORTSEQ) {\n\t\tseq = ((skb->data[2] & 0x0f) << 8) | skb->data[3];\n\t\tmask = 0xfff;\n\t} else {\n\t\tseq = (skb->data[3] << 16) | (skb->data[4] << 8)| skb->data[5];\n\t\tmask = 0xffffff;\n\t}\n\tPPP_MP_CB(skb)->BEbits = skb->data[2];\n\tskb_pull(skb, mphdrlen);\t/* pull off PPP and MP headers */\n\n\t/*\n\t * Do protocol ID decompression on the first fragment of each packet.\n\t */\n\tif ((PPP_MP_CB(skb)->BEbits & B) && (skb->data[0] & 1))\n\t\t*skb_push(skb, 1) = 0;\n\n\t/*\n\t * Expand sequence number to 32 bits, making it as close\n\t * as possible to ppp->minseq.\n\t */\n\tseq |= ppp->minseq & ~mask;\n\tif ((int)(ppp->minseq - seq) > (int)(mask >> 1))\n\t\tseq += mask + 1;\n\telse if ((int)(seq - ppp->minseq) > (int)(mask >> 1))\n\t\tseq -= mask + 1;\t/* should never happen */\n\tPPP_MP_CB(skb)->sequence = seq;\n\tpch->lastseq = seq;\n\n\t/*\n\t * If this packet comes before the next one we were expecting,\n\t * drop it.\n\t */\n\tif (seq_before(seq, ppp->nextseq)) {\n\t\tkfree_skb(skb);\n\t\t++ppp->dev->stats.rx_dropped;\n\t\tppp_receive_error(ppp);\n\t\treturn;\n\t}\n\n\t/*\n\t * Reevaluate minseq, the minimum over all channels of the\n\t * last sequence number received on each channel.  Because of\n\t * the increasing sequence number rule, we know that any fragment\n\t * before `minseq' which hasn't arrived is never going to arrive.\n\t * The list of channels can't change because we have the receive\n\t * side of the ppp unit locked.\n\t */\n\tlist_for_each_entry(ch, &ppp->channels, clist) {\n\t\tif (seq_before(ch->lastseq, seq))\n\t\t\tseq = ch->lastseq;\n\t}\n\tif (seq_before(ppp->minseq, seq))\n\t\tppp->minseq = seq;\n\n\t/* Put the fragment on the reconstruction queue */\n\tppp_mp_insert(ppp, skb);\n\n\t/* If the queue is getting long, don't wait any longer for packets\n\t   before the start of the queue. */\n\tif (skb_queue_len(&ppp->mrq) >= PPP_MP_MAX_QLEN) {\n\t\tstruct sk_buff *mskb = skb_peek(&ppp->mrq);\n\t\tif (seq_before(ppp->minseq, PPP_MP_CB(mskb)->sequence))\n\t\t\tppp->minseq = PPP_MP_CB(mskb)->sequence;\n\t}\n\n\t/* Pull completed packets off the queue and receive them. */\n\twhile ((skb = ppp_mp_reconstruct(ppp))) {\n\t\tif (pskb_may_pull(skb, 2))\n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t\telse {\n\t\t\t++ppp->dev->stats.rx_length_errors;\n\t\t\tkfree_skb(skb);\n\t\t\tppp_receive_error(ppp);\n\t\t}\n\t}\n\n\treturn;\n\n err:\n\tkfree_skb(skb);\n\tppp_receive_error(ppp);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "SMBC_server_internal(TALLOC_CTX *ctx,\n            SMBCCTX *context,\n            bool connect_if_not_found,\n            const char *server,\n            uint16_t port,\n            const char *share,\n            char **pp_workgroup,\n            char **pp_username,\n            char **pp_password,\n\t    bool *in_cache)\n{\n\tSMBCSRV *srv=NULL;\n\tchar *workgroup = NULL;\n\tstruct cli_state *c = NULL;\n\tconst char *server_n = server;\n        int is_ipc = (share != NULL && strcmp(share, \"IPC$\") == 0);\n\tuint32_t fs_attrs = 0;\n        const char *username_used;\n \tNTSTATUS status;\n        char *newserver, *newshare;\n        int flags = 0;\n        struct smbXcli_tcon *tcon = NULL;\n \n        ZERO_STRUCT(c);\n        *in_cache = false;\n\tif (server[0] == 0) {\n\t\terrno = EPERM;\n\t\treturn NULL;\n\t}\n\n        /* Look for a cached connection */\n        srv = SMBC_find_server(ctx, context, server, share,\n                               pp_workgroup, pp_username, pp_password);\n\n        /*\n         * If we found a connection and we're only allowed one share per\n         * server...\n         */\n        if (srv &&\n\t    share != NULL && *share != '\\0' &&\n            smbc_getOptionOneSharePerServer(context)) {\n\n                /*\n                 * ... then if there's no current connection to the share,\n                 * connect to it.  SMBC_find_server(), or rather the function\n                 * pointed to by context->get_cached_srv_fn which\n                 * was called by SMBC_find_server(), will have issued a tree\n                 * disconnect if the requested share is not the same as the\n                 * one that was already connected.\n                 */\n\n\t\t/*\n\t\t * Use srv->cli->desthost and srv->cli->share instead of\n\t\t * server and share below to connect to the actual share,\n\t\t * i.e., a normal share or a referred share from\n\t\t * 'msdfs proxy' share.\n\t\t */\n                if (!cli_state_has_tcon(srv->cli)) {\n                        /* Ensure we have accurate auth info */\n\t\t\tSMBC_call_auth_fn(ctx, context,\n\t\t\t\t\t  smbXcli_conn_remote_name(srv->cli->conn),\n\t\t\t\t\t  srv->cli->share,\n                                          pp_workgroup,\n                                          pp_username,\n                                          pp_password);\n\n\t\t\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\tcli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n\t\t\t\tsmbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We don't need to renegotiate encryption\n\t\t\t * here as the encryption context is not per\n\t\t\t * tid.\n\t\t\t */\n\n\t\t\tstatus = cli_tree_connect(srv->cli,\n\t\t\t\t\t\t  srv->cli->share,\n\t\t\t\t\t\t  \"?????\",\n\t\t\t\t\t\t  *pp_password,\n\t\t\t\t\t\t  strlen(*pp_password)+1);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n                                errno = map_errno_from_nt_status(status);\n                                cli_shutdown(srv->cli);\n\t\t\t\tsrv->cli = NULL;\n                                smbc_getFunctionRemoveCachedServer(context)(context,\n                                                                            srv);\n                                srv = NULL;\n                        }\n\n                        /* Determine if this share supports case sensitivity */\n                        if (is_ipc) {\n                                DEBUG(4,\n                                      (\"IPC$ so ignore case sensitivity\\n\"));\n                                status = NT_STATUS_OK;\n                        } else {\n                                status = cli_get_fs_attr_info(c, &fs_attrs);\n                        }\n\n                        if (!NT_STATUS_IS_OK(status)) {\n                                DEBUG(4, (\"Could not retrieve \"\n                                          \"case sensitivity flag: %s.\\n\",\n                                          nt_errstr(status)));\n\n                                /*\n                                 * We can't determine the case sensitivity of\n                                 * the share. We have no choice but to use the\n                                 * user-specified case sensitivity setting.\n                                 */\n                                if (smbc_getOptionCaseSensitive(context)) {\n                                        cli_set_case_sensitive(c, True);\n                                } else {\n                                        cli_set_case_sensitive(c, False);\n                                }\n                        } else if (!is_ipc) {\n                                DEBUG(4,\n                                      (\"Case sensitive: %s\\n\",\n                                       (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                        ? \"True\"\n                                        : \"False\")));\n                                cli_set_case_sensitive(\n                                        c,\n                                        (fs_attrs & FILE_CASE_SENSITIVE_SEARCH\n                                         ? True\n                                         : False));\n                        }\n\n                        /*\n                         * Regenerate the dev value since it's based on both\n                         * server and share\n                         */\n                        if (srv) {\n\t\t\t\tconst char *remote_name =\n\t\t\t\t\tsmbXcli_conn_remote_name(srv->cli->conn);\n\n\t\t\t\tsrv->dev = (dev_t)(str_checksum(remote_name) ^\n                                                   str_checksum(srv->cli->share));\n                        }\n                }\n        }\n\n        /* If we have a connection... */\n        if (srv) {\n\n                /* ... then we're done here.  Give 'em what they came for. */\n\t\t*in_cache = true;\n                goto done;\n        }\n\n        /* If we're not asked to connect when a connection doesn't exist... */\n        if (! connect_if_not_found) {\n                /* ... then we're done here. */\n                return NULL;\n        }\n\n\tif (!*pp_workgroup || !*pp_username || !*pp_password) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tDEBUG(4,(\"SMBC_server: server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tDEBUG(4,(\" -> server_n=[%s] server=[%s]\\n\", server_n, server));\n\n\tstatus = NT_STATUS_UNSUCCESSFUL;\n\n\tif (smbc_getOptionUseKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_KERBEROS;\n\t}\n\n\tif (smbc_getOptionFallbackAfterKerberos(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_FALLBACK_AFTER_KERBEROS;\n\t}\n\n\tif (smbc_getOptionUseCCache(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_CCACHE;\n\t}\n\n\tif (smbc_getOptionUseNTHash(context)) {\n\t\tflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n                flags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n        }\n \n        if (port == 0) {\n                if (share == NULL || *share == '\\0' || is_ipc) {\n                        /*\n\t\t}\n                         */\n                        status = cli_connect_nb(server_n, NULL, NBT_SMB_PORT, 0x20,\n                                        smbc_getNetbiosName(context),\n                                       SMB_SIGNING_DEFAULT, flags, &c);\n                }\n        }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Cues::LoadCuePoint() const {\n   const long long stop = m_start + m_size;\n \n   if (m_pos >= stop)\n     return false;  // nothing else to do\n \n  Init();\n \n   IMkvReader* const pReader = m_pSegment->m_pReader;\n \n while (m_pos < stop) {\n const long long idpos = m_pos;\n\n \n     long len;\n \n    const long long id = ReadUInt(pReader, m_pos, len);\n    assert(id >= 0);  // TODO\n    assert((m_pos + len) <= stop);\n \n     m_pos += len;  // consume ID\n \n     const long long size = ReadUInt(pReader, m_pos, len);\n    assert(size >= 0);\n    assert((m_pos + len) <= stop);\n \n     m_pos += len;  // consume Size field\n    assert((m_pos + size) <= stop);\n \n     if (id != 0x3B) {  // CuePoint ID\n       m_pos += size;  // consume payload\n      assert(m_pos <= stop);\n \n       continue;\n     }\n \n    assert(m_preload_count > 0);\n    CuePoint* const pCP = m_cue_points[m_count];\n    assert(pCP);\n    assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));\n    if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))\n       return false;\n \n    pCP->Load(pReader);\n     ++m_count;\n     --m_preload_count;\n \n     m_pos += size;  // consume payload\n    assert(m_pos <= stop);\n \n     return true;  // yes, we loaded a cue point\n   }\n \n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    file_size = (uint32_t)avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf chunk_size %u\\n\", size);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf file_size %u\\n\", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf duration %\"PRId64\" ms\\n\", duration);\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\",\n            strings_size, table_entries, table_entries_used);\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got header; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_log(s, AV_LOG_TRACE, \"NSV NSVf INFO: %s='%s'\\n\", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got infos; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n         if (!nsv->nsvs_file_offset)\n             return AVERROR(ENOMEM);\n \n        for(i=0;i<table_entries_used;i++)\n             nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n \n         if(table_entries > table_entries_used &&\n            avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_TRACE, \"NSV got index; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (avio_feof(pb))\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-834"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void nfs4_release_lockowner(const struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server = lsp->ls_state->owner->so_server;\n\tstruct nfs_release_lockowner_args *args;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RELEASE_LOCKOWNER],\n\t};\n\n\tif (server->nfs_client->cl_mvops->minor_version != 0)\n\t\treturn;\n\targs = kmalloc(sizeof(*args), GFP_NOFS);\n\tif (!args)\n\t\treturn;\n\targs->lock_owner.clientid = server->nfs_client->cl_clientid;\n\targs->lock_owner.id = lsp->ls_id.id;\n\targs->lock_owner.s_dev = server->s_dev;\n\tmsg.rpc_argp = args;\n\trpc_call_async(server->client, &msg, 0, &nfs4_release_lockowner_ops, args);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "my_object_send_car (MyObject *obj, GValueArray *invals, GValueArray **outvals, GError **error)\n{\n  if (invals->n_values != 3\n      || G_VALUE_TYPE (g_value_array_get_nth (invals, 0)) != G_TYPE_STRING\n      || G_VALUE_TYPE (g_value_array_get_nth (invals, 1)) != G_TYPE_UINT\n      || G_VALUE_TYPE (g_value_array_get_nth (invals, 2)) != G_TYPE_VALUE)\n    {\n      g_set_error (error,\n\t\t   MY_OBJECT_ERROR,\n\t\t   MY_OBJECT_ERROR_FOO,\n\t\t   \"invalid incoming values\");\n      return FALSE;\n    }\n  *outvals = g_value_array_new (2);\n  g_value_array_append (*outvals, NULL);\n  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), G_TYPE_UINT);\n  g_value_set_uint (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),\n\t\t    g_value_get_uint (g_value_array_get_nth (invals, 1)) + 1);\n  g_value_array_append (*outvals, NULL);\n  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), DBUS_TYPE_G_OBJECT_PATH);\n  g_value_set_boxed (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),\n\t\t     g_strdup (\"/org/freedesktop/DBus/GLib/Tests/MyTestObject2\"));\n  return TRUE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,\n const MotionEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime,\n bool* outConflictingPointerActions) {\n enum InjectionPermission {\n        INJECTION_PERMISSION_UNKNOWN,\n        INJECTION_PERMISSION_GRANTED,\n        INJECTION_PERMISSION_DENIED\n };\n\n nsecs_t startTime = now();\n\n int32_t displayId = entry->displayId;\n int32_t action = entry->action;\n int32_t maskedAction = action & AMOTION_EVENT_ACTION_MASK;\n\n int32_t injectionResult = INPUT_EVENT_INJECTION_PENDING;\n InjectionPermission injectionPermission = INJECTION_PERMISSION_UNKNOWN;\n    sp<InputWindowHandle> newHoverWindowHandle;\n\n const TouchState* oldState = NULL;\n ssize_t oldStateIndex = mTouchStatesByDisplay.indexOfKey(displayId);\n if (oldStateIndex >= 0) {\n        oldState = &mTouchStatesByDisplay.valueAt(oldStateIndex);\n        mTempTouchState.copyFrom(*oldState);\n }\n\n bool isSplit = mTempTouchState.split;\n bool switchedDevice = mTempTouchState.deviceId >= 0 && mTempTouchState.displayId >= 0\n && (mTempTouchState.deviceId != entry->deviceId\n || mTempTouchState.source != entry->source\n || mTempTouchState.displayId != displayId);\n bool isHoverAction = (maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_EXIT);\n bool newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN\n || maskedAction == AMOTION_EVENT_ACTION_SCROLL\n || isHoverAction);\n bool wrongDevice = false;\n if (newGesture) {\n bool down = maskedAction == AMOTION_EVENT_ACTION_DOWN;\n if (switchedDevice && mTempTouchState.down && !down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because a pointer for a different device is already down.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            switchedDevice = false;\n            wrongDevice = true;\n goto Failed;\n }\n        mTempTouchState.reset();\n        mTempTouchState.down = down;\n        mTempTouchState.deviceId = entry->deviceId;\n        mTempTouchState.source = entry->source;\n        mTempTouchState.displayId = displayId;\n        isSplit = false;\n }\n\n if (newGesture || (isSplit && maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) {\n /* Case 1: New splittable pointer going down, or need target for hover or scroll. */\n\n int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n int32_t x = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_X));\n int32_t y = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_Y));\n        sp<InputWindowHandle> newTouchedWindowHandle;\n bool isTouchModal = false;\n\n size_t numWindows = mWindowHandles.size();\n for (size_t i = 0; i < numWindows; i++) {\n            sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n const InputWindowInfo* windowInfo = windowHandle->getInfo();\n if (windowInfo->displayId != displayId) {\n continue; // wrong display\n }\n\n int32_t flags = windowInfo->layoutParamsFlags;\n if (windowInfo->visible) {\n if (! (flags & InputWindowInfo::FLAG_NOT_TOUCHABLE)) {\n                    isTouchModal = (flags & (InputWindowInfo::FLAG_NOT_FOCUSABLE\n | InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == 0;\n if (isTouchModal || windowInfo->touchableRegionContainsPoint(x, y)) {\n                        newTouchedWindowHandle = windowHandle;\n break; // found touched window, exit window loop\n }\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN\n && (flags & InputWindowInfo::FLAG_WATCH_OUTSIDE_TOUCH)) {\n\n                     int32_t outsideTargetFlags = InputTarget::FLAG_DISPATCH_AS_OUTSIDE;\n                     if (isWindowObscuredAtPointLocked(windowHandle, x, y)) {\n                         outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n                     }\n \n                     mTempTouchState.addOrUpdateWindow(\n                            windowHandle, outsideTargetFlags, BitSet32(0));\n }\n }\n }\n\n if (newTouchedWindowHandle != NULL\n && newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n            isSplit = true;\n } else if (isSplit) {\n            newTouchedWindowHandle = NULL;\n }\n\n if (newTouchedWindowHandle == NULL) {\n            newTouchedWindowHandle = mTempTouchState.getFirstForegroundWindowHandle();\n if (newTouchedWindowHandle == NULL) {\n                ALOGI(\"Dropping event because there is no touchable window at (%d, %d).\", x, y);\n                injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n }\n\n int32_t targetFlags = InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS;\n if (isSplit) {\n            targetFlags |= InputTarget::FLAG_SPLIT;\n\n         }\n         if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n             targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n         }\n \n if (isHoverAction) {\n            newHoverWindowHandle = newTouchedWindowHandle;\n } else if (maskedAction == AMOTION_EVENT_ACTION_SCROLL) {\n            newHoverWindowHandle = mLastHoverWindowHandle;\n }\n\n BitSet32 pointerIds;\n if (isSplit) {\n uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n            pointerIds.markBit(pointerId);\n }\n        mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n } else {\n /* Case 2: Pointer move, up, cancel or non-splittable pointer down. */\n\n if (! mTempTouchState.down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because the pointer is not down or we previously \"\n \"dropped the pointer down event.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_MOVE\n && entry->pointerCount == 1\n && mTempTouchState.isSlippery()) {\n int32_t x = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_X));\n int32_t y = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_Y));\n\n            sp<InputWindowHandle> oldTouchedWindowHandle =\n                    mTempTouchState.getFirstForegroundWindowHandle();\n            sp<InputWindowHandle> newTouchedWindowHandle =\n                    findTouchedWindowAtLocked(displayId, x, y);\n if (oldTouchedWindowHandle != newTouchedWindowHandle\n && newTouchedWindowHandle != NULL) {\n#if DEBUG_FOCUS\n                ALOGD(\"Touch is slipping out of window %s into window %s.\",\n                        oldTouchedWindowHandle->getName().string(),\n                        newTouchedWindowHandle->getName().string());\n#endif\n                mTempTouchState.addOrUpdateWindow(oldTouchedWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT, BitSet32(0));\n\n if (newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n                    isSplit = true;\n }\n\n int32_t targetFlags = InputTarget::FLAG_FOREGROUND\n | InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER;\n if (isSplit) {\n                    targetFlags |= InputTarget::FLAG_SPLIT;\n }\n if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n                    targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n }\n\n BitSet32 pointerIds;\n if (isSplit) {\n                    pointerIds.markBit(entry->pointerProperties[0].id);\n }\n                mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n }\n }\n }\n\n if (newHoverWindowHandle != mLastHoverWindowHandle) {\n if (mLastHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover exit event to window %s.\",\n                    mLastHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(mLastHoverWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT, BitSet32(0));\n }\n\n if (newHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover enter event to window %s.\",\n                    newHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(newHoverWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER, BitSet32(0));\n }\n }\n\n {\n bool haveForegroundWindow = false;\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n                haveForegroundWindow = true;\n if (! checkInjectionPermission(touchedWindow.windowHandle,\n                        entry->injectionState)) {\n                    injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;\n                    injectionPermission = INJECTION_PERMISSION_DENIED;\n goto Failed;\n }\n }\n }\n if (! haveForegroundWindow) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because there is no touched foreground window to receive it.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n\n        injectionPermission = INJECTION_PERMISSION_GRANTED;\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n const int32_t foregroundWindowUid = foregroundWindowHandle->getInfo()->ownerUid;\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n                sp<InputWindowHandle> inputWindowHandle = touchedWindow.windowHandle;\n if (inputWindowHandle->getInfo()->ownerUid != foregroundWindowUid) {\n                    mTempTouchState.addOrUpdateWindow(inputWindowHandle,\n InputTarget::FLAG_ZERO_COORDS, BitSet32(0));\n }\n }\n }\n }\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n String8 reason = checkWindowReadyForMoreInputLocked(currentTime,\n                    touchedWindow.windowHandle, entry, \"touched\");\n if (!reason.isEmpty()) {\n                injectionResult = handleTargetsNotReadyLocked(currentTime, entry,\n                        NULL, touchedWindow.windowHandle, nextWakeupTime, reason.string());\n goto Unresponsive;\n }\n }\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n if (foregroundWindowHandle->getInfo()->hasWallpaper) {\n for (size_t i = 0; i < mWindowHandles.size(); i++) {\n                sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n const InputWindowInfo* info = windowHandle->getInfo();\n if (info->displayId == displayId\n && windowHandle->getInfo()->layoutParamsType\n\n                                 == InputWindowInfo::TYPE_WALLPAPER) {\n                     mTempTouchState.addOrUpdateWindow(windowHandle,\n                             InputTarget::FLAG_WINDOW_IS_OBSCURED\n                                     | InputTarget::FLAG_DISPATCH_AS_IS,\n                             BitSet32(0));\n                 }\n }\n }\n }\n\n    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows.itemAt(i);\n        addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags,\n                touchedWindow.pointerIds, inputTargets);\n }\n\n    mTempTouchState.filterNonAsIsTouchWindows();\n\nFailed:\n if (injectionPermission == INJECTION_PERMISSION_UNKNOWN) {\n if (checkInjectionPermission(NULL, entry->injectionState)) {\n            injectionPermission = INJECTION_PERMISSION_GRANTED;\n } else {\n            injectionPermission = INJECTION_PERMISSION_DENIED;\n }\n }\n\n if (injectionPermission == INJECTION_PERMISSION_GRANTED) {\n if (!wrongDevice) {\n if (switchedDevice) {\n#if DEBUG_FOCUS\n                ALOGD(\"Conflicting pointer actions: Switched to a different device.\");\n#endif\n *outConflictingPointerActions = true;\n }\n\n if (isHoverAction) {\n if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Hover received while pointer was down.\");\n#endif\n *outConflictingPointerActions = true;\n }\n                mTempTouchState.reset();\n if (maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE) {\n                    mTempTouchState.deviceId = entry->deviceId;\n                    mTempTouchState.source = entry->source;\n                    mTempTouchState.displayId = displayId;\n }\n } else if (maskedAction == AMOTION_EVENT_ACTION_UP\n || maskedAction == AMOTION_EVENT_ACTION_CANCEL) {\n                mTempTouchState.reset();\n } else if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Down received while already down.\");\n#endif\n *outConflictingPointerActions = true;\n }\n } else if (maskedAction == AMOTION_EVENT_ACTION_POINTER_UP) {\n if (isSplit) {\n int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); ) {\n TouchedWindow& touchedWindow = mTempTouchState.windows.editItemAt(i);\n if (touchedWindow.targetFlags & InputTarget::FLAG_SPLIT) {\n                            touchedWindow.pointerIds.clearBit(pointerId);\n if (touchedWindow.pointerIds.isEmpty()) {\n                                mTempTouchState.windows.removeAt(i);\n continue;\n }\n }\n                        i += 1;\n }\n }\n }\n\n if (maskedAction != AMOTION_EVENT_ACTION_SCROLL) {\n if (mTempTouchState.displayId >= 0) {\n if (oldStateIndex >= 0) {\n                        mTouchStatesByDisplay.editValueAt(oldStateIndex).copyFrom(mTempTouchState);\n } else {\n                        mTouchStatesByDisplay.add(displayId, mTempTouchState);\n }\n } else if (oldStateIndex >= 0) {\n                    mTouchStatesByDisplay.removeItemsAt(oldStateIndex);\n }\n }\n\n            mLastHoverWindowHandle = newHoverWindowHandle;\n }\n } else {\n#if DEBUG_FOCUS\n        ALOGD(\"Not updating touch focus because injection was denied.\");\n#endif\n }\n\nUnresponsive:\n    mTempTouchState.reset();\n\n nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);\n    updateDispatchStatisticsLocked(currentTime, entry,\n            injectionResult, timeSpentWaitingForApplication);\n#if DEBUG_FOCUS\n    ALOGD(\"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, \"\n \"timeSpentWaitingForApplication=%0.1fms\",\n            injectionResult, injectionPermission, timeSpentWaitingForApplication / 1000000.0);\n#endif\n return injectionResult;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void read_boot(DOS_FS * fs)\n{\n     struct boot_sector b;\n     unsigned total_sectors;\n     unsigned short logical_sector_size, sectors;\n    unsigned fat_length;\n     unsigned total_fat_entries;\n     off_t data_size;\n \n    fs_read(0, sizeof(b), &b);\n    logical_sector_size = GET_UNALIGNED_W(b.sector_size);\n    if (!logical_sector_size)\n\tdie(\"Logical sector size is zero.\");\n\n    /* This was moved up because it's the first thing that will fail */\n    /* if the platform needs special handling of unaligned multibyte accesses */\n    /* but such handling isn't being provided. See GET_UNALIGNED_W() above. */\n    if (logical_sector_size & (SECTOR_SIZE - 1))\n\tdie(\"Logical sector size (%d bytes) is not a multiple of the physical \"\n\t    \"sector size.\", logical_sector_size);\n\n    fs->cluster_size = b.cluster_size * logical_sector_size;\n    if (!fs->cluster_size)\n\tdie(\"Cluster size is zero.\");\n    if (b.fats != 2 && b.fats != 1)\n\tdie(\"Currently, only 1 or 2 FATs are supported, not %d.\\n\", b.fats);\n    fs->nfats = b.fats;\n    sectors = GET_UNALIGNED_W(b.sectors);\n    total_sectors = sectors ? sectors : le32toh(b.total_sect);\n    if (verbose)\n\tprintf(\"Checking we can access the last sector of the filesystem\\n\");\n     /* Can't access last odd sector anyway, so round down */\n     fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,\n \t    logical_sector_size);\n     fat_length = le16toh(b.fat_length) ?\n \tle16toh(b.fat_length) : le32toh(b.fat32_length);\n     fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;\n     fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *\n \tlogical_sector_size;\n     fs->root_entries = GET_UNALIGNED_W(b.dir_entries);\n     fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<\n \t\t\t\t\t\t\tMSDOS_DIR_BITS,\n \t\t\t\t\t\t\tlogical_sector_size);\n     data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;\n     fs->data_clusters = data_size / fs->cluster_size;\n     fs->root_cluster = 0;\t/* indicates standard, pre-FAT32 root dir */\n     fs->fsinfo_start = 0;\t/* no FSINFO structure */\n    fs->free_clusters = -1;\t/* unknown */\n    if (!b.fat_length && b.fat32_length) {\n\tfs->fat_bits = 32;\n\tfs->root_cluster = le32toh(b.root_cluster);\n\tif (!fs->root_cluster && fs->root_entries)\n\t    /* M$ hasn't specified this, but it looks reasonable: If\n\t     * root_cluster is 0 but there is a separate root dir\n\t     * (root_entries != 0), we handle the root dir the old way. Give a\n\t     * warning, but convertig to a root dir in a cluster chain seems\n\t     * to complex for now... */\n\t    printf(\"Warning: FAT32 root dir not in cluster chain! \"\n\t\t   \"Compatibility mode...\\n\");\n\telse if (!fs->root_cluster && !fs->root_entries)\n\t    die(\"No root directory!\");\n\telse if (fs->root_cluster && fs->root_entries)\n\t    printf(\"Warning: FAT32 root dir is in a cluster chain, but \"\n\t\t   \"a separate root dir\\n\"\n\t\t   \"  area is defined. Cannot fix this easily.\\n\");\n\tif (fs->data_clusters < FAT16_THRESHOLD)\n\t    printf(\"Warning: Filesystem is FAT32 according to fat_length \"\n\t\t   \"and fat32_length fields,\\n\"\n\t\t   \"  but has only %lu clusters, less than the required \"\n\t\t   \"minimum of %d.\\n\"\n\t\t   \"  This may lead to problems on some systems.\\n\",\n\t\t   (unsigned long)fs->data_clusters, FAT16_THRESHOLD);\n\n\tcheck_fat_state_bit(fs, &b);\n\tfs->backupboot_start = le16toh(b.backup_boot) * logical_sector_size;\n\tcheck_backup_boot(fs, &b, logical_sector_size);\n\n\tread_fsinfo(fs, &b, logical_sector_size);\n    } else if (!atari_format) {\n\t/* On real MS-DOS, a 16 bit FAT is used whenever there would be too\n\t * much clusers otherwise. */\n\tfs->fat_bits = (fs->data_clusters >= FAT12_THRESHOLD) ? 16 : 12;\n\tif (fs->data_clusters >= FAT16_THRESHOLD)\n\t    die(\"Too many clusters (%lu) for FAT16 filesystem.\", fs->data_clusters);\n\tcheck_fat_state_bit(fs, &b);\n    } else {\n\t/* On Atari, things are more difficult: GEMDOS always uses 12bit FATs\n\t * on floppies, and always 16 bit on harddisks. */\n\tfs->fat_bits = 16;\t/* assume 16 bit FAT for now */\n\t/* If more clusters than fat entries in 16-bit fat, we assume\n\t * it's a real MSDOS FS with 12-bit fat. */\n\tif (fs->data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||\n\t    /* if it has one of the usual floppy sizes -> 12bit FAT  */\n\t    (total_sectors == 720 || total_sectors == 1440 ||\n\t     total_sectors == 2880))\n\t    fs->fat_bits = 12;\n    }\n    /* On FAT32, the high 4 bits of a FAT entry are reserved */\n    fs->eff_fat_bits = (fs->fat_bits == 32) ? 28 : fs->fat_bits;\n    fs->fat_size = fat_length * logical_sector_size;\n\n    fs->label = calloc(12, sizeof(uint8_t));\n    if (fs->fat_bits == 12 || fs->fat_bits == 16) {\n\tstruct boot_sector_16 *b16 = (struct boot_sector_16 *)&b;\n\tif (b16->extended_sig == 0x29)\n\t    memmove(fs->label, b16->label, 11);\n\telse\n\t    fs->label = NULL;\n    } else if (fs->fat_bits == 32) {\n\tif (b.extended_sig == 0x29)\n\t    memmove(fs->label, &b.label, 11);\n\telse\n\t    fs->label = NULL;\n    }\n\n    total_fat_entries = (uint64_t)fs->fat_size * 8 / fs->fat_bits;\n    if (fs->data_clusters > total_fat_entries - 2)\n\tdie(\"Filesystem has %u clusters but only space for %u FAT entries.\",\n\t    fs->data_clusters, total_fat_entries - 2);\n    if (!fs->root_entries && !fs->root_cluster)\n\tdie(\"Root directory has zero size.\");\n    if (fs->root_entries & (MSDOS_DPS - 1))\n\tdie(\"Root directory (%d entries) doesn't span an integral number of \"\n\t    \"sectors.\", fs->root_entries);\n    if (logical_sector_size & (SECTOR_SIZE - 1))\n\tdie(\"Logical sector size (%d bytes) is not a multiple of the physical \"\n\t    \"sector size.\", logical_sector_size);\n#if 0\t\t\t\t/* linux kernel doesn't check that either */\n    /* ++roman: On Atari, these two fields are often left uninitialized */\n    if (!atari_format && (!b.secs_track || !b.heads))\n\tdie(\"Invalid disk format in boot sector.\");\n#endif\n    if (verbose)\n\tdump_boot(fs, &b, logical_sector_size);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::CreateVP8Picture() {\n   scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();\n   if (!va_surface)\n     return nullptr;\n\n  return new VaapiVP8Picture(std::move(va_surface));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)\n{\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-369"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "double AudioTrack::GetSamplingRate() const\n{\n    return m_rate;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void NetworkHandler::DeleteCookies(\n    const std::string& name,\n    Maybe<std::string> url,\n     Maybe<std::string> domain,\n     Maybe<std::string> path,\n     std::unique_ptr<DeleteCookiesCallback> callback) {\n  if (!process_) {\n     callback->sendFailure(Response::InternalError());\n     return;\n   }\n\n  if (!url.isJust() && !domain.isJust()) {\n    callback->sendFailure(Response::InvalidParams(\n        \"At least one of the url and domain needs to be specified\"));\n  }\n  BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(\n           &DeleteCookiesOnIO,\n          base::Unretained(\n              process_->GetStoragePartition()->GetURLRequestContext()),\n          name, url.fromMaybe(\"\"), domain.fromMaybe(\"\"), path.fromMaybe(\"\"),\n           base::BindOnce(&DeleteCookiesCallback::sendSuccess,\n                          std::move(callback))));\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "xml_start(struct archive_read *a, const char *name, struct xmlattr_list *list)\n{\n\tstruct xar *xar;\n\tstruct xmlattr *attr;\n\n\txar = (struct xar *)(a->format->data);\n\n#if DEBUG\n\tfprintf(stderr, \"xml_sta:[%s]\\n\", name);\n\tfor (attr = list->first; attr != NULL; attr = attr->next)\n\t\tfprintf(stderr, \"    attr:\\\"%s\\\"=\\\"%s\\\"\\n\",\n\t\t    attr->name, attr->value);\n#endif\n\txar->base64text = 0;\n\tswitch (xar->xmlsts) {\n\tcase INIT:\n\t\tif (strcmp(name, \"xar\") == 0)\n\t\t\txar->xmlsts = XAR;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase XAR:\n\t\tif (strcmp(name, \"toc\") == 0)\n\t\t\txar->xmlsts = TOC;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC:\n\t\tif (strcmp(name, \"creation-time\") == 0)\n\t\t\txar->xmlsts = TOC_CREATION_TIME;\n\t\telse if (strcmp(name, \"checksum\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM;\n\t\telse if (strcmp(name, \"file\") == 0) {\n\t\t\tif (file_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\txar->xmlsts = TOC_FILE;\n\t\t}\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_CHECKSUM:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM_SIZE;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_FILE:\n\t\tif (strcmp(name, \"file\") == 0) {\n\t\t\tif (file_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\telse if (strcmp(name, \"data\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\telse if (strcmp(name, \"ea\") == 0) {\n\t\t\tif (xattr_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\txar->xmlsts = FILE_EA;\n\t\t}\n\t\telse if (strcmp(name, \"ctime\") == 0)\n\t\t\txar->xmlsts = FILE_CTIME;\n\t\telse if (strcmp(name, \"mtime\") == 0)\n\t\t\txar->xmlsts = FILE_MTIME;\n\t\telse if (strcmp(name, \"atime\") == 0)\n\t\t\txar->xmlsts = FILE_ATIME;\n\t\telse if (strcmp(name, \"group\") == 0)\n\t\t\txar->xmlsts = FILE_GROUP;\n\t\telse if (strcmp(name, \"gid\") == 0)\n\t\t\txar->xmlsts = FILE_GID;\n\t\telse if (strcmp(name, \"user\") == 0)\n\t\t\txar->xmlsts = FILE_USER;\n\t\telse if (strcmp(name, \"uid\") == 0)\n\t\t\txar->xmlsts = FILE_UID;\n\t\telse if (strcmp(name, \"mode\") == 0)\n\t\t\txar->xmlsts = FILE_MODE;\n\t\telse if (strcmp(name, \"device\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE;\n\t\telse if (strcmp(name, \"deviceno\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICENO;\n\t\telse if (strcmp(name, \"inode\") == 0)\n\t\t\txar->xmlsts = FILE_INODE;\n\t\telse if (strcmp(name, \"link\") == 0)\n\t\t\txar->xmlsts = FILE_LINK;\n\t\telse if (strcmp(name, \"type\") == 0) {\n\t\t\txar->xmlsts = FILE_TYPE;\n\t\t\tfor (attr = list->first; attr != NULL;\n\t\t\t    attr = attr->next) {\n\t\t\t\tif (strcmp(attr->name, \"link\") != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (strcmp(attr->value, \"original\") == 0) {\n\t\t\t\t\txar->file->hdnext = xar->hdlink_orgs;\n\t\t\t\t\txar->hdlink_orgs = xar->file;\n\t\t\t\t} else {\n\t\t\t\t\txar->file->link = (unsigned)atol10(attr->value,\n\t\t\t\t\t    strlen(attr->value));\n\t\t\t\t\tif (xar->file->link > 0)\n\t\t\t\t\t\tif (add_link(a, xar, xar->file) != ARCHIVE_OK) {\n\t\t\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(name, \"name\") == 0) {\n\t\t\txar->xmlsts = FILE_NAME;\n\t\t\tfor (attr = list->first; attr != NULL;\n\t\t\t    attr = attr->next) {\n\t\t\t\tif (strcmp(attr->name, \"enctype\") == 0 &&\n\t\t\t\t    strcmp(attr->value, \"base64\") == 0)\n\t\t\t\t\txar->base64text = 1;\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(name, \"acl\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\telse if (strcmp(name, \"flags\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\telse if (strcmp(name, \"ext2\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DATA:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_LENGTH;\n\t\telse if (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_SIZE;\n\t\telse if (strcmp(name, \"encoding\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_ENCODING;\n\t\t\txar->file->encoding = getencoding(list);\n\t\t}\n\t\telse if (strcmp(name, \"archived-checksum\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_A_CHECKSUM;\n\t\t\txar->file->a_sum.alg = getsumalgorithm(list);\n\t\t}\n\t\telse if (strcmp(name, \"extracted-checksum\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_E_CHECKSUM;\n\t\t\txar->file->e_sum.alg = getsumalgorithm(list);\n\t\t}\n\t\telse if (strcmp(name, \"content\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_CONTENT;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DEVICE:\n\t\tif (strcmp(name, \"major\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE_MAJOR;\n\t\telse if (strcmp(name, \"minor\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE_MINOR;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DATA_CONTENT:\n\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_EA:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_EA_LENGTH;\n\t\telse if (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_EA_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_EA_SIZE;\n\t\telse if (strcmp(name, \"encoding\") == 0) {\n\t\t\txar->xmlsts = FILE_EA_ENCODING;\n\t\t\txar->xattr->encoding = getencoding(list);\n\t\t} else if (strcmp(name, \"archived-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA_A_CHECKSUM;\n\t\telse if (strcmp(name, \"extracted-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA_E_CHECKSUM;\n\t\telse if (strcmp(name, \"name\") == 0)\n\t\t\txar->xmlsts = FILE_EA_NAME;\n\t\telse if (strcmp(name, \"fstype\") == 0)\n\t\t\txar->xmlsts = FILE_EA_FSTYPE;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_ACL:\n\t\tif (strcmp(name, \"appleextended\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_APPLEEXTENDED;\n\t\telse if (strcmp(name, \"default\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_DEFAULT;\n\t\telse if (strcmp(name, \"access\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_ACCESS;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_FLAGS:\n\t\tif (!xml_parse_file_flags(xar, name))\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_EXT2:\n\t\tif (!xml_parse_file_ext2(xar, name))\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_CREATION_TIME:\n\tcase TOC_CHECKSUM_OFFSET:\n\tcase TOC_CHECKSUM_SIZE:\n\tcase FILE_DATA_LENGTH:\n\tcase FILE_DATA_OFFSET:\n\tcase FILE_DATA_SIZE:\n\tcase FILE_DATA_ENCODING:\n\tcase FILE_DATA_A_CHECKSUM:\n\tcase FILE_DATA_E_CHECKSUM:\n\tcase FILE_EA_LENGTH:\n\tcase FILE_EA_OFFSET:\n\tcase FILE_EA_SIZE:\n\tcase FILE_EA_ENCODING:\n\tcase FILE_EA_A_CHECKSUM:\n\tcase FILE_EA_E_CHECKSUM:\n\tcase FILE_EA_NAME:\n\tcase FILE_EA_FSTYPE:\n\tcase FILE_CTIME:\n\tcase FILE_MTIME:\n\tcase FILE_ATIME:\n\tcase FILE_GROUP:\n\tcase FILE_GID:\n\tcase FILE_USER:\n\tcase FILE_UID:\n\tcase FILE_INODE:\n\tcase FILE_DEVICE_MAJOR:\n\tcase FILE_DEVICE_MINOR:\n\tcase FILE_DEVICENO:\n\tcase FILE_MODE:\n\tcase FILE_TYPE:\n\tcase FILE_LINK:\n\tcase FILE_NAME:\n\tcase FILE_ACL_DEFAULT:\n\tcase FILE_ACL_ACCESS:\n\tcase FILE_ACL_APPLEEXTENDED:\n\tcase FILE_FLAGS_USER_NODUMP:\n\tcase FILE_FLAGS_USER_IMMUTABLE:\n\tcase FILE_FLAGS_USER_APPEND:\n\tcase FILE_FLAGS_USER_OPAQUE:\n\tcase FILE_FLAGS_USER_NOUNLINK:\n\tcase FILE_FLAGS_SYS_ARCHIVED:\n\tcase FILE_FLAGS_SYS_IMMUTABLE:\n\tcase FILE_FLAGS_SYS_APPEND:\n\tcase FILE_FLAGS_SYS_NOUNLINK:\n\tcase FILE_FLAGS_SYS_SNAPSHOT:\n\tcase FILE_EXT2_SecureDeletion:\n\tcase FILE_EXT2_Undelete:\n\tcase FILE_EXT2_Compress:\n\tcase FILE_EXT2_Synchronous:\n\tcase FILE_EXT2_Immutable:\n\tcase FILE_EXT2_AppendOnly:\n\tcase FILE_EXT2_NoDump:\n\tcase FILE_EXT2_NoAtime:\n\tcase FILE_EXT2_CompDirty:\n\tcase FILE_EXT2_CompBlock:\n\tcase FILE_EXT2_NoCompBlock:\n\tcase FILE_EXT2_CompError:\n\tcase FILE_EXT2_BTree:\n\tcase FILE_EXT2_HashIndexed:\n\tcase FILE_EXT2_iMagic:\n\tcase FILE_EXT2_Journaled:\n\tcase FILE_EXT2_NoTail:\n\tcase FILE_EXT2_DirSync:\n\tcase FILE_EXT2_TopDir:\n\tcase FILE_EXT2_Reserved:\n\tcase UNKNOWN:\n\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\t}\n\treturn (ARCHIVE_OK);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ChangeCurrentInputMethod(const InputMethodDescriptor& new_input_method) {\n     if (current_input_method_.id != new_input_method.id) {\n       previous_input_method_ = current_input_method_;\n       current_input_method_ = new_input_method;\n\n      if (!input_method::SetCurrentKeyboardLayoutByName(\n              current_input_method_.keyboard_layout)) {\n        LOG(ERROR) << \"Failed to change keyboard layout to \"\n                   << current_input_method_.keyboard_layout;\n      }\n\n      ObserverListBase<Observer>::Iterator it(observers_);\n      Observer* first_observer = it.GetNext();\n       if (first_observer) {\n         first_observer->PreferenceUpdateNeeded(this,\n                                                previous_input_method_,\n                                               current_input_method_);\n      }\n    }\n\n     const size_t num_active_input_methods = GetNumActiveInputMethods();\n    FOR_EACH_OBSERVER(Observer, observers_,\n                       InputMethodChanged(this,\n                                          current_input_method_,\n                                          num_active_input_methods));\n  }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "gss_wrap_aead (minor_status,\n               context_handle,\n               conf_req_flag,\n               qop_req,\n\t       input_assoc_buffer,\n\t       input_payload_buffer,\n               conf_state,\n               output_message_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\tinput_payload_buffer;\nint *\t\t\tconf_state;\ngss_buffer_t\t\toutput_message_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_mechanism\tmech;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_wrap_aead_args(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tinput_assoc_buffer, input_payload_buffer,\n\t\t\t\tconf_state, output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n      * call it.\n      */\n     ctx = (gss_union_ctx_id_t)context_handle;\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn (GSS_S_BAD_MECH);\n\n    return gssint_wrap_aead(mech, minor_status, ctx,\n\t\t\t    conf_req_flag, qop_req,\n\t\t\t    input_assoc_buffer, input_payload_buffer,\n\t\t\t    conf_state, output_message_buffer);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-415"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void BrowserPpapiHostImpl::OnThrottleStateChanged(PP_Instance instance,\n                                                  bool is_throttled) {\n  auto it = instance_map_.find(instance);\n  if (it != instance_map_.end()) {\n    it->second->is_throttled = is_throttled;\n    for (auto& observer : it->second->observer_list)\n      observer.OnThrottleStateChanged(is_throttled);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ScopedRenderbufferBindingReset::ScopedRenderbufferBindingReset(gl::GLApi* api)\n    : api_(api), renderbuffer_(0) {\n  api_->glGetIntegervFn(GL_RENDERBUFFER_BINDING, &renderbuffer_);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-416"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t GraphicBuffer::unflatten(\n void const*& buffer, size_t& size, int const*& fds, size_t& count) {\n if (size < 8*sizeof(int)) return NO_MEMORY;\n\n int const* buf = static_cast<int const*>(buffer);\n if (buf[0] != 'GBFR') return BAD_TYPE;\n\n\n     const size_t numFds  = buf[8];\n     const size_t numInts = buf[9];\n \n     const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n     if (size < sizeNeeded) return NO_MEMORY;\n \n    size_t fdCountNeeded = 0;\n     if (count < fdCountNeeded) return NO_MEMORY;\n \n     if (handle) {\n        free_handle();\n }\n\n if (numFds || numInts) {\n        width  = buf[1];\n        height = buf[2];\n        stride = buf[3];\n\n         format = buf[4];\n         usage  = buf[5];\n         native_handle* h = native_handle_create(numFds, numInts);\n         memcpy(h->data,          fds,     numFds*sizeof(int));\n         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n         handle = h;\n } else {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n }\n\n    mId = static_cast<uint64_t>(buf[6]) << 32;\n    mId |= static_cast<uint32_t>(buf[7]);\n\n    mOwner = ownHandle;\n\n if (handle != 0) {\n status_t err = mBufferMapper.registerBuffer(handle);\n if (err != NO_ERROR) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: registerBuffer failed: %s (%d)\",\n                    strerror(-err), err);\n return err;\n }\n }\n\n    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);\n    size -= sizeNeeded;\n    fds += numFds;\n    count -= numFds;\n\n return NO_ERROR;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap, size_t align, int *flags)\n {\n\tElf32_Nhdr nh32;\n\tElf64_Nhdr nh64;\n\tsize_t noff, doff;\n#ifdef ELFCORE\n\tint os_style = -1;\n#endif\n\tuint32_t namesz, descsz;\n\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n\tchar sbuf[512];\n\tif (xnh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xnh_sizeof + offset;\n\t}\n\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n\toffset += xnh_sizeof;\n\tnamesz = xnh_namesz;\n\tdescsz = xnh_descsz;\n\tif ((namesz == 0) && (descsz == 0)) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\tif (namesz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note name size 0x%lx\",\n\t\t(unsigned long)namesz);\n\t    return 0;\n\t}\n\tif (descsz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note description size 0x%lx\",\n\t\t(unsigned long)descsz);\n\t    return 0;\n\t}\n\tnoff = offset;\n\tdoff = ELF_ALIGN(offset + namesz);\n\tif (offset + namesz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn doff;\n\t}\n\toffset = ELF_ALIGN(doff + descsz);\n\tif (doff + descsz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n \t}\n \n\tif ((*flags & (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID)) ==\n\t    (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID))\n\t\tgoto core;\n \tif (namesz == 5 && strcmp((char *)&nbuf[noff], \"SuSE\") == 0 &&\n\t    xnh_type == NT_GNU_VERSION && descsz == 2) {\n \t    file_printf(ms, \", for SuSE %d.%d\", nbuf[doff], nbuf[doff + 1]);\n \t}\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    xnh_type == NT_GNU_VERSION && descsz == 16) {\n \t\tuint32_t desc[4];\n \t\t(void)memcpy(desc, &nbuf[doff], sizeof(desc));\n \n \t\tif (file_printf(ms, \", for GNU/\") == -1)\n\t\t\treturn size;\n \t\tswitch (elf_getu32(swap, desc[0])) {\n \t\tcase GNU_OS_LINUX:\n \t\t\tif (file_printf(ms, \"Linux\") == -1)\n\t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase GNU_OS_HURD:\n \t\t\tif (file_printf(ms, \"Hurd\") == -1)\n\t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase GNU_OS_SOLARIS:\n \t\t\tif (file_printf(ms, \"Solaris\") == -1)\n\t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase GNU_OS_KFREEBSD:\n \t\t\tif (file_printf(ms, \"kFreeBSD\") == -1)\n\t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase GNU_OS_KNETBSD:\n \t\t\tif (file_printf(ms, \"kNetBSD\") == -1)\n\t\t\t\treturn size;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tif (file_printf(ms, \"<unknown>\") == -1)\n\t\t\t\treturn size; \n \t\t}\n \t\tif (file_printf(ms, \" %d.%d.%d\", elf_getu32(swap, desc[1]),\n \t\t    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)\n\t\t\treturn size;\n\t\t*flags |= FLAGS_DID_NOTE;\n\t\treturn size;\n \t}\n \n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    xnh_type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {\n\t    uint8_t desc[20];\n\t    uint32_t i;\n\t    if (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5/uuid\" :\n\t\t\"sha1\") == -1)\n\t\t    return size;\n\t    (void)memcpy(desc, &nbuf[doff], descsz);\n\t    for (i = 0; i < descsz; i++)\n\t\tif (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t    return size;\n\t    *flags |= FLAGS_DID_BUILD_ID;\n \t}\n \n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&\n\t    xnh_type == NT_NETBSD_PAX && descsz == 4) {\n \t\tstatic const char *pax[] = {\n \t\t    \"+mprotect\",\n \t\t    \"-mprotect\",\n\t\t    \"+segvguard\",\n\t\t    \"-segvguard\",\n\t\t    \"+ASLR\",\n\t\t    \"-ASLR\",\n\t\t};\n\t\tuint32_t desc;\n \t\tsize_t i;\n \t\tint did = 0;\n \n \t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n \t\tdesc = elf_getu32(swap, desc);\n \n \t\tif (desc && file_printf(ms, \", PaX: \") == -1)\n\t\t\treturn size;\n \n \t\tfor (i = 0; i < __arraycount(pax); i++) {\n \t\t\tif (((1 << i) & desc) == 0)\n \t\t\t\tcontinue;\n \t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",\n \t\t\t    pax[i]) == -1)\n\t\t\t\treturn size;\n\t\t}\n\t}\n\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n\t\tswitch (xnh_type) {\n\t\tcase NT_NETBSD_VERSION:\n\t\t\tif (descsz == 4) {\n\t\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n\t\t\t\t*flags |= FLAGS_DID_NOTE;\n\t\t\t\treturn size;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NT_NETBSD_MARCH:\n\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n\t\t\t    (const char *)&nbuf[doff]) == -1)\n\t\t\t\treturn size;\n\t\t\tbreak;\n\t\tcase NT_NETBSD_CMODEL:\n\t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n\t\t\t\treturn size;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n\t\t\t\treturn size;\n\t\t\tbreak;\n\t\t}\n\t\treturn size;\n\t}\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n\t    \tif (xnh_type == NT_FREEBSD_VERSION && descsz == 4) {\n\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n\t\t\t*flags |= FLAGS_DID_NOTE;\n\t\t\treturn size;\n \t\t}\n \t}\n \n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n\t    xnh_type == NT_OPENBSD_VERSION && descsz == 4) {\n\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n\t\t\treturn size;\n\t\t/* Content of note is always 0 */\n\t\t*flags |= FLAGS_DID_NOTE;\n\t\treturn size;\n\t}\n\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n\t    xnh_type == NT_DRAGONFLY_VERSION && descsz == 4) {\n\t\tuint32_t desc;\n\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n\t\t\treturn size;\n\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\t\tif (file_printf(ms, \" %d.%d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10, desc % 10000) == -1)\n\t\t\treturn size;\n\t\t*flags |= FLAGS_DID_NOTE;\n\t\treturn size;\n\t}\ncore:\n \t/*\n \t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n \t * least, doesn't correctly implement name\n\t * sections, in core dumps, as specified by\n\t * the \"Program Linking\" section of \"UNIX(R) System\n\t * V Release 4 Programmer's Guide: ANSI C and\n\t * Programming Support Tools\", because my copy\n\t * clearly says \"The first 'namesz' bytes in 'name'\n\t * contain a *null-terminated* [emphasis mine]\n\t * character representation of the entry's owner\n\t * or originator\", but the 2.0.36 kernel code\n\t * doesn't include the terminating null in the\n\t * name....\n\t */\n\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||\n\t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {\n\t\tos_style = OS_STYLE_SVR4;\n\t} \n\n\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {\n\t\tos_style = OS_STYLE_FREEBSD;\n\t}\n\n\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)\n\t    == 0)) {\n \t\tos_style = OS_STYLE_NETBSD;\n \t}\n \n#ifdef ELFCORE\n\tif ((*flags & FLAGS_DID_CORE) != 0)\n\t\treturn size;\n \tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n \t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n \t\t    == -1)\n\t\t\treturn size;\n \t\t*flags |= FLAGS_DID_CORE_STYLE;\n \t}\n \n \tswitch (os_style) {\n \tcase OS_STYLE_NETBSD:\n\t\tif (xnh_type == NT_NETBSD_CORE_PROCINFO) {\n \t\t\tuint32_t signo;\n \t\t\t/*\n \t\t\t * Extract the program name.  It is at\n\t\t\t * offset 0x7c, and is up to 32-bytes,\n\t\t\t * including the terminating NUL.\n\t\t\t */\n \t\t\tif (file_printf(ms, \", from '%.31s'\",\n \t\t\t    file_printable(sbuf, sizeof(sbuf),\n \t\t\t    (const char *)&nbuf[doff + 0x7c])) == -1)\n\t\t\t\treturn size;\n \t\t\t\n \t\t\t/*\n \t\t\t * Extract the signal number.  It is at\n\t\t\t * offset 0x08.\n\t\t\t */\n\t\t\t(void)memcpy(&signo, &nbuf[doff + 0x08],\n \t\t\t    sizeof(signo));\n \t\t\tif (file_printf(ms, \" (signal %u)\",\n \t\t\t    elf_getu32(swap, signo)) == -1)\n\t\t\t\treturn size;\n \t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\treturn size;\n \t\t}\n \t\tbreak;\n \n \tdefault:\n\t\tif (xnh_type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n \t\t\tsize_t i, j;\n \t\t\tunsigned char c;\n \t\t\t/*\n\t\t\t * Extract the program name.  We assume\n\t\t\t * it to be 16 characters (that's what it\n\t\t\t * is in SunOS 5.x and Linux).\n\t\t\t *\n\t\t\t * Unfortunately, it's at a different offset\n\t\t\t * in various OSes, so try multiple offsets.\n\t\t\t * If the characters aren't all printable,\n\t\t\t * reject it.\n\t\t\t */\n\t\t\tfor (i = 0; i < NOFFSETS; i++) {\n\t\t\t\tunsigned char *cname, *cp;\n\t\t\t\tsize_t reloffset = prpsoffsets(i);\n\t\t\t\tsize_t noffset = doff + reloffset;\n\t\t\t\tsize_t k;\n\t\t\t\tfor (j = 0; j < 16; j++, noffset++,\n\t\t\t\t    reloffset++) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the buffer; if\n\t\t\t\t\t * we are, just give up.\n\t\t\t\t\t */\n\t\t\t\t\tif (noffset >= size)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the contents;\n\t\t\t\t\t * if we are, this obviously\n\t\t\t\t\t * isn't the right offset.\n\t\t\t\t\t */\n\t\t\t\t\tif (reloffset >= descsz)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tc = nbuf[noffset];\n\t\t\t\t\tif (c == '\\0') {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A '\\0' at the\n\t\t\t\t\t\t * beginning is\n\t\t\t\t\t\t * obviously wrong.\n\t\t\t\t\t\t * Any other '\\0'\n\t\t\t\t\t\t * means we're done.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A nonprintable\n\t\t\t\t\t\t * character is also\n\t\t\t\t\t\t * wrong.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!isprint(c) || isquote(c))\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Well, that worked.\n\t\t\t\t */\n\n\t\t\t\t/*\n \t\t\t\t * Try next offsets, in case this match is\n \t\t\t\t * in the middle of a string.\n \t\t\t\t */\n\t\t\t\tfor (k = i + 1 ; k < NOFFSETS ; k++) {\n \t\t\t\t\tsize_t no;\n \t\t\t\t\tint adjust = 1;\n \t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (no = doff + prpsoffsets(k);\n\t\t\t\t\t     no < doff + prpsoffsets(i); no++)\n\t\t\t\t\t\tadjust = adjust\n\t\t\t\t\t\t         && isprint(nbuf[no]);\n\t\t\t\t\tif (adjust)\n\t\t\t\t\t\ti = k;\n\t\t\t\t}\n\n\t\t\t\tcname = (unsigned char *)\n\t\t\t\t    &nbuf[doff + prpsoffsets(i)];\n\t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Linux apparently appends a space at the end\n\t\t\t\t * of the command line: remove it.\n\t\t\t\t */\n\t\t\t\twhile (cp > cname && isspace(cp[-1]))\n \t\t\t\t\tcp--;\n \t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n \t\t\t\t    (int)(cp - cname), cname) == -1)\n\t\t\t\t\treturn size;\n \t\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\t\treturn size;\n \n \t\t\ttryanother:\n \t\t\t\t;\n\t\t\t}\n\t\t}\n \t\tbreak;\n \t}\n #endif\n \treturn offset;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n   entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n   entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n   entry->magick=(IsImageFormatHandler *) IsMPC;\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "futex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tstruct plist_head *head;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\tspin_lock(&hb->lock);\n\thead = &hb->chain;\n\n\tplist_for_each_entry_safe(this, next, head, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if one of the bits is set in both bitsets */\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\twake_futex(this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void op32_set_current_rxslot(struct b43_dmaring *ring, int slot)\n{\n\tb43_dma_write(ring, B43_DMA32_RXINDEX,\n\t\t      (u32) (slot * sizeof(struct b43_dmadesc32)));\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,&image->exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType);\n        (void) SetImageDepth(image,1);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass);\n        (void) SetImageDepth(image,8);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            CoderError,\"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,&image->exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass);\n              (void) SetImageDepth(image,8);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorMatteType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,&image->exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) && (image->matte == MagickFalse))\n                  SetImageMonochrome(image,&image->exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->matte != MagickFalse)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            if (image->colorspace == YCbCrColorspace)\n              {\n                const char\n                  *sampling_factor;\n\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                sampling_factor=(const char *) NULL;\n                value=GetImageProperty(image,\"jpeg:sampling-factor\");\n                if (value != (char *) NULL)\n                  {\n                    sampling_factor=value;\n                    if (image->debug != MagickFalse)\n                      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"  Input sampling-factors=%s\",sampling_factor);\n                  }\n                if (image_info->sampling_factor != (char *) NULL)\n                  sampling_factor=image_info->sampling_factor;\n                if (sampling_factor != (const char *) NULL)\n                  {\n                    flags=ParseGeometry(sampling_factor,&geometry_info);\n                    if ((flags & SigmaValue) == 0)\n                      geometry_info.sigma=geometry_info.rho;\n                    (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                      geometry_info.rho,(uint16) geometry_info.sigma);\n                  }\n            }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->x_resolution);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->y_resolution);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(&image->exception,GetMagickModule(),\n            CoderError,\"TIFF: negative image positions unsupported\",\"%s\",\n            image->filename);\n        if ((image->page.x > 0) && (image->x_resolution > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->x_resolution);\n          }\n        if ((image->page.y > 0) && (image->y_resolution > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->y_resolution);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=GetQuantumPixels(quantum_info);\n    tiff_info.scanline=GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->matte != MagickFalse)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,quantum_type,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,RedQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,GreenQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const PixelPacket\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,BlueQuantum,pixels,&image->exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->matte != MagickFalse)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const PixelPacket\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,\n                  &image->exception);\n                if (p == (const PixelPacket *) NULL)\n                  break;\n                (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,&image->exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->matte != MagickFalse)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->matte != MagickFalse)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          (void) ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,&image->exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void InsertNoBarrier() {\n  Object* obj = Object::Create();\n  Container container;\n  {\n    ExpectNoWriteBarrierFires scope(ThreadState::Current(), {obj});\n    container.insert(obj);\n  }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static pfunc stream_token(struct jv_parser* p, char ch) {\n  jv_kind k;\n  jv last;\n\n  switch (ch) {\n  case '[':\n    if (jv_is_valid(p->next))\n      return \"Expected a separator between values\";\n    p->path = jv_array_append(p->path, jv_number(0)); // push\n    p->last_seen = JV_LAST_OPEN_ARRAY;\n    p->stacklen++;\n    break;\n\n  case '{':\n    if (p->last_seen == JV_LAST_VALUE)\n      return \"Expected a separator between values\";\n    p->path = jv_array_append(p->path, jv_null()); // push\n    p->last_seen = JV_LAST_OPEN_OBJECT;\n    p->stacklen++;\n    break;\n\n  case ':':\n    if (p->stacklen == 0 || jv_get_kind(jv_array_get(jv_copy(p->path), p->stacklen - 1)) == JV_KIND_NUMBER)\n      return \"':' not as part of an object\";\n    if (!jv_is_valid(p->next) || p->last_seen == JV_LAST_NONE)\n      return \"Expected string key before ':'\";\n    if (jv_get_kind(p->next) != JV_KIND_STRING)\n      return \"Object keys must be strings\";\n    if (p->last_seen != JV_LAST_VALUE)\n      return \"':' should follow a key\";\n    p->last_seen = JV_LAST_COLON;\n    p->path = jv_array_set(p->path, p->stacklen - 1, p->next);\n    p->next = jv_invalid();\n    break;\n\n  case ',':\n    if (p->last_seen != JV_LAST_VALUE)\n      return \"Expected value before ','\";\n    if (p->stacklen == 0)\n      return \"',' not as part of an object or array\";\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    if (k == JV_KIND_NUMBER) {\n      int idx = jv_number_value(last);\n\n      if (jv_is_valid(p->next)) {\n        p->output = JV_ARRAY(jv_copy(p->path), p->next);\n        p->next = jv_invalid();\n      }\n      p->path = jv_array_set(p->path, p->stacklen - 1, jv_number(idx + 1));\n      p->last_seen = JV_LAST_COMMA;\n    } else if (k == JV_KIND_STRING) {\n      if (jv_is_valid(p->next)) {\n        p->output = JV_ARRAY(jv_copy(p->path), p->next);\n        p->next = jv_invalid();\n      }\n      p->path = jv_array_set(p->path, p->stacklen - 1, jv_true()); // ready for another name:value pair\n      p->last_seen = JV_LAST_COMMA;\n    } else {\n      assert(k == JV_KIND_NULL);\n      jv_free(last);\n      return \"Objects must consist of key:value pairs\";\n    }\n    jv_free(last);\n    break;\n\n  case ']':\n    if (p->stacklen == 0)\n      return \"Unmatched ']' at the top-level\";\n    if (p->last_seen == JV_LAST_COMMA)\n      return \"Expected another array element\";\n    if (p->last_seen == JV_LAST_OPEN_ARRAY)\n      assert(!jv_is_valid(p->next));\n\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    jv_free(last);\n\n    if (k != JV_KIND_NUMBER)\n      return \"Unmatched ']' in the middle of an object\";\n    if (jv_is_valid(p->next)) {\n      p->output = JV_ARRAY(jv_copy(p->path), p->next, jv_true());\n      p->next = jv_invalid();\n    } else if (p->last_seen != JV_LAST_OPEN_ARRAY) {\n      p->output = JV_ARRAY(jv_copy(p->path));\n    }\n\n    p->path = jv_array_slice(p->path, 0, --(p->stacklen)); // pop\n    jv_free(p->next);\n    p->next = jv_invalid();\n\n    if (p->last_seen == JV_LAST_OPEN_ARRAY)\n      p->output = JV_ARRAY(jv_copy(p->path), jv_array()); // Empty arrays are leaves\n\n    if (p->stacklen == 0)\n      p->last_seen = JV_LAST_NONE;\n    else\n      p->last_seen = JV_LAST_VALUE;\n    break;\n\n  case '}':\n    if (p->stacklen == 0)\n      return \"Unmatched '}' at the top-level\";\n    if (p->last_seen == JV_LAST_COMMA)\n      return \"Expected another key:value pair\";\n    if (p->last_seen == JV_LAST_OPEN_OBJECT)\n      assert(!jv_is_valid(p->next));\n\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    jv_free(last);\n    if (k == JV_KIND_NUMBER)\n      return \"Unmatched '}' in the middle of an array\";"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void InfoBarCountObserver::CheckCount() {\n  InfoBarTabHelper* infobar_tab_helper =\n      InfoBarTabHelper::FromWebContents(tab_contents_->web_contents());\n  if (infobar_tab_helper->GetInfoBarCount() != target_count_)\n    return;\n\n  if (automation_) {\n    AutomationMsg_WaitForInfoBarCount::WriteReplyParams(reply_message_.get(),\n                                                        true);\n    automation_->Send(reply_message_.release());\n  }\n  delete this;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\tdprint(DBG_CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n \terr = hfs_brec_find(&src_fd);\n \tif (err)\n \t\tgoto out;\n \n \thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n \t\t\t\tsrc_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfsplus_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "gpgsm_release (void *engine)\n{\n  engine_gpgsm_t gpgsm = engine;\n\n  if (!gpgsm)\n    return;\n\n  gpgsm_cancel (engine);\n\n  free (gpgsm->colon.attic.line);\n  free (gpgsm);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "selftest_sign_2048 (gcry_sexp_t pkey, gcry_sexp_t skey)\n{\n  static const char sample_data[] =\n    \"(data (flags pkcs1)\"\n    \" (hash sha256 #11223344556677889900aabbccddeeff\"\n    /**/           \"102030405060708090a0b0c0d0f01121#))\";\n  static const char sample_data_bad[] =\n    \"(data (flags pkcs1)\"\n    \" (hash sha256 #11223344556677889900aabbccddeeff\"\n    /**/           \"802030405060708090a0b0c0d0f01121#))\";\n\n  const char *errtxt = NULL;\n  gcry_error_t err;\n  gcry_sexp_t data = NULL;\n  gcry_sexp_t data_bad = NULL;\n  gcry_sexp_t sig = NULL;\n  /* raw signature data reference */\n  const char ref_data[] =\n    \"6252a19a11e1d5155ed9376036277193d644fa239397fff03e9b92d6f86415d6\"\n    \"d30da9273775f290e580d038295ff8ff89522becccfa6ae870bf76b76df402a8\"\n    \"54f69347e3db3de8e1e7d4dada281ec556810c7a8ecd0b5f51f9b1c0e7aa7557\"\n    \"61aa2b8ba5f811304acc6af0eca41fe49baf33bf34eddaf44e21e036ac7f0b68\"\n    \"03cdef1c60021fb7b5b97ebacdd88ab755ce29af568dbc5728cc6e6eff42618d\"\n    \"62a0386ca8beed46402bdeeef29b6a3feded906bace411a06a39192bf516ae10\"\n    \"67e4320fa8ea113968525f4574d022a3ceeaafdc41079efe1f22cc94bf59d8d3\"\n    \"328085da9674857db56de5978a62394aab48aa3b72e23a1b16260cfd9daafe65\";\n  gcry_mpi_t ref_mpi = NULL;\n  gcry_mpi_t sig_mpi = NULL;\n\n  err = sexp_sscan (&data, NULL, sample_data, strlen (sample_data));\n  if (!err)\n    err = sexp_sscan (&data_bad, NULL,\n                      sample_data_bad, strlen (sample_data_bad));\n  if (err)\n    {\n      errtxt = \"converting data failed\";\n      goto leave;\n    }\n\n  err = _gcry_pk_sign (&sig, data, skey);\n  if (err)\n    {\n      errtxt = \"signing failed\";\n      goto leave;\n    }\n\n  err = _gcry_mpi_scan(&ref_mpi, GCRYMPI_FMT_HEX, ref_data, 0, NULL);\n  if (err)\n    {\n      errtxt = \"converting ref_data to mpi failed\";\n      goto leave;\n    }\n\n  err = _gcry_sexp_extract_param(sig, \"sig-val!rsa\", \"s\", &sig_mpi, NULL);\n  if (err)\n    {\n      errtxt = \"extracting signature data failed\";\n      goto leave;\n    }\n\n  if (mpi_cmp (sig_mpi, ref_mpi))\n    {\n      errtxt = \"signature does not match reference data\";\n      goto leave;\n    }\n\n  err = _gcry_pk_verify (sig, data, pkey);\n  if (err)\n    {\n      errtxt = \"verify failed\";\n      goto leave;\n    }\n  err = _gcry_pk_verify (sig, data_bad, pkey);\n  if (gcry_err_code (err) != GPG_ERR_BAD_SIGNATURE)\n    {\n      errtxt = \"bad signature not detected\";\n      goto leave;\n    }\n\n\n leave:\n  sexp_release (sig);\n  sexp_release (data_bad);\n  sexp_release (data);\n  _gcry_mpi_release (ref_mpi);\n  _gcry_mpi_release (sig_mpi);\n  return errtxt;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-310"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(PrintPreviewMessageHandler, message,\n                                   render_frame_host)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_RequestPrintPreview,\n                        OnRequestPrintPreview)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n  if (handled)\n    return true;\n\n  handled = true;\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n                        OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,\n                        OnPrintPreviewFailed)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetDefaultPageLayout,\n                        OnDidGetDefaultPageLayout)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewCancelled,\n                        OnPrintPreviewCancelled)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewInvalidPrinterSettings,\n                        OnInvalidPrinterSettings)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_SetOptionsFromDocument,\n                        OnSetOptionsFromDocument)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n  return handled;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void DocumentVisibilityObserver::registerObserver(Document& document)\n{\n    ASSERT(!m_document);\n    m_document = &document;\n    if (m_document)\n        m_document->registerVisibilityObserver(this);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "double HTMLMediaElement::officialPlaybackPosition() const {\n  bool waitingForData = m_readyState <= kHaveCurrentData;\n  if (m_officialPlaybackPositionNeedsUpdate && !m_paused && !waitingForData) {\n    setOfficialPlaybackPosition(currentPlaybackPosition());\n  }\n\n#if LOG_OFFICIAL_TIME_STATUS\n  static const double minCachedDeltaForWarning = 0.01;\n  double delta =\n      std::abs(m_officialPlaybackPosition - currentPlaybackPosition());\n  if (delta > minCachedDeltaForWarning) {\n    BLINK_MEDIA_LOG << \"currentTime(\" << (void*)this\n                    << \") - WARNING, cached time is \" << delta\n                    << \"seconds off of media time when paused/waiting\";\n  }\n#endif\n\n  return m_officialPlaybackPosition;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void pid_from_ns(int sock, pid_t tpid)\n{\n\tpid_t vpid;\n\tstruct ucred cred;\n\tchar v;\n\tstruct timeval tv;\n\tfd_set s;\n\tint ret;\n\n\tcred.uid = 0;\n\tcred.gid = 0;\n\twhile (1) {\n\t\tFD_ZERO(&s);\n\t\tFD_SET(sock, &s);\n\t\ttv.tv_sec = 2;\n\t\ttv.tv_usec = 0;\n\t\tret = select(sock+1, &s, NULL, NULL, &tv);\n\t\tif (ret <= 0) {\n\t\t\tfprintf(stderr, \"%s: bad select before read from parent: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif ((ret = read(sock, &vpid, sizeof(pid_t))) != sizeof(pid_t)) {\n\t\t\tfprintf(stderr, \"%s: bad read from parent: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (vpid == -1) // done\n\t\t\tbreak;\n\t\tv = '0';\n\t\tcred.pid = vpid;\n\t\tif (send_creds(sock, &cred, v, true) != SEND_CREDS_OK) {\n\t\t\tv = '1';\n\t\t\tcred.pid = getpid();\n\t\t\tif (send_creds(sock, &cred, v, false) != SEND_CREDS_OK)\n\t\t\t\t_exit(1);\n\t\t}\n\t}\n\t_exit(0);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n \t}\n \tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n \t    tu->last_resolution != resolution) {\n \t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n \t\tr1.tstamp = tstamp;\n \t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void ieee80211_sta_eosp(struct ieee80211_sta *pubsta)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_local *local = sta->local;\n\n\ttrace_api_eosp(local, pubsta);\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-362"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "ieee802_15_4_if_print(netdissect_options *ndo,\n                       const struct pcap_pkthdr *h, const u_char *p)\n {\n \tu_int caplen = h->caplen;\n\tint hdrlen;\n \tuint16_t fc;\n \tuint8_t seq;\n \n \tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4] %x\", caplen));\n \t\treturn caplen;\n \t}\n \n \tfc = EXTRACT_LE_16BITS(p);\n\thdrlen = extract_header_length(fc);\n \tseq = EXTRACT_LE_8BITS(p + 2);\n \n \tp += 3;\n \tcaplen -= 3;\n \n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[fc & 0x7]));\n \tif (ndo->ndo_vflag)\n \t\tND_PRINT((ndo,\"seq %02x \", seq));\n\tif (hdrlen == -1) {\n\t\tND_PRINT((ndo,\"invalid! \"));\n\t\treturn caplen;\n\t}\n\tif (!ndo->ndo_vflag) {\n\t\tp+= hdrlen;\n\t\tcaplen -= hdrlen;\n\t} else {\n\t\tuint16_t panid = 0;\n \n\t\tswitch ((fc >> 10) & 0x3) {\n\t\tcase 0x00:\n \t\t\tND_PRINT((ndo,\"none \"));\n\t\t\tbreak;\n\t\tcase 0x01:\n \t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\t\treturn 0;\n\t\tcase 0x02:\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\t\tp += 8;\n\t\t\tbreak;\n \t\t}\n \t\tND_PRINT((ndo,\"< \"));\n \n\t\tswitch ((fc >> 14) & 0x3) {\n\t\tcase 0x00:\n \t\t\tND_PRINT((ndo,\"none \"));\n\t\t\tbreak;\n\t\tcase 0x01:\n \t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\t\treturn 0;\n\t\tcase 0x02:\n\t\t\tif (!(fc & (1 << 6))) {\n\t\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\t\tp += 2;\n \t\t\t}\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n \t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tif (!(fc & (1 << 6))) {\n\t\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\t\tp += 2;\n \t\t\t}\n                        ND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\t\tp += 8;\n\t\t\tbreak;\n \t\t}\n\t\tcaplen -= hdrlen;\n \t}\n \n \tif (!ndo->ndo_suppress_default_print)\n \t\tND_DEFAULTPRINT(p, caplen);\n \n\treturn 0;\n }"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static void calc_timer_values(struct perf_event *event,\n\t\t\t\tu64 *now,\n\t\t\t\tu64 *enabled,\n\t\t\t\tu64 *running)\n{\n\tu64 ctx_time;\n\n\t*now = perf_clock();\n\tctx_time = event->shadow_ctx_time + *now;\n\t*enabled = ctx_time - event->tstamp_enabled;\n\t*running = ctx_time - event->tstamp_running;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "PHP_FUNCTION(curl_unescape)\n{\n\tchar       *str = NULL, *out = NULL;\n\tsize_t     str_len = 0;\n\tint        out_len;\n\tzval       *zid;\n\tphp_curl   *ch;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((ch = (php_curl*)zend_fetch_resource(Z_RES_P(zid), le_curl_name, le_curl)) == NULL) {\n \t\tRETURN_FALSE;\n \t}\n \n\tif (str_len > INT_MAX) {\n \t\tRETURN_FALSE;\n \t}\n \n\tif ((out = curl_easy_unescape(ch->cp, str, str_len, &out_len))) {\n\t\tRETVAL_STRINGL(out, out_len);\n\t\tcurl_free(out);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "int yr_re_fast_exec(\n    uint8_t* code,\n    uint8_t* input_data,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args,\n    int* matches)\n{\n  RE_REPEAT_ANY_ARGS* repeat_any_args;\n\n  uint8_t* code_stack[MAX_FAST_RE_STACK];\n  uint8_t* input_stack[MAX_FAST_RE_STACK];\n  int matches_stack[MAX_FAST_RE_STACK];\n\n  uint8_t* ip = code;\n  uint8_t* input = input_data;\n  uint8_t* next_input;\n  uint8_t* next_opcode;\n  uint8_t mask;\n  uint8_t value;\n\n  int i;\n  int stop;\n  int input_incr;\n  int sp = 0;\n  int bytes_matched;\n  int max_bytes_matched;\n\n  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?\n      (int) input_backwards_size :\n      (int) input_forwards_size;\n\n  input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n    input--;\n\n  code_stack[sp] = code;\n  input_stack[sp] = input;\n  matches_stack[sp] = 0;\n  sp++;\n\n  while (sp > 0)\n  {\n    sp--;\n    ip = code_stack[sp];\n    input = input_stack[sp];\n    bytes_matched = matches_stack[sp];\n    stop = FALSE;\n\n    while(!stop)\n    {\n      if (*ip == RE_OPCODE_MATCH)\n      {\n        if (flags & RE_FLAGS_EXHAUSTIVE)\n        {\n          FAIL_ON_ERROR(callback(\n             flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,\n             bytes_matched,\n             flags,\n             callback_args));\n\n          break;\n        }\n        else\n        {\n          if (matches != NULL)\n            *matches = bytes_matched;\n\n          return ERROR_SUCCESS;\n        }\n      }\n\n      if (bytes_matched >= max_bytes_matched)\n        break;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_LITERAL:\n\n          if (*input == *(ip + 1))\n          {\n            bytes_matched++;\n            input += input_incr;\n            ip += 2;\n          }\n          else\n          {\n            stop = TRUE;\n          }\n\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          if ((*input & mask) == value)\n          {\n            bytes_matched++;\n            input += input_incr;\n            ip += 3;\n          }\n          else\n          {\n            stop = TRUE;\n          }\n\n          break;\n\n        case RE_OPCODE_ANY:\n\n          bytes_matched++;\n          input += input_incr;\n          ip += 1;\n\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n\n          repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);\n          next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);\n \n           for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)\n           {\n            next_input = input + i * input_incr;\n             if (bytes_matched + i >= max_bytes_matched)\n               break;\n \n             if ( *(next_opcode) != RE_OPCODE_LITERAL ||\n                 (*(next_opcode) == RE_OPCODE_LITERAL &&\n                  *(next_opcode + 1) == *next_input))\n            {\n              if (sp >= MAX_FAST_RE_STACK)\n                return -4;\n\n              code_stack[sp] = next_opcode;\n              input_stack[sp] = next_input;\n              matches_stack[sp] = bytes_matched + i;\n              sp++;\n            }\n          }\n \n           input += input_incr * repeat_any_args->min;\n           bytes_matched += repeat_any_args->min;\n           ip = next_opcode;\n \n           break;\n\n        default:\n          assert(FALSE);\n      }\n    }\n  }\n\n  if (matches != NULL)\n    *matches = -1;\n\n  return ERROR_SUCCESS;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool Element::rareDataChildrenAffectedByHover() const\n{\n    ASSERT(hasRareData());\n    return elementRareData()->childrenAffectedByHover();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-399"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "AuthenticatorBlePowerOnManualSheetModel::GetStepIllustration(\n    ImageColorScheme color_scheme) const {\n  return color_scheme == ImageColorScheme::kDark\n             ? kWebauthnErrorBluetoothDarkIcon\n             : kWebauthnErrorBluetoothIcon;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "bool IsBackgroundSuspendEnabled(WebMediaPlayerDelegate* delegate) {\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDisableMediaSuspend))\n    return false;\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableMediaSuspend))\n    return true;\n\n  return delegate->IsBackgroundMediaSuspendEnabled();\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-732"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\t     struct prefix_info *pinfo, u32 portid, u32 seq,\n\t\t\t     int event, unsigned int flags)\n{\n\tstruct prefixmsg *pmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct prefix_cacheinfo\tci;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tpmsg = nlmsg_data(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_pad1 = 0;\n\tpmsg->prefix_pad2 = 0;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\tpmsg->prefix_pad3 = 0;\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\n\tif (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))\n\t\tgoto nla_put_failure;\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tif (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void tty_ldisc_release(struct tty_struct *tty)\n{\n\tstruct tty_struct *o_tty = tty->link;\n\n\t/*\n\t * Shutdown this line discipline. As this is the final close,\n\t * it does not race with the set_ldisc code path.\n\t */\n\n\ttty_ldisc_lock_pair(tty, o_tty);\n\ttty_ldisc_kill(tty);\n\tif (o_tty)\n\t\ttty_ldisc_kill(o_tty);\n\ttty_ldisc_unlock_pair(tty, o_tty);\n\n\t/* And the memory resources remaining (buffers, termios) will be\n\t   disposed of when the kref hits zero */\n\n\ttty_ldisc_debug(tty, \"released\\n\");\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-200"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "void av_parser_close(AVCodecParserContext *s)\n{\n    if(s){\n        if (s->parser->parser_close)\n            s->parser->parser_close(s);\n        av_free(s->priv_data);\n        av_free(s);\n    }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "content::BrowserMainParts* ChromeContentBrowserClient::CreateBrowserMainParts(\n    const content::MainFunctionParams& parameters) {\n  ChromeBrowserMainParts* main_parts;\n#if defined(OS_WIN)\n  main_parts = new ChromeBrowserMainPartsWin(parameters);\n#elif defined(OS_MACOSX)\n  main_parts = new ChromeBrowserMainPartsMac(parameters);\n#elif defined(OS_CHROMEOS)\n  main_parts = new chromeos::ChromeBrowserMainPartsChromeos(parameters);\n#elif defined(OS_LINUX)\n  main_parts = new ChromeBrowserMainPartsLinux(parameters);\n#elif defined(OS_ANDROID)\n  main_parts = new ChromeBrowserMainPartsAndroid(parameters);\n#elif defined(OS_POSIX)\n  main_parts = new ChromeBrowserMainPartsPosix(parameters);\n#else\n  NOTREACHED();\n  main_parts = new ChromeBrowserMainParts(parameters);\n#endif\n\n#if defined(TOOLKIT_GTK)\n  chrome::AddGtkToolkitExtraParts(main_parts);\n#endif\n\n#if defined(TOOLKIT_VIEWS)\n  chrome::AddViewsToolkitExtraParts(main_parts);\n#endif\n\n#if defined(USE_ASH)\n  chrome::AddAshToolkitExtraParts(main_parts);\n#endif\n\n#if defined(USE_AURA)\n  chrome::AddAuraToolkitExtraParts(main_parts);\n#endif\n\n  return main_parts;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "EXPORTED int mboxlist_lookup(const char *name, mbentry_t **entryptr,\n                             struct txn **tid)\n{\n    mbentry_t *entry = NULL;\n    int r;\n\n    r = mboxlist_mylookup(name, &entry, tid, 0);\n\n    if (r) return r;\n\n    /* Ignore \"reserved\" entries, like they aren't there */\n    if (entry->mbtype & MBTYPE_RESERVE) {\n        mboxlist_entry_free(&entry);\n        return IMAP_MAILBOX_RESERVED;\n    }\n\n    /* Ignore \"deleted\" entries, like they aren't there */\n    if (entry->mbtype & MBTYPE_DELETED) {\n        mboxlist_entry_free(&entry);\n        return IMAP_MAILBOX_NONEXISTENT;\n    }\n\n    if (entryptr) *entryptr = entry;\n    else mboxlist_entry_free(&entry);\n\n    return 0;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n               IOBUF a, size_t *ret_len )\n {\n     int zrc;\n    int rc=0;\n     size_t n;\n     int nread, count;\n     int refill = !zs->avail_in;\n    if( DBG_FILTER )\n\tlog_debug(\"begin inflate: avail_in=%u, avail_out=%u, inbuf=%u\\n\",\n\t\t(unsigned)zs->avail_in, (unsigned)zs->avail_out,\n\t\t(unsigned)zfx->inbufsize );\n    do {\n\tif( zs->avail_in < zfx->inbufsize && refill ) {\n\t    n = zs->avail_in;\n\t    if( !n )\n            zs->next_in = BYTEF_CAST (zfx->inbuf);\n\t    count = zfx->inbufsize - n;\n\t    nread = iobuf_read( a, zfx->inbuf + n, count );\n            nread = iobuf_read( a, zfx->inbuf + n, count );\n            if( nread == -1 ) nread = 0;\n            n += nread;\n           /* If we use the undocumented feature to suppress\n            * the zlib header, we have to give inflate an\n            * extra dummy byte to read */\n           if( nread < count && zfx->algo == 1 ) {\n               *(zfx->inbuf + n) = 0xFF; /* is it really needed ? */\n               zfx->algo1hack = 1;\n                n++;\n            }\n            zs->avail_in = n;\n        }\n\t    log_debug(\"enter inflate: avail_in=%u, avail_out=%u\\n\",\n\t\t    (unsigned)zs->avail_in, (unsigned)zs->avail_out);\n\tzrc = inflate ( zs, Z_SYNC_FLUSH );\n\tif( DBG_FILTER )\n\t    log_debug(\"leave inflate: avail_in=%u, avail_out=%u, zrc=%d\\n\",\n\t\t   (unsigned)zs->avail_in, (unsigned)zs->avail_out, zrc);\n\tif( zrc == Z_STREAM_END )\n\t    rc = -1; /* eof */\n\telse if( zrc != Z_OK && zrc != Z_BUF_ERROR ) {\n\t    if( zs->msg )\n\t\tlog_fatal(\"zlib inflate problem: %s\\n\", zs->msg );\n\t    else\n\t\tlog_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n            else\n                log_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n        }\n    } while( zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR );\n \n     *ret_len = zfx->outbufsize - zs->avail_out;\n     if( DBG_FILTER )\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "user_path_parent(int dfd, const char __user *path,\n\t\t struct path *parent,\n\t\t struct qstr *last,\n\t\t int *type,\n\t\t unsigned int flags)\n{\n\t/* only LOOKUP_REVAL is allowed in extra flags */\n\treturn filename_parentat(dfd, getname(path), flags & LOOKUP_REVAL,\n\t\t\t\t parent, last, type);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-254"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,\n unsigned long arg)\n{\n unsigned long tmp;\n struct vm_area_struct * vma, *prev;\n int unmapped_error = 0;\n int error = -EINVAL;\n\n /*\n\t * If the interval [start,end) covers some unmapped address\n\t * ranges, just ignore them, but return -ENOMEM at the end.\n\t * - this matches the handling in madvise.\n\t */\n\tvma = find_vma_prev(current->mm, start, &prev);\n if (vma && start > vma->vm_start)\n\t\tprev = vma;\n\n for (;;) {\n /* Still start < end. */\n\t\terror = -ENOMEM;\n if (!vma)\n return error;\n\n /* Here start < (end|vma->vm_end). */\n if (start < vma->vm_start) {\n\t\t\tunmapped_error = -ENOMEM;\n\t\t\tstart = vma->vm_start;\n if (start >= end)\n return error;\n }\n\n /* Here vma->vm_start <= start < (end|vma->vm_end) */\n\t\ttmp = vma->vm_end;\n if (end < tmp)\n\n \t\t\ttmp = end;\n \n \t\t/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */\n\t\terror = prctl_update_vma_anon_name(vma, &prev, start, end,\n \t\t\t\t(const char __user *)arg);\n \t\tif (error)\n \t\t\treturn error;\n\t\tstart = tmp;\n if (prev && start < prev->vm_end)\n\t\t\tstart = prev->vm_end;\n\t\terror = unmapped_error;\n if (start >= end)\n return error;\n if (prev)\n\t\t\tvma = prev->vm_next;\n else /* madvise_remove dropped mmap_sem */\n\t\t\tvma = find_vma(current->mm, start);\n }\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-264"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "status_t MediaMetadataRetriever::setDataSource(int fd, int64_t offset, int64_t length)\n{\n    ALOGV(\"setDataSource(%d, %\" PRId64 \", %\" PRId64 \")\", fd, offset, length);\n Mutex::Autolock _l(mLock);\n if (mRetriever == 0) {\n        ALOGE(\"retriever is not initialized\");\n return INVALID_OPERATION;\n }\n if (fd < 0 || offset < 0 || length < 0) {\n        ALOGE(\"Invalid negative argument\");\n return UNKNOWN_ERROR;\n }\n return mRetriever->setDataSource(fd, offset, length);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "smb_errstr(int class, int num)\n{\n    static char ret[128];\n    int i, j;\n\n    ret[0] = 0;\n\n    for (i = 0; err_classes[i].class; i++)\n\tif (err_classes[i].code == class) {\n\t    if (err_classes[i].err_msgs) {\n\t\tconst err_code_struct *err = err_classes[i].err_msgs;\n\t\tfor (j = 0; err[j].name; j++)\n\t\t    if (num == err[j].code) {\n\t\t\tsnprintf(ret, sizeof(ret), \"%s - %s (%s)\",\n\t\t\t    err_classes[i].class, err[j].name, err[j].message);\n\t\t\treturn ret;\n\t\t    }\n\t    }\n\n\t    snprintf(ret, sizeof(ret), \"%s - %d\", err_classes[i].class, num);\n\t    return ret;\n\t}\n\n    snprintf(ret, sizeof(ret), \"ERROR: Unknown error (%d,%d)\", class, num);\n    return(ret);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-125"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "const SerializedResource* getResource(const char* url, const char* mimeType)\n    {\n        KURL kURL = KURL(m_baseUrl, url);\n        String mime(mimeType);\n        for (size_t i = 0; i < m_resources.size(); ++i) {\n            const SerializedResource& resource = m_resources[i];\n            if (resource.url == kURL && !resource.data->isEmpty()\n                && (mime.isNull() || equalIgnoringCase(resource.mimeType, mime)))\n                return &resource;\n        }\n        return nullptr;\n    }"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-20"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "static int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_channel *channel;\n\tint rc;\n\n\tnet_dev->watchdog_timeo = 5 * HZ;\n \tnet_dev->irq = efx->pci_dev->irq;\n \tnet_dev->netdev_ops = &efx_netdev_ops;\n \tSET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);\n \n \t/* Clear MAC statistics */\n \tefx->mac_op->update_stats(efx);\n\tmemset(&efx->mac_stats, 0, sizeof(efx->mac_stats));\n\n\trtnl_lock();\n\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tefx_update_name(efx);\n\n\trc = register_netdevice(net_dev);\n\tif (rc)\n\t\tgoto fail_locked;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tstruct efx_tx_queue *tx_queue;\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\tefx_init_tx_queue_core_txq(tx_queue);\n\t}\n\n\t/* Always start with carrier off; PHY events will detect the link */\n\tnetif_carrier_off(efx->net_dev);\n\n\trtnl_unlock();\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"failed to init net dev attributes\\n\");\n\t\tgoto fail_registered;\n\t}\n\n\treturn 0;\n\nfail_locked:\n\trtnl_unlock();\n\tnetif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");\n\treturn rc;\n\nfail_registered:\n\tunregister_netdev(net_dev);\n\treturn rc;\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 1\nCWE Number: CWE: CWE-189"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "android::SoftOMXComponent *createSoftOMXComponent(\n const char *name, const OMX_CALLBACKTYPE *callbacks,\n        OMX_PTR appData, OMX_COMPONENTTYPE **component) {\n return new android::SoftAMRWBEncoder(name, callbacks, appData, component);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
{"messages": [{"role": "system", "content": "You are an assistant that detects vulnerabilities in code and provides their CWE number. Out put 1 and CWE number if the code is vulnerable, 0 otherwise."}, {"role": "user", "content": "png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,\n   png_charp profile, int profile_len)\n{\n#ifdef PNG_USE_LOCAL_ARRAYS\n   PNG_iCCP;\n#endif\n   png_size_t name_len;\n   png_charp new_name;\n   compression_state comp;\n   int embedded_profile_len = 0;\n\n   png_debug(1, \"in png_write_iCCP\");\n\n   comp.num_output_ptr = 0;\n   comp.max_output_ptr = 0;\n   comp.output_ptr = NULL;\n   comp.input = NULL;\n   comp.input_len = 0;\n\n   if ((name_len = png_check_keyword(png_ptr, name,\n      &new_name)) == 0)\n      return;\n\n   if (compression_type != PNG_COMPRESSION_TYPE_BASE)\n      png_warning(png_ptr, \"Unknown compression type in iCCP chunk\");\n\n   if (profile == NULL)\n      profile_len = 0;\n\n   if (profile_len > 3)\n      embedded_profile_len =\n          ((*( (png_bytep)profile    ))<<24) |\n          ((*( (png_bytep)profile + 1))<<16) |\n          ((*( (png_bytep)profile + 2))<< 8) |\n          ((*( (png_bytep)profile + 3))    );\n\n   if (embedded_profile_len < 0)\n   {\n      png_warning(png_ptr,\n        \"Embedded profile length in iCCP chunk is negative\");\n      png_free(png_ptr, new_name);\n      return;\n   }\n\n   if (profile_len < embedded_profile_len)\n   {\n      png_warning(png_ptr,\n        \"Embedded profile length too large in iCCP chunk\");\n      png_free(png_ptr, new_name);\n      return;\n   }\n\n   if (profile_len > embedded_profile_len)\n   {\n      png_warning(png_ptr,\n        \"Truncating profile to actual length in iCCP chunk\");\n      profile_len = embedded_profile_len;\n   }\n\n   if (profile_len)\n      profile_len = png_text_compress(png_ptr, profile,\n        (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp);\n\n   /* Make sure we include the NULL after the name and the compression type */\n   png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,\n          (png_uint_32)(name_len + profile_len + 2));\n   new_name[name_len + 1] = 0x00;\n   png_write_chunk_data(png_ptr, (png_bytep)new_name,\n     (png_size_t)(name_len + 2));\n\n   if (profile_len)\n      png_write_compressed_data_out(png_ptr, &comp);\n\n   png_write_chunk_end(png_ptr);\n   png_free(png_ptr, new_name);\n}"}, {"role": "assistant", "content": "Vulnerability Class: vul 0\nCWE Number: CWE: CWE-119"}]}
